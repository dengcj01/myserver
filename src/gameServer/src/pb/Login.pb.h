// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: Login.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_Login_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_Login_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3020000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3020003 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_bases.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_Login_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_Login_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_Login_2eproto;
class ReqCreatePlayer;
struct ReqCreatePlayerDefaultTypeInternal;
extern ReqCreatePlayerDefaultTypeInternal _ReqCreatePlayer_default_instance_;
class ReqEnterGame;
struct ReqEnterGameDefaultTypeInternal;
extern ReqEnterGameDefaultTypeInternal _ReqEnterGame_default_instance_;
class ReqLoginAuth;
struct ReqLoginAuthDefaultTypeInternal;
extern ReqLoginAuthDefaultTypeInternal _ReqLoginAuth_default_instance_;
class ReqSelectPlayer;
struct ReqSelectPlayerDefaultTypeInternal;
extern ReqSelectPlayerDefaultTypeInternal _ReqSelectPlayer_default_instance_;
class ResCreatePlayer;
struct ResCreatePlayerDefaultTypeInternal;
extern ResCreatePlayerDefaultTypeInternal _ResCreatePlayer_default_instance_;
class ResEnterGame;
struct ResEnterGameDefaultTypeInternal;
extern ResEnterGameDefaultTypeInternal _ResEnterGame_default_instance_;
class ResLoginAuth;
struct ResLoginAuthDefaultTypeInternal;
extern ResLoginAuthDefaultTypeInternal _ResLoginAuth_default_instance_;
class ResSelectPlayer;
struct ResSelectPlayerDefaultTypeInternal;
extern ResSelectPlayerDefaultTypeInternal _ResSelectPlayer_default_instance_;
class ResServerCloseClient;
struct ResServerCloseClientDefaultTypeInternal;
extern ResServerCloseClientDefaultTypeInternal _ResServerCloseClient_default_instance_;
PROTOBUF_NAMESPACE_OPEN
template<> ::ReqCreatePlayer* Arena::CreateMaybeMessage<::ReqCreatePlayer>(Arena*);
template<> ::ReqEnterGame* Arena::CreateMaybeMessage<::ReqEnterGame>(Arena*);
template<> ::ReqLoginAuth* Arena::CreateMaybeMessage<::ReqLoginAuth>(Arena*);
template<> ::ReqSelectPlayer* Arena::CreateMaybeMessage<::ReqSelectPlayer>(Arena*);
template<> ::ResCreatePlayer* Arena::CreateMaybeMessage<::ResCreatePlayer>(Arena*);
template<> ::ResEnterGame* Arena::CreateMaybeMessage<::ResEnterGame>(Arena*);
template<> ::ResLoginAuth* Arena::CreateMaybeMessage<::ResLoginAuth>(Arena*);
template<> ::ResSelectPlayer* Arena::CreateMaybeMessage<::ResSelectPlayer>(Arena*);
template<> ::ResServerCloseClient* Arena::CreateMaybeMessage<::ResServerCloseClient>(Arena*);
PROTOBUF_NAMESPACE_CLOSE

// ===================================================================

class ReqLoginAuth final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ReqLoginAuth) */ {
 public:
  inline ReqLoginAuth() : ReqLoginAuth(nullptr) {}
  ~ReqLoginAuth() override;
  explicit PROTOBUF_CONSTEXPR ReqLoginAuth(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ReqLoginAuth(const ReqLoginAuth& from);
  ReqLoginAuth(ReqLoginAuth&& from) noexcept
    : ReqLoginAuth() {
    *this = ::std::move(from);
  }

  inline ReqLoginAuth& operator=(const ReqLoginAuth& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReqLoginAuth& operator=(ReqLoginAuth&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReqLoginAuth& default_instance() {
    return *internal_default_instance();
  }
  static inline const ReqLoginAuth* internal_default_instance() {
    return reinterpret_cast<const ReqLoginAuth*>(
               &_ReqLoginAuth_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(ReqLoginAuth& a, ReqLoginAuth& b) {
    a.Swap(&b);
  }
  inline void Swap(ReqLoginAuth* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReqLoginAuth* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReqLoginAuth* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ReqLoginAuth>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ReqLoginAuth& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ReqLoginAuth& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReqLoginAuth* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ReqLoginAuth";
  }
  protected:
  explicit ReqLoginAuth(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAccountFieldNumber = 2,
    kPasswordFieldNumber = 3,
    kPfFieldNumber = 4,
    kServerIdFieldNumber = 1,
    kFromServerIdFieldNumber = 5,
  };
  // string account = 2;
  void clear_account();
  const std::string& account() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_account(ArgT0&& arg0, ArgT... args);
  std::string* mutable_account();
  PROTOBUF_NODISCARD std::string* release_account();
  void set_allocated_account(std::string* account);
  private:
  const std::string& _internal_account() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_account(const std::string& value);
  std::string* _internal_mutable_account();
  public:

  // string password = 3;
  void clear_password();
  const std::string& password() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_password(ArgT0&& arg0, ArgT... args);
  std::string* mutable_password();
  PROTOBUF_NODISCARD std::string* release_password();
  void set_allocated_password(std::string* password);
  private:
  const std::string& _internal_password() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_password(const std::string& value);
  std::string* _internal_mutable_password();
  public:

  // string pf = 4;
  void clear_pf();
  const std::string& pf() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_pf(ArgT0&& arg0, ArgT... args);
  std::string* mutable_pf();
  PROTOBUF_NODISCARD std::string* release_pf();
  void set_allocated_pf(std::string* pf);
  private:
  const std::string& _internal_pf() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_pf(const std::string& value);
  std::string* _internal_mutable_pf();
  public:

  // sint32 serverId = 1;
  void clear_serverid();
  int32_t serverid() const;
  void set_serverid(int32_t value);
  private:
  int32_t _internal_serverid() const;
  void _internal_set_serverid(int32_t value);
  public:

  // sint32 fromServerId = 5;
  void clear_fromserverid();
  int32_t fromserverid() const;
  void set_fromserverid(int32_t value);
  private:
  int32_t _internal_fromserverid() const;
  void _internal_set_fromserverid(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:ReqLoginAuth)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr account_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr password_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr pf_;
  int32_t serverid_;
  int32_t fromserverid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Login_2eproto;
};
// -------------------------------------------------------------------

class ResLoginAuth final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ResLoginAuth) */ {
 public:
  inline ResLoginAuth() : ResLoginAuth(nullptr) {}
  ~ResLoginAuth() override;
  explicit PROTOBUF_CONSTEXPR ResLoginAuth(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ResLoginAuth(const ResLoginAuth& from);
  ResLoginAuth(ResLoginAuth&& from) noexcept
    : ResLoginAuth() {
    *this = ::std::move(from);
  }

  inline ResLoginAuth& operator=(const ResLoginAuth& from) {
    CopyFrom(from);
    return *this;
  }
  inline ResLoginAuth& operator=(ResLoginAuth&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ResLoginAuth& default_instance() {
    return *internal_default_instance();
  }
  static inline const ResLoginAuth* internal_default_instance() {
    return reinterpret_cast<const ResLoginAuth*>(
               &_ResLoginAuth_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(ResLoginAuth& a, ResLoginAuth& b) {
    a.Swap(&b);
  }
  inline void Swap(ResLoginAuth* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ResLoginAuth* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ResLoginAuth* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ResLoginAuth>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ResLoginAuth& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ResLoginAuth& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResLoginAuth* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ResLoginAuth";
  }
  protected:
  explicit ResLoginAuth(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCodeFieldNumber = 1,
  };
  // sint32 code = 1;
  void clear_code();
  int32_t code() const;
  void set_code(int32_t value);
  private:
  int32_t _internal_code() const;
  void _internal_set_code(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:ResLoginAuth)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int32_t code_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Login_2eproto;
};
// -------------------------------------------------------------------

class ReqSelectPlayer final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:ReqSelectPlayer) */ {
 public:
  inline ReqSelectPlayer() : ReqSelectPlayer(nullptr) {}
  explicit PROTOBUF_CONSTEXPR ReqSelectPlayer(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ReqSelectPlayer(const ReqSelectPlayer& from);
  ReqSelectPlayer(ReqSelectPlayer&& from) noexcept
    : ReqSelectPlayer() {
    *this = ::std::move(from);
  }

  inline ReqSelectPlayer& operator=(const ReqSelectPlayer& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReqSelectPlayer& operator=(ReqSelectPlayer&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReqSelectPlayer& default_instance() {
    return *internal_default_instance();
  }
  static inline const ReqSelectPlayer* internal_default_instance() {
    return reinterpret_cast<const ReqSelectPlayer*>(
               &_ReqSelectPlayer_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(ReqSelectPlayer& a, ReqSelectPlayer& b) {
    a.Swap(&b);
  }
  inline void Swap(ReqSelectPlayer* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReqSelectPlayer* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReqSelectPlayer* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ReqSelectPlayer>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const ReqSelectPlayer& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const ReqSelectPlayer& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ReqSelectPlayer";
  }
  protected:
  explicit ReqSelectPlayer(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:ReqSelectPlayer)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  friend struct ::TableStruct_Login_2eproto;
};
// -------------------------------------------------------------------

class ResSelectPlayer final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ResSelectPlayer) */ {
 public:
  inline ResSelectPlayer() : ResSelectPlayer(nullptr) {}
  ~ResSelectPlayer() override;
  explicit PROTOBUF_CONSTEXPR ResSelectPlayer(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ResSelectPlayer(const ResSelectPlayer& from);
  ResSelectPlayer(ResSelectPlayer&& from) noexcept
    : ResSelectPlayer() {
    *this = ::std::move(from);
  }

  inline ResSelectPlayer& operator=(const ResSelectPlayer& from) {
    CopyFrom(from);
    return *this;
  }
  inline ResSelectPlayer& operator=(ResSelectPlayer&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ResSelectPlayer& default_instance() {
    return *internal_default_instance();
  }
  static inline const ResSelectPlayer* internal_default_instance() {
    return reinterpret_cast<const ResSelectPlayer*>(
               &_ResSelectPlayer_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(ResSelectPlayer& a, ResSelectPlayer& b) {
    a.Swap(&b);
  }
  inline void Swap(ResSelectPlayer* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ResSelectPlayer* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ResSelectPlayer* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ResSelectPlayer>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ResSelectPlayer& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ResSelectPlayer& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResSelectPlayer* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ResSelectPlayer";
  }
  protected:
  explicit ResSelectPlayer(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPidFieldNumber = 1,
    kCodeFieldNumber = 2,
  };
  // uint64 pid = 1;
  void clear_pid();
  uint64_t pid() const;
  void set_pid(uint64_t value);
  private:
  uint64_t _internal_pid() const;
  void _internal_set_pid(uint64_t value);
  public:

  // sint32 code = 2;
  void clear_code();
  int32_t code() const;
  void set_code(int32_t value);
  private:
  int32_t _internal_code() const;
  void _internal_set_code(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:ResSelectPlayer)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  uint64_t pid_;
  int32_t code_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Login_2eproto;
};
// -------------------------------------------------------------------

class ReqCreatePlayer final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ReqCreatePlayer) */ {
 public:
  inline ReqCreatePlayer() : ReqCreatePlayer(nullptr) {}
  ~ReqCreatePlayer() override;
  explicit PROTOBUF_CONSTEXPR ReqCreatePlayer(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ReqCreatePlayer(const ReqCreatePlayer& from);
  ReqCreatePlayer(ReqCreatePlayer&& from) noexcept
    : ReqCreatePlayer() {
    *this = ::std::move(from);
  }

  inline ReqCreatePlayer& operator=(const ReqCreatePlayer& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReqCreatePlayer& operator=(ReqCreatePlayer&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReqCreatePlayer& default_instance() {
    return *internal_default_instance();
  }
  static inline const ReqCreatePlayer* internal_default_instance() {
    return reinterpret_cast<const ReqCreatePlayer*>(
               &_ReqCreatePlayer_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(ReqCreatePlayer& a, ReqCreatePlayer& b) {
    a.Swap(&b);
  }
  inline void Swap(ReqCreatePlayer* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReqCreatePlayer* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReqCreatePlayer* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ReqCreatePlayer>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ReqCreatePlayer& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ReqCreatePlayer& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReqCreatePlayer* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ReqCreatePlayer";
  }
  protected:
  explicit ReqCreatePlayer(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 2,
    kSexFieldNumber = 1,
  };
  // bytes name = 2;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // sint32 sex = 1;
  void clear_sex();
  int32_t sex() const;
  void set_sex(int32_t value);
  private:
  int32_t _internal_sex() const;
  void _internal_set_sex(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:ReqCreatePlayer)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  int32_t sex_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Login_2eproto;
};
// -------------------------------------------------------------------

class ResCreatePlayer final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ResCreatePlayer) */ {
 public:
  inline ResCreatePlayer() : ResCreatePlayer(nullptr) {}
  ~ResCreatePlayer() override;
  explicit PROTOBUF_CONSTEXPR ResCreatePlayer(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ResCreatePlayer(const ResCreatePlayer& from);
  ResCreatePlayer(ResCreatePlayer&& from) noexcept
    : ResCreatePlayer() {
    *this = ::std::move(from);
  }

  inline ResCreatePlayer& operator=(const ResCreatePlayer& from) {
    CopyFrom(from);
    return *this;
  }
  inline ResCreatePlayer& operator=(ResCreatePlayer&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ResCreatePlayer& default_instance() {
    return *internal_default_instance();
  }
  static inline const ResCreatePlayer* internal_default_instance() {
    return reinterpret_cast<const ResCreatePlayer*>(
               &_ResCreatePlayer_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(ResCreatePlayer& a, ResCreatePlayer& b) {
    a.Swap(&b);
  }
  inline void Swap(ResCreatePlayer* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ResCreatePlayer* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ResCreatePlayer* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ResCreatePlayer>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ResCreatePlayer& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ResCreatePlayer& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResCreatePlayer* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ResCreatePlayer";
  }
  protected:
  explicit ResCreatePlayer(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 2,
    kSexFieldNumber = 1,
    kCodeFieldNumber = 4,
    kPidFieldNumber = 3,
  };
  // bytes name = 2;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // sint32 sex = 1;
  void clear_sex();
  int32_t sex() const;
  void set_sex(int32_t value);
  private:
  int32_t _internal_sex() const;
  void _internal_set_sex(int32_t value);
  public:

  // sint32 code = 4;
  void clear_code();
  int32_t code() const;
  void set_code(int32_t value);
  private:
  int32_t _internal_code() const;
  void _internal_set_code(int32_t value);
  public:

  // uint64 pid = 3;
  void clear_pid();
  uint64_t pid() const;
  void set_pid(uint64_t value);
  private:
  uint64_t _internal_pid() const;
  void _internal_set_pid(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:ResCreatePlayer)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  int32_t sex_;
  int32_t code_;
  uint64_t pid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Login_2eproto;
};
// -------------------------------------------------------------------

class ReqEnterGame final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ReqEnterGame) */ {
 public:
  inline ReqEnterGame() : ReqEnterGame(nullptr) {}
  ~ReqEnterGame() override;
  explicit PROTOBUF_CONSTEXPR ReqEnterGame(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ReqEnterGame(const ReqEnterGame& from);
  ReqEnterGame(ReqEnterGame&& from) noexcept
    : ReqEnterGame() {
    *this = ::std::move(from);
  }

  inline ReqEnterGame& operator=(const ReqEnterGame& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReqEnterGame& operator=(ReqEnterGame&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReqEnterGame& default_instance() {
    return *internal_default_instance();
  }
  static inline const ReqEnterGame* internal_default_instance() {
    return reinterpret_cast<const ReqEnterGame*>(
               &_ReqEnterGame_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(ReqEnterGame& a, ReqEnterGame& b) {
    a.Swap(&b);
  }
  inline void Swap(ReqEnterGame* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReqEnterGame* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReqEnterGame* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ReqEnterGame>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ReqEnterGame& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ReqEnterGame& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReqEnterGame* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ReqEnterGame";
  }
  protected:
  explicit ReqEnterGame(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPidFieldNumber = 1,
  };
  // uint64 pid = 1;
  void clear_pid();
  uint64_t pid() const;
  void set_pid(uint64_t value);
  private:
  uint64_t _internal_pid() const;
  void _internal_set_pid(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:ReqEnterGame)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  uint64_t pid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Login_2eproto;
};
// -------------------------------------------------------------------

class ResEnterGame final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ResEnterGame) */ {
 public:
  inline ResEnterGame() : ResEnterGame(nullptr) {}
  ~ResEnterGame() override;
  explicit PROTOBUF_CONSTEXPR ResEnterGame(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ResEnterGame(const ResEnterGame& from);
  ResEnterGame(ResEnterGame&& from) noexcept
    : ResEnterGame() {
    *this = ::std::move(from);
  }

  inline ResEnterGame& operator=(const ResEnterGame& from) {
    CopyFrom(from);
    return *this;
  }
  inline ResEnterGame& operator=(ResEnterGame&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ResEnterGame& default_instance() {
    return *internal_default_instance();
  }
  static inline const ResEnterGame* internal_default_instance() {
    return reinterpret_cast<const ResEnterGame*>(
               &_ResEnterGame_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(ResEnterGame& a, ResEnterGame& b) {
    a.Swap(&b);
  }
  inline void Swap(ResEnterGame* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ResEnterGame* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ResEnterGame* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ResEnterGame>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ResEnterGame& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ResEnterGame& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResEnterGame* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ResEnterGame";
  }
  protected:
  explicit ResEnterGame(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCodeFieldNumber = 1,
  };
  // sint32 code = 1;
  void clear_code();
  int32_t code() const;
  void set_code(int32_t value);
  private:
  int32_t _internal_code() const;
  void _internal_set_code(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:ResEnterGame)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int32_t code_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Login_2eproto;
};
// -------------------------------------------------------------------

class ResServerCloseClient final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:ResServerCloseClient) */ {
 public:
  inline ResServerCloseClient() : ResServerCloseClient(nullptr) {}
  explicit PROTOBUF_CONSTEXPR ResServerCloseClient(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ResServerCloseClient(const ResServerCloseClient& from);
  ResServerCloseClient(ResServerCloseClient&& from) noexcept
    : ResServerCloseClient() {
    *this = ::std::move(from);
  }

  inline ResServerCloseClient& operator=(const ResServerCloseClient& from) {
    CopyFrom(from);
    return *this;
  }
  inline ResServerCloseClient& operator=(ResServerCloseClient&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ResServerCloseClient& default_instance() {
    return *internal_default_instance();
  }
  static inline const ResServerCloseClient* internal_default_instance() {
    return reinterpret_cast<const ResServerCloseClient*>(
               &_ResServerCloseClient_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(ResServerCloseClient& a, ResServerCloseClient& b) {
    a.Swap(&b);
  }
  inline void Swap(ResServerCloseClient* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ResServerCloseClient* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ResServerCloseClient* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ResServerCloseClient>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const ResServerCloseClient& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const ResServerCloseClient& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ResServerCloseClient";
  }
  protected:
  explicit ResServerCloseClient(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:ResServerCloseClient)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  friend struct ::TableStruct_Login_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// ReqLoginAuth

// sint32 serverId = 1;
inline void ReqLoginAuth::clear_serverid() {
  serverid_ = 0;
}
inline int32_t ReqLoginAuth::_internal_serverid() const {
  return serverid_;
}
inline int32_t ReqLoginAuth::serverid() const {
  // @@protoc_insertion_point(field_get:ReqLoginAuth.serverId)
  return _internal_serverid();
}
inline void ReqLoginAuth::_internal_set_serverid(int32_t value) {
  
  serverid_ = value;
}
inline void ReqLoginAuth::set_serverid(int32_t value) {
  _internal_set_serverid(value);
  // @@protoc_insertion_point(field_set:ReqLoginAuth.serverId)
}

// string account = 2;
inline void ReqLoginAuth::clear_account() {
  account_.ClearToEmpty();
}
inline const std::string& ReqLoginAuth::account() const {
  // @@protoc_insertion_point(field_get:ReqLoginAuth.account)
  return _internal_account();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ReqLoginAuth::set_account(ArgT0&& arg0, ArgT... args) {
 
 account_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ReqLoginAuth.account)
}
inline std::string* ReqLoginAuth::mutable_account() {
  std::string* _s = _internal_mutable_account();
  // @@protoc_insertion_point(field_mutable:ReqLoginAuth.account)
  return _s;
}
inline const std::string& ReqLoginAuth::_internal_account() const {
  return account_.Get();
}
inline void ReqLoginAuth::_internal_set_account(const std::string& value) {
  
  account_.Set(value, GetArenaForAllocation());
}
inline std::string* ReqLoginAuth::_internal_mutable_account() {
  
  return account_.Mutable(GetArenaForAllocation());
}
inline std::string* ReqLoginAuth::release_account() {
  // @@protoc_insertion_point(field_release:ReqLoginAuth.account)
  return account_.Release();
}
inline void ReqLoginAuth::set_allocated_account(std::string* account) {
  if (account != nullptr) {
    
  } else {
    
  }
  account_.SetAllocated(account, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (account_.IsDefault()) {
    account_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ReqLoginAuth.account)
}

// string password = 3;
inline void ReqLoginAuth::clear_password() {
  password_.ClearToEmpty();
}
inline const std::string& ReqLoginAuth::password() const {
  // @@protoc_insertion_point(field_get:ReqLoginAuth.password)
  return _internal_password();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ReqLoginAuth::set_password(ArgT0&& arg0, ArgT... args) {
 
 password_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ReqLoginAuth.password)
}
inline std::string* ReqLoginAuth::mutable_password() {
  std::string* _s = _internal_mutable_password();
  // @@protoc_insertion_point(field_mutable:ReqLoginAuth.password)
  return _s;
}
inline const std::string& ReqLoginAuth::_internal_password() const {
  return password_.Get();
}
inline void ReqLoginAuth::_internal_set_password(const std::string& value) {
  
  password_.Set(value, GetArenaForAllocation());
}
inline std::string* ReqLoginAuth::_internal_mutable_password() {
  
  return password_.Mutable(GetArenaForAllocation());
}
inline std::string* ReqLoginAuth::release_password() {
  // @@protoc_insertion_point(field_release:ReqLoginAuth.password)
  return password_.Release();
}
inline void ReqLoginAuth::set_allocated_password(std::string* password) {
  if (password != nullptr) {
    
  } else {
    
  }
  password_.SetAllocated(password, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (password_.IsDefault()) {
    password_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ReqLoginAuth.password)
}

// string pf = 4;
inline void ReqLoginAuth::clear_pf() {
  pf_.ClearToEmpty();
}
inline const std::string& ReqLoginAuth::pf() const {
  // @@protoc_insertion_point(field_get:ReqLoginAuth.pf)
  return _internal_pf();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ReqLoginAuth::set_pf(ArgT0&& arg0, ArgT... args) {
 
 pf_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ReqLoginAuth.pf)
}
inline std::string* ReqLoginAuth::mutable_pf() {
  std::string* _s = _internal_mutable_pf();
  // @@protoc_insertion_point(field_mutable:ReqLoginAuth.pf)
  return _s;
}
inline const std::string& ReqLoginAuth::_internal_pf() const {
  return pf_.Get();
}
inline void ReqLoginAuth::_internal_set_pf(const std::string& value) {
  
  pf_.Set(value, GetArenaForAllocation());
}
inline std::string* ReqLoginAuth::_internal_mutable_pf() {
  
  return pf_.Mutable(GetArenaForAllocation());
}
inline std::string* ReqLoginAuth::release_pf() {
  // @@protoc_insertion_point(field_release:ReqLoginAuth.pf)
  return pf_.Release();
}
inline void ReqLoginAuth::set_allocated_pf(std::string* pf) {
  if (pf != nullptr) {
    
  } else {
    
  }
  pf_.SetAllocated(pf, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (pf_.IsDefault()) {
    pf_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ReqLoginAuth.pf)
}

// sint32 fromServerId = 5;
inline void ReqLoginAuth::clear_fromserverid() {
  fromserverid_ = 0;
}
inline int32_t ReqLoginAuth::_internal_fromserverid() const {
  return fromserverid_;
}
inline int32_t ReqLoginAuth::fromserverid() const {
  // @@protoc_insertion_point(field_get:ReqLoginAuth.fromServerId)
  return _internal_fromserverid();
}
inline void ReqLoginAuth::_internal_set_fromserverid(int32_t value) {
  
  fromserverid_ = value;
}
inline void ReqLoginAuth::set_fromserverid(int32_t value) {
  _internal_set_fromserverid(value);
  // @@protoc_insertion_point(field_set:ReqLoginAuth.fromServerId)
}

// -------------------------------------------------------------------

// ResLoginAuth

// sint32 code = 1;
inline void ResLoginAuth::clear_code() {
  code_ = 0;
}
inline int32_t ResLoginAuth::_internal_code() const {
  return code_;
}
inline int32_t ResLoginAuth::code() const {
  // @@protoc_insertion_point(field_get:ResLoginAuth.code)
  return _internal_code();
}
inline void ResLoginAuth::_internal_set_code(int32_t value) {
  
  code_ = value;
}
inline void ResLoginAuth::set_code(int32_t value) {
  _internal_set_code(value);
  // @@protoc_insertion_point(field_set:ResLoginAuth.code)
}

// -------------------------------------------------------------------

// ReqSelectPlayer

// -------------------------------------------------------------------

// ResSelectPlayer

// uint64 pid = 1;
inline void ResSelectPlayer::clear_pid() {
  pid_ = uint64_t{0u};
}
inline uint64_t ResSelectPlayer::_internal_pid() const {
  return pid_;
}
inline uint64_t ResSelectPlayer::pid() const {
  // @@protoc_insertion_point(field_get:ResSelectPlayer.pid)
  return _internal_pid();
}
inline void ResSelectPlayer::_internal_set_pid(uint64_t value) {
  
  pid_ = value;
}
inline void ResSelectPlayer::set_pid(uint64_t value) {
  _internal_set_pid(value);
  // @@protoc_insertion_point(field_set:ResSelectPlayer.pid)
}

// sint32 code = 2;
inline void ResSelectPlayer::clear_code() {
  code_ = 0;
}
inline int32_t ResSelectPlayer::_internal_code() const {
  return code_;
}
inline int32_t ResSelectPlayer::code() const {
  // @@protoc_insertion_point(field_get:ResSelectPlayer.code)
  return _internal_code();
}
inline void ResSelectPlayer::_internal_set_code(int32_t value) {
  
  code_ = value;
}
inline void ResSelectPlayer::set_code(int32_t value) {
  _internal_set_code(value);
  // @@protoc_insertion_point(field_set:ResSelectPlayer.code)
}

// -------------------------------------------------------------------

// ReqCreatePlayer

// sint32 sex = 1;
inline void ReqCreatePlayer::clear_sex() {
  sex_ = 0;
}
inline int32_t ReqCreatePlayer::_internal_sex() const {
  return sex_;
}
inline int32_t ReqCreatePlayer::sex() const {
  // @@protoc_insertion_point(field_get:ReqCreatePlayer.sex)
  return _internal_sex();
}
inline void ReqCreatePlayer::_internal_set_sex(int32_t value) {
  
  sex_ = value;
}
inline void ReqCreatePlayer::set_sex(int32_t value) {
  _internal_set_sex(value);
  // @@protoc_insertion_point(field_set:ReqCreatePlayer.sex)
}

// bytes name = 2;
inline void ReqCreatePlayer::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& ReqCreatePlayer::name() const {
  // @@protoc_insertion_point(field_get:ReqCreatePlayer.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ReqCreatePlayer::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ReqCreatePlayer.name)
}
inline std::string* ReqCreatePlayer::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:ReqCreatePlayer.name)
  return _s;
}
inline const std::string& ReqCreatePlayer::_internal_name() const {
  return name_.Get();
}
inline void ReqCreatePlayer::_internal_set_name(const std::string& value) {
  
  name_.Set(value, GetArenaForAllocation());
}
inline std::string* ReqCreatePlayer::_internal_mutable_name() {
  
  return name_.Mutable(GetArenaForAllocation());
}
inline std::string* ReqCreatePlayer::release_name() {
  // @@protoc_insertion_point(field_release:ReqCreatePlayer.name)
  return name_.Release();
}
inline void ReqCreatePlayer::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (name_.IsDefault()) {
    name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ReqCreatePlayer.name)
}

// -------------------------------------------------------------------

// ResCreatePlayer

// sint32 sex = 1;
inline void ResCreatePlayer::clear_sex() {
  sex_ = 0;
}
inline int32_t ResCreatePlayer::_internal_sex() const {
  return sex_;
}
inline int32_t ResCreatePlayer::sex() const {
  // @@protoc_insertion_point(field_get:ResCreatePlayer.sex)
  return _internal_sex();
}
inline void ResCreatePlayer::_internal_set_sex(int32_t value) {
  
  sex_ = value;
}
inline void ResCreatePlayer::set_sex(int32_t value) {
  _internal_set_sex(value);
  // @@protoc_insertion_point(field_set:ResCreatePlayer.sex)
}

// bytes name = 2;
inline void ResCreatePlayer::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& ResCreatePlayer::name() const {
  // @@protoc_insertion_point(field_get:ResCreatePlayer.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ResCreatePlayer::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ResCreatePlayer.name)
}
inline std::string* ResCreatePlayer::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:ResCreatePlayer.name)
  return _s;
}
inline const std::string& ResCreatePlayer::_internal_name() const {
  return name_.Get();
}
inline void ResCreatePlayer::_internal_set_name(const std::string& value) {
  
  name_.Set(value, GetArenaForAllocation());
}
inline std::string* ResCreatePlayer::_internal_mutable_name() {
  
  return name_.Mutable(GetArenaForAllocation());
}
inline std::string* ResCreatePlayer::release_name() {
  // @@protoc_insertion_point(field_release:ResCreatePlayer.name)
  return name_.Release();
}
inline void ResCreatePlayer::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (name_.IsDefault()) {
    name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ResCreatePlayer.name)
}

// uint64 pid = 3;
inline void ResCreatePlayer::clear_pid() {
  pid_ = uint64_t{0u};
}
inline uint64_t ResCreatePlayer::_internal_pid() const {
  return pid_;
}
inline uint64_t ResCreatePlayer::pid() const {
  // @@protoc_insertion_point(field_get:ResCreatePlayer.pid)
  return _internal_pid();
}
inline void ResCreatePlayer::_internal_set_pid(uint64_t value) {
  
  pid_ = value;
}
inline void ResCreatePlayer::set_pid(uint64_t value) {
  _internal_set_pid(value);
  // @@protoc_insertion_point(field_set:ResCreatePlayer.pid)
}

// sint32 code = 4;
inline void ResCreatePlayer::clear_code() {
  code_ = 0;
}
inline int32_t ResCreatePlayer::_internal_code() const {
  return code_;
}
inline int32_t ResCreatePlayer::code() const {
  // @@protoc_insertion_point(field_get:ResCreatePlayer.code)
  return _internal_code();
}
inline void ResCreatePlayer::_internal_set_code(int32_t value) {
  
  code_ = value;
}
inline void ResCreatePlayer::set_code(int32_t value) {
  _internal_set_code(value);
  // @@protoc_insertion_point(field_set:ResCreatePlayer.code)
}

// -------------------------------------------------------------------

// ReqEnterGame

// uint64 pid = 1;
inline void ReqEnterGame::clear_pid() {
  pid_ = uint64_t{0u};
}
inline uint64_t ReqEnterGame::_internal_pid() const {
  return pid_;
}
inline uint64_t ReqEnterGame::pid() const {
  // @@protoc_insertion_point(field_get:ReqEnterGame.pid)
  return _internal_pid();
}
inline void ReqEnterGame::_internal_set_pid(uint64_t value) {
  
  pid_ = value;
}
inline void ReqEnterGame::set_pid(uint64_t value) {
  _internal_set_pid(value);
  // @@protoc_insertion_point(field_set:ReqEnterGame.pid)
}

// -------------------------------------------------------------------

// ResEnterGame

// sint32 code = 1;
inline void ResEnterGame::clear_code() {
  code_ = 0;
}
inline int32_t ResEnterGame::_internal_code() const {
  return code_;
}
inline int32_t ResEnterGame::code() const {
  // @@protoc_insertion_point(field_get:ResEnterGame.code)
  return _internal_code();
}
inline void ResEnterGame::_internal_set_code(int32_t value) {
  
  code_ = value;
}
inline void ResEnterGame::set_code(int32_t value) {
  _internal_set_code(value);
  // @@protoc_insertion_point(field_set:ResEnterGame.code)
}

// -------------------------------------------------------------------

// ResServerCloseClient

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_Login_2eproto
