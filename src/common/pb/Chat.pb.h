// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: Chat.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_Chat_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_Chat_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3020000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3020003 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include "Player.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_Chat_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_Chat_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_Chat_2eproto;
class AllChatData;
struct AllChatDataDefaultTypeInternal;
extern AllChatDataDefaultTypeInternal _AllChatData_default_instance_;
class ChatData;
struct ChatDataDefaultTypeInternal;
extern ChatDataDefaultTypeInternal _ChatData_default_instance_;
class NotifyAddNewChat;
struct NotifyAddNewChatDefaultTypeInternal;
extern NotifyAddNewChatDefaultTypeInternal _NotifyAddNewChat_default_instance_;
class ReqAddNewChatData;
struct ReqAddNewChatDataDefaultTypeInternal;
extern ReqAddNewChatDataDefaultTypeInternal _ReqAddNewChatData_default_instance_;
class ReqChatInfo;
struct ReqChatInfoDefaultTypeInternal;
extern ReqChatInfoDefaultTypeInternal _ReqChatInfo_default_instance_;
class ReqCrossSendChat;
struct ReqCrossSendChatDefaultTypeInternal;
extern ReqCrossSendChatDefaultTypeInternal _ReqCrossSendChat_default_instance_;
class ReqGetCrossChatData;
struct ReqGetCrossChatDataDefaultTypeInternal;
extern ReqGetCrossChatDataDefaultTypeInternal _ReqGetCrossChatData_default_instance_;
class ReqSendChat;
struct ReqSendChatDefaultTypeInternal;
extern ReqSendChatDefaultTypeInternal _ReqSendChat_default_instance_;
class ResChatInfo;
struct ResChatInfoDefaultTypeInternal;
extern ResChatInfoDefaultTypeInternal _ResChatInfo_default_instance_;
class ResCrossPlayerBaseInfo;
struct ResCrossPlayerBaseInfoDefaultTypeInternal;
extern ResCrossPlayerBaseInfoDefaultTypeInternal _ResCrossPlayerBaseInfo_default_instance_;
class ResCrossSendChat;
struct ResCrossSendChatDefaultTypeInternal;
extern ResCrossSendChatDefaultTypeInternal _ResCrossSendChat_default_instance_;
PROTOBUF_NAMESPACE_OPEN
template<> ::AllChatData* Arena::CreateMaybeMessage<::AllChatData>(Arena*);
template<> ::ChatData* Arena::CreateMaybeMessage<::ChatData>(Arena*);
template<> ::NotifyAddNewChat* Arena::CreateMaybeMessage<::NotifyAddNewChat>(Arena*);
template<> ::ReqAddNewChatData* Arena::CreateMaybeMessage<::ReqAddNewChatData>(Arena*);
template<> ::ReqChatInfo* Arena::CreateMaybeMessage<::ReqChatInfo>(Arena*);
template<> ::ReqCrossSendChat* Arena::CreateMaybeMessage<::ReqCrossSendChat>(Arena*);
template<> ::ReqGetCrossChatData* Arena::CreateMaybeMessage<::ReqGetCrossChatData>(Arena*);
template<> ::ReqSendChat* Arena::CreateMaybeMessage<::ReqSendChat>(Arena*);
template<> ::ResChatInfo* Arena::CreateMaybeMessage<::ResChatInfo>(Arena*);
template<> ::ResCrossPlayerBaseInfo* Arena::CreateMaybeMessage<::ResCrossPlayerBaseInfo>(Arena*);
template<> ::ResCrossSendChat* Arena::CreateMaybeMessage<::ResCrossSendChat>(Arena*);
PROTOBUF_NAMESPACE_CLOSE

// ===================================================================

class ChatData final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ChatData) */ {
 public:
  inline ChatData() : ChatData(nullptr) {}
  ~ChatData() override;
  explicit PROTOBUF_CONSTEXPR ChatData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ChatData(const ChatData& from);
  ChatData(ChatData&& from) noexcept
    : ChatData() {
    *this = ::std::move(from);
  }

  inline ChatData& operator=(const ChatData& from) {
    CopyFrom(from);
    return *this;
  }
  inline ChatData& operator=(ChatData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ChatData& default_instance() {
    return *internal_default_instance();
  }
  static inline const ChatData* internal_default_instance() {
    return reinterpret_cast<const ChatData*>(
               &_ChatData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(ChatData& a, ChatData& b) {
    a.Swap(&b);
  }
  inline void Swap(ChatData* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ChatData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ChatData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ChatData>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ChatData& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ChatData& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ChatData* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ChatData";
  }
  protected:
  explicit ChatData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPidFieldNumber = 1,
    kContentFieldNumber = 2,
    kSendTimeFieldNumber = 3,
  };
  // string pid = 1;
  void clear_pid();
  const std::string& pid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_pid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_pid();
  PROTOBUF_NODISCARD std::string* release_pid();
  void set_allocated_pid(std::string* pid);
  private:
  const std::string& _internal_pid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_pid(const std::string& value);
  std::string* _internal_mutable_pid();
  public:

  // string content = 2;
  void clear_content();
  const std::string& content() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_content(ArgT0&& arg0, ArgT... args);
  std::string* mutable_content();
  PROTOBUF_NODISCARD std::string* release_content();
  void set_allocated_content(std::string* content);
  private:
  const std::string& _internal_content() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_content(const std::string& value);
  std::string* _internal_mutable_content();
  public:

  // uint32 sendTime = 3;
  void clear_sendtime();
  uint32_t sendtime() const;
  void set_sendtime(uint32_t value);
  private:
  uint32_t _internal_sendtime() const;
  void _internal_set_sendtime(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:ChatData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr pid_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr content_;
  uint32_t sendtime_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Chat_2eproto;
};
// -------------------------------------------------------------------

class AllChatData final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:AllChatData) */ {
 public:
  inline AllChatData() : AllChatData(nullptr) {}
  ~AllChatData() override;
  explicit PROTOBUF_CONSTEXPR AllChatData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AllChatData(const AllChatData& from);
  AllChatData(AllChatData&& from) noexcept
    : AllChatData() {
    *this = ::std::move(from);
  }

  inline AllChatData& operator=(const AllChatData& from) {
    CopyFrom(from);
    return *this;
  }
  inline AllChatData& operator=(AllChatData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AllChatData& default_instance() {
    return *internal_default_instance();
  }
  static inline const AllChatData* internal_default_instance() {
    return reinterpret_cast<const AllChatData*>(
               &_AllChatData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(AllChatData& a, AllChatData& b) {
    a.Swap(&b);
  }
  inline void Swap(AllChatData* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AllChatData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AllChatData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AllChatData>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AllChatData& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const AllChatData& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AllChatData* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "AllChatData";
  }
  protected:
  explicit AllChatData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 2,
    kPidFieldNumber = 1,
  };
  // repeated .ChatData data = 2;
  int data_size() const;
  private:
  int _internal_data_size() const;
  public:
  void clear_data();
  ::ChatData* mutable_data(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ChatData >*
      mutable_data();
  private:
  const ::ChatData& _internal_data(int index) const;
  ::ChatData* _internal_add_data();
  public:
  const ::ChatData& data(int index) const;
  ::ChatData* add_data();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ChatData >&
      data() const;

  // string pid = 1;
  void clear_pid();
  const std::string& pid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_pid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_pid();
  PROTOBUF_NODISCARD std::string* release_pid();
  void set_allocated_pid(std::string* pid);
  private:
  const std::string& _internal_pid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_pid(const std::string& value);
  std::string* _internal_mutable_pid();
  public:

  // @@protoc_insertion_point(class_scope:AllChatData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ChatData > data_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr pid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Chat_2eproto;
};
// -------------------------------------------------------------------

class ReqChatInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ReqChatInfo) */ {
 public:
  inline ReqChatInfo() : ReqChatInfo(nullptr) {}
  ~ReqChatInfo() override;
  explicit PROTOBUF_CONSTEXPR ReqChatInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ReqChatInfo(const ReqChatInfo& from);
  ReqChatInfo(ReqChatInfo&& from) noexcept
    : ReqChatInfo() {
    *this = ::std::move(from);
  }

  inline ReqChatInfo& operator=(const ReqChatInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReqChatInfo& operator=(ReqChatInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReqChatInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const ReqChatInfo* internal_default_instance() {
    return reinterpret_cast<const ReqChatInfo*>(
               &_ReqChatInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(ReqChatInfo& a, ReqChatInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(ReqChatInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReqChatInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReqChatInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ReqChatInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ReqChatInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ReqChatInfo& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReqChatInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ReqChatInfo";
  }
  protected:
  explicit ReqChatInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kChannelFieldNumber = 1,
  };
  // int32 channel = 1;
  void clear_channel();
  int32_t channel() const;
  void set_channel(int32_t value);
  private:
  int32_t _internal_channel() const;
  void _internal_set_channel(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:ReqChatInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int32_t channel_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Chat_2eproto;
};
// -------------------------------------------------------------------

class ResChatInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ResChatInfo) */ {
 public:
  inline ResChatInfo() : ResChatInfo(nullptr) {}
  ~ResChatInfo() override;
  explicit PROTOBUF_CONSTEXPR ResChatInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ResChatInfo(const ResChatInfo& from);
  ResChatInfo(ResChatInfo&& from) noexcept
    : ResChatInfo() {
    *this = ::std::move(from);
  }

  inline ResChatInfo& operator=(const ResChatInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline ResChatInfo& operator=(ResChatInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ResChatInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const ResChatInfo* internal_default_instance() {
    return reinterpret_cast<const ResChatInfo*>(
               &_ResChatInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(ResChatInfo& a, ResChatInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(ResChatInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ResChatInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ResChatInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ResChatInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ResChatInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ResChatInfo& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResChatInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ResChatInfo";
  }
  protected:
  explicit ResChatInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBaseInfoFieldNumber = 2,
    kDataFieldNumber = 3,
    kChannelFieldNumber = 1,
  };
  // repeated .PayerBaseInfo baseInfo = 2;
  int baseinfo_size() const;
  private:
  int _internal_baseinfo_size() const;
  public:
  void clear_baseinfo();
  ::PayerBaseInfo* mutable_baseinfo(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PayerBaseInfo >*
      mutable_baseinfo();
  private:
  const ::PayerBaseInfo& _internal_baseinfo(int index) const;
  ::PayerBaseInfo* _internal_add_baseinfo();
  public:
  const ::PayerBaseInfo& baseinfo(int index) const;
  ::PayerBaseInfo* add_baseinfo();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PayerBaseInfo >&
      baseinfo() const;

  // repeated .AllChatData data = 3;
  int data_size() const;
  private:
  int _internal_data_size() const;
  public:
  void clear_data();
  ::AllChatData* mutable_data(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::AllChatData >*
      mutable_data();
  private:
  const ::AllChatData& _internal_data(int index) const;
  ::AllChatData* _internal_add_data();
  public:
  const ::AllChatData& data(int index) const;
  ::AllChatData* add_data();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::AllChatData >&
      data() const;

  // int32 channel = 1;
  void clear_channel();
  int32_t channel() const;
  void set_channel(int32_t value);
  private:
  int32_t _internal_channel() const;
  void _internal_set_channel(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:ResChatInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PayerBaseInfo > baseinfo_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::AllChatData > data_;
  int32_t channel_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Chat_2eproto;
};
// -------------------------------------------------------------------

class ReqSendChat final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ReqSendChat) */ {
 public:
  inline ReqSendChat() : ReqSendChat(nullptr) {}
  ~ReqSendChat() override;
  explicit PROTOBUF_CONSTEXPR ReqSendChat(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ReqSendChat(const ReqSendChat& from);
  ReqSendChat(ReqSendChat&& from) noexcept
    : ReqSendChat() {
    *this = ::std::move(from);
  }

  inline ReqSendChat& operator=(const ReqSendChat& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReqSendChat& operator=(ReqSendChat&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReqSendChat& default_instance() {
    return *internal_default_instance();
  }
  static inline const ReqSendChat* internal_default_instance() {
    return reinterpret_cast<const ReqSendChat*>(
               &_ReqSendChat_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(ReqSendChat& a, ReqSendChat& b) {
    a.Swap(&b);
  }
  inline void Swap(ReqSendChat* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReqSendChat* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReqSendChat* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ReqSendChat>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ReqSendChat& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ReqSendChat& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReqSendChat* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ReqSendChat";
  }
  protected:
  explicit ReqSendChat(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kContentFieldNumber = 2,
    kOtherPidFieldNumber = 3,
    kChannelFieldNumber = 1,
  };
  // string content = 2;
  void clear_content();
  const std::string& content() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_content(ArgT0&& arg0, ArgT... args);
  std::string* mutable_content();
  PROTOBUF_NODISCARD std::string* release_content();
  void set_allocated_content(std::string* content);
  private:
  const std::string& _internal_content() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_content(const std::string& value);
  std::string* _internal_mutable_content();
  public:

  // string otherPid = 3;
  void clear_otherpid();
  const std::string& otherpid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_otherpid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_otherpid();
  PROTOBUF_NODISCARD std::string* release_otherpid();
  void set_allocated_otherpid(std::string* otherpid);
  private:
  const std::string& _internal_otherpid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_otherpid(const std::string& value);
  std::string* _internal_mutable_otherpid();
  public:

  // int32 channel = 1;
  void clear_channel();
  int32_t channel() const;
  void set_channel(int32_t value);
  private:
  int32_t _internal_channel() const;
  void _internal_set_channel(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:ReqSendChat)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr content_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr otherpid_;
  int32_t channel_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Chat_2eproto;
};
// -------------------------------------------------------------------

class NotifyAddNewChat final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:NotifyAddNewChat) */ {
 public:
  inline NotifyAddNewChat() : NotifyAddNewChat(nullptr) {}
  ~NotifyAddNewChat() override;
  explicit PROTOBUF_CONSTEXPR NotifyAddNewChat(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NotifyAddNewChat(const NotifyAddNewChat& from);
  NotifyAddNewChat(NotifyAddNewChat&& from) noexcept
    : NotifyAddNewChat() {
    *this = ::std::move(from);
  }

  inline NotifyAddNewChat& operator=(const NotifyAddNewChat& from) {
    CopyFrom(from);
    return *this;
  }
  inline NotifyAddNewChat& operator=(NotifyAddNewChat&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NotifyAddNewChat& default_instance() {
    return *internal_default_instance();
  }
  static inline const NotifyAddNewChat* internal_default_instance() {
    return reinterpret_cast<const NotifyAddNewChat*>(
               &_NotifyAddNewChat_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(NotifyAddNewChat& a, NotifyAddNewChat& b) {
    a.Swap(&b);
  }
  inline void Swap(NotifyAddNewChat* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NotifyAddNewChat* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NotifyAddNewChat* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NotifyAddNewChat>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NotifyAddNewChat& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const NotifyAddNewChat& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NotifyAddNewChat* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "NotifyAddNewChat";
  }
  protected:
  explicit NotifyAddNewChat(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 2,
    kBaseInfoFieldNumber = 3,
    kChannelFieldNumber = 1,
  };
  // .ChatData data = 2;
  bool has_data() const;
  private:
  bool _internal_has_data() const;
  public:
  void clear_data();
  const ::ChatData& data() const;
  PROTOBUF_NODISCARD ::ChatData* release_data();
  ::ChatData* mutable_data();
  void set_allocated_data(::ChatData* data);
  private:
  const ::ChatData& _internal_data() const;
  ::ChatData* _internal_mutable_data();
  public:
  void unsafe_arena_set_allocated_data(
      ::ChatData* data);
  ::ChatData* unsafe_arena_release_data();

  // .PayerBaseInfo baseInfo = 3;
  bool has_baseinfo() const;
  private:
  bool _internal_has_baseinfo() const;
  public:
  void clear_baseinfo();
  const ::PayerBaseInfo& baseinfo() const;
  PROTOBUF_NODISCARD ::PayerBaseInfo* release_baseinfo();
  ::PayerBaseInfo* mutable_baseinfo();
  void set_allocated_baseinfo(::PayerBaseInfo* baseinfo);
  private:
  const ::PayerBaseInfo& _internal_baseinfo() const;
  ::PayerBaseInfo* _internal_mutable_baseinfo();
  public:
  void unsafe_arena_set_allocated_baseinfo(
      ::PayerBaseInfo* baseinfo);
  ::PayerBaseInfo* unsafe_arena_release_baseinfo();

  // int32 channel = 1;
  void clear_channel();
  int32_t channel() const;
  void set_channel(int32_t value);
  private:
  int32_t _internal_channel() const;
  void _internal_set_channel(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:NotifyAddNewChat)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::ChatData* data_;
  ::PayerBaseInfo* baseinfo_;
  int32_t channel_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Chat_2eproto;
};
// -------------------------------------------------------------------

class ReqGetCrossChatData final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ReqGetCrossChatData) */ {
 public:
  inline ReqGetCrossChatData() : ReqGetCrossChatData(nullptr) {}
  ~ReqGetCrossChatData() override;
  explicit PROTOBUF_CONSTEXPR ReqGetCrossChatData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ReqGetCrossChatData(const ReqGetCrossChatData& from);
  ReqGetCrossChatData(ReqGetCrossChatData&& from) noexcept
    : ReqGetCrossChatData() {
    *this = ::std::move(from);
  }

  inline ReqGetCrossChatData& operator=(const ReqGetCrossChatData& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReqGetCrossChatData& operator=(ReqGetCrossChatData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReqGetCrossChatData& default_instance() {
    return *internal_default_instance();
  }
  static inline const ReqGetCrossChatData* internal_default_instance() {
    return reinterpret_cast<const ReqGetCrossChatData*>(
               &_ReqGetCrossChatData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(ReqGetCrossChatData& a, ReqGetCrossChatData& b) {
    a.Swap(&b);
  }
  inline void Swap(ReqGetCrossChatData* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReqGetCrossChatData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReqGetCrossChatData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ReqGetCrossChatData>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ReqGetCrossChatData& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ReqGetCrossChatData& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReqGetCrossChatData* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ReqGetCrossChatData";
  }
  protected:
  explicit ReqGetCrossChatData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPidsFieldNumber = 3,
    kPidFieldNumber = 2,
    kChannelFieldNumber = 1,
  };
  // repeated string pids = 3;
  int pids_size() const;
  private:
  int _internal_pids_size() const;
  public:
  void clear_pids();
  const std::string& pids(int index) const;
  std::string* mutable_pids(int index);
  void set_pids(int index, const std::string& value);
  void set_pids(int index, std::string&& value);
  void set_pids(int index, const char* value);
  void set_pids(int index, const char* value, size_t size);
  std::string* add_pids();
  void add_pids(const std::string& value);
  void add_pids(std::string&& value);
  void add_pids(const char* value);
  void add_pids(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& pids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_pids();
  private:
  const std::string& _internal_pids(int index) const;
  std::string* _internal_add_pids();
  public:

  // string pid = 2;
  void clear_pid();
  const std::string& pid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_pid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_pid();
  PROTOBUF_NODISCARD std::string* release_pid();
  void set_allocated_pid(std::string* pid);
  private:
  const std::string& _internal_pid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_pid(const std::string& value);
  std::string* _internal_mutable_pid();
  public:

  // int32 channel = 1;
  void clear_channel();
  int32_t channel() const;
  void set_channel(int32_t value);
  private:
  int32_t _internal_channel() const;
  void _internal_set_channel(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:ReqGetCrossChatData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> pids_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr pid_;
  int32_t channel_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Chat_2eproto;
};
// -------------------------------------------------------------------

class ResCrossPlayerBaseInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ResCrossPlayerBaseInfo) */ {
 public:
  inline ResCrossPlayerBaseInfo() : ResCrossPlayerBaseInfo(nullptr) {}
  ~ResCrossPlayerBaseInfo() override;
  explicit PROTOBUF_CONSTEXPR ResCrossPlayerBaseInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ResCrossPlayerBaseInfo(const ResCrossPlayerBaseInfo& from);
  ResCrossPlayerBaseInfo(ResCrossPlayerBaseInfo&& from) noexcept
    : ResCrossPlayerBaseInfo() {
    *this = ::std::move(from);
  }

  inline ResCrossPlayerBaseInfo& operator=(const ResCrossPlayerBaseInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline ResCrossPlayerBaseInfo& operator=(ResCrossPlayerBaseInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ResCrossPlayerBaseInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const ResCrossPlayerBaseInfo* internal_default_instance() {
    return reinterpret_cast<const ResCrossPlayerBaseInfo*>(
               &_ResCrossPlayerBaseInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(ResCrossPlayerBaseInfo& a, ResCrossPlayerBaseInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(ResCrossPlayerBaseInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ResCrossPlayerBaseInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ResCrossPlayerBaseInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ResCrossPlayerBaseInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ResCrossPlayerBaseInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ResCrossPlayerBaseInfo& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResCrossPlayerBaseInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ResCrossPlayerBaseInfo";
  }
  protected:
  explicit ResCrossPlayerBaseInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBaseInfoFieldNumber = 1,
    kPidFieldNumber = 2,
    kChannelFieldNumber = 3,
  };
  // repeated .PayerBaseInfo baseInfo = 1;
  int baseinfo_size() const;
  private:
  int _internal_baseinfo_size() const;
  public:
  void clear_baseinfo();
  ::PayerBaseInfo* mutable_baseinfo(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PayerBaseInfo >*
      mutable_baseinfo();
  private:
  const ::PayerBaseInfo& _internal_baseinfo(int index) const;
  ::PayerBaseInfo* _internal_add_baseinfo();
  public:
  const ::PayerBaseInfo& baseinfo(int index) const;
  ::PayerBaseInfo* add_baseinfo();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PayerBaseInfo >&
      baseinfo() const;

  // string pid = 2;
  void clear_pid();
  const std::string& pid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_pid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_pid();
  PROTOBUF_NODISCARD std::string* release_pid();
  void set_allocated_pid(std::string* pid);
  private:
  const std::string& _internal_pid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_pid(const std::string& value);
  std::string* _internal_mutable_pid();
  public:

  // int32 channel = 3;
  void clear_channel();
  int32_t channel() const;
  void set_channel(int32_t value);
  private:
  int32_t _internal_channel() const;
  void _internal_set_channel(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:ResCrossPlayerBaseInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PayerBaseInfo > baseinfo_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr pid_;
  int32_t channel_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Chat_2eproto;
};
// -------------------------------------------------------------------

class ReqCrossSendChat final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ReqCrossSendChat) */ {
 public:
  inline ReqCrossSendChat() : ReqCrossSendChat(nullptr) {}
  ~ReqCrossSendChat() override;
  explicit PROTOBUF_CONSTEXPR ReqCrossSendChat(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ReqCrossSendChat(const ReqCrossSendChat& from);
  ReqCrossSendChat(ReqCrossSendChat&& from) noexcept
    : ReqCrossSendChat() {
    *this = ::std::move(from);
  }

  inline ReqCrossSendChat& operator=(const ReqCrossSendChat& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReqCrossSendChat& operator=(ReqCrossSendChat&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReqCrossSendChat& default_instance() {
    return *internal_default_instance();
  }
  static inline const ReqCrossSendChat* internal_default_instance() {
    return reinterpret_cast<const ReqCrossSendChat*>(
               &_ReqCrossSendChat_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(ReqCrossSendChat& a, ReqCrossSendChat& b) {
    a.Swap(&b);
  }
  inline void Swap(ReqCrossSendChat* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReqCrossSendChat* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReqCrossSendChat* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ReqCrossSendChat>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ReqCrossSendChat& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ReqCrossSendChat& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReqCrossSendChat* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ReqCrossSendChat";
  }
  protected:
  explicit ReqCrossSendChat(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kContentFieldNumber = 2,
    kOtherPidFieldNumber = 3,
    kPidFieldNumber = 4,
    kChannelFieldNumber = 1,
  };
  // string content = 2;
  void clear_content();
  const std::string& content() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_content(ArgT0&& arg0, ArgT... args);
  std::string* mutable_content();
  PROTOBUF_NODISCARD std::string* release_content();
  void set_allocated_content(std::string* content);
  private:
  const std::string& _internal_content() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_content(const std::string& value);
  std::string* _internal_mutable_content();
  public:

  // string otherPid = 3;
  void clear_otherpid();
  const std::string& otherpid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_otherpid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_otherpid();
  PROTOBUF_NODISCARD std::string* release_otherpid();
  void set_allocated_otherpid(std::string* otherpid);
  private:
  const std::string& _internal_otherpid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_otherpid(const std::string& value);
  std::string* _internal_mutable_otherpid();
  public:

  // string pid = 4;
  void clear_pid();
  const std::string& pid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_pid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_pid();
  PROTOBUF_NODISCARD std::string* release_pid();
  void set_allocated_pid(std::string* pid);
  private:
  const std::string& _internal_pid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_pid(const std::string& value);
  std::string* _internal_mutable_pid();
  public:

  // int32 channel = 1;
  void clear_channel();
  int32_t channel() const;
  void set_channel(int32_t value);
  private:
  int32_t _internal_channel() const;
  void _internal_set_channel(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:ReqCrossSendChat)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr content_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr otherpid_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr pid_;
  int32_t channel_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Chat_2eproto;
};
// -------------------------------------------------------------------

class ResCrossSendChat final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ResCrossSendChat) */ {
 public:
  inline ResCrossSendChat() : ResCrossSendChat(nullptr) {}
  ~ResCrossSendChat() override;
  explicit PROTOBUF_CONSTEXPR ResCrossSendChat(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ResCrossSendChat(const ResCrossSendChat& from);
  ResCrossSendChat(ResCrossSendChat&& from) noexcept
    : ResCrossSendChat() {
    *this = ::std::move(from);
  }

  inline ResCrossSendChat& operator=(const ResCrossSendChat& from) {
    CopyFrom(from);
    return *this;
  }
  inline ResCrossSendChat& operator=(ResCrossSendChat&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ResCrossSendChat& default_instance() {
    return *internal_default_instance();
  }
  static inline const ResCrossSendChat* internal_default_instance() {
    return reinterpret_cast<const ResCrossSendChat*>(
               &_ResCrossSendChat_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(ResCrossSendChat& a, ResCrossSendChat& b) {
    a.Swap(&b);
  }
  inline void Swap(ResCrossSendChat* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ResCrossSendChat* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ResCrossSendChat* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ResCrossSendChat>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ResCrossSendChat& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ResCrossSendChat& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResCrossSendChat* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ResCrossSendChat";
  }
  protected:
  explicit ResCrossSendChat(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBaseInfoFieldNumber = 3,
    kDataFieldNumber = 2,
    kChannelFieldNumber = 1,
  };
  // repeated .PayerBaseInfo baseInfo = 3;
  int baseinfo_size() const;
  private:
  int _internal_baseinfo_size() const;
  public:
  void clear_baseinfo();
  ::PayerBaseInfo* mutable_baseinfo(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PayerBaseInfo >*
      mutable_baseinfo();
  private:
  const ::PayerBaseInfo& _internal_baseinfo(int index) const;
  ::PayerBaseInfo* _internal_add_baseinfo();
  public:
  const ::PayerBaseInfo& baseinfo(int index) const;
  ::PayerBaseInfo* add_baseinfo();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PayerBaseInfo >&
      baseinfo() const;

  // .ChatData data = 2;
  bool has_data() const;
  private:
  bool _internal_has_data() const;
  public:
  void clear_data();
  const ::ChatData& data() const;
  PROTOBUF_NODISCARD ::ChatData* release_data();
  ::ChatData* mutable_data();
  void set_allocated_data(::ChatData* data);
  private:
  const ::ChatData& _internal_data() const;
  ::ChatData* _internal_mutable_data();
  public:
  void unsafe_arena_set_allocated_data(
      ::ChatData* data);
  ::ChatData* unsafe_arena_release_data();

  // int32 channel = 1;
  void clear_channel();
  int32_t channel() const;
  void set_channel(int32_t value);
  private:
  int32_t _internal_channel() const;
  void _internal_set_channel(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:ResCrossSendChat)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PayerBaseInfo > baseinfo_;
  ::ChatData* data_;
  int32_t channel_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Chat_2eproto;
};
// -------------------------------------------------------------------

class ReqAddNewChatData final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ReqAddNewChatData) */ {
 public:
  inline ReqAddNewChatData() : ReqAddNewChatData(nullptr) {}
  ~ReqAddNewChatData() override;
  explicit PROTOBUF_CONSTEXPR ReqAddNewChatData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ReqAddNewChatData(const ReqAddNewChatData& from);
  ReqAddNewChatData(ReqAddNewChatData&& from) noexcept
    : ReqAddNewChatData() {
    *this = ::std::move(from);
  }

  inline ReqAddNewChatData& operator=(const ReqAddNewChatData& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReqAddNewChatData& operator=(ReqAddNewChatData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReqAddNewChatData& default_instance() {
    return *internal_default_instance();
  }
  static inline const ReqAddNewChatData* internal_default_instance() {
    return reinterpret_cast<const ReqAddNewChatData*>(
               &_ReqAddNewChatData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(ReqAddNewChatData& a, ReqAddNewChatData& b) {
    a.Swap(&b);
  }
  inline void Swap(ReqAddNewChatData* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReqAddNewChatData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReqAddNewChatData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ReqAddNewChatData>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ReqAddNewChatData& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ReqAddNewChatData& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReqAddNewChatData* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ReqAddNewChatData";
  }
  protected:
  explicit ReqAddNewChatData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kContentFieldNumber = 2,
    kOtherPidFieldNumber = 3,
    kPidFieldNumber = 4,
    kChannelFieldNumber = 1,
  };
  // string content = 2;
  void clear_content();
  const std::string& content() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_content(ArgT0&& arg0, ArgT... args);
  std::string* mutable_content();
  PROTOBUF_NODISCARD std::string* release_content();
  void set_allocated_content(std::string* content);
  private:
  const std::string& _internal_content() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_content(const std::string& value);
  std::string* _internal_mutable_content();
  public:

  // string otherPid = 3;
  void clear_otherpid();
  const std::string& otherpid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_otherpid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_otherpid();
  PROTOBUF_NODISCARD std::string* release_otherpid();
  void set_allocated_otherpid(std::string* otherpid);
  private:
  const std::string& _internal_otherpid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_otherpid(const std::string& value);
  std::string* _internal_mutable_otherpid();
  public:

  // string pid = 4;
  void clear_pid();
  const std::string& pid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_pid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_pid();
  PROTOBUF_NODISCARD std::string* release_pid();
  void set_allocated_pid(std::string* pid);
  private:
  const std::string& _internal_pid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_pid(const std::string& value);
  std::string* _internal_mutable_pid();
  public:

  // int32 channel = 1;
  void clear_channel();
  int32_t channel() const;
  void set_channel(int32_t value);
  private:
  int32_t _internal_channel() const;
  void _internal_set_channel(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:ReqAddNewChatData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr content_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr otherpid_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr pid_;
  int32_t channel_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Chat_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// ChatData

// string pid = 1;
inline void ChatData::clear_pid() {
  pid_.ClearToEmpty();
}
inline const std::string& ChatData::pid() const {
  // @@protoc_insertion_point(field_get:ChatData.pid)
  return _internal_pid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ChatData::set_pid(ArgT0&& arg0, ArgT... args) {
 
 pid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ChatData.pid)
}
inline std::string* ChatData::mutable_pid() {
  std::string* _s = _internal_mutable_pid();
  // @@protoc_insertion_point(field_mutable:ChatData.pid)
  return _s;
}
inline const std::string& ChatData::_internal_pid() const {
  return pid_.Get();
}
inline void ChatData::_internal_set_pid(const std::string& value) {
  
  pid_.Set(value, GetArenaForAllocation());
}
inline std::string* ChatData::_internal_mutable_pid() {
  
  return pid_.Mutable(GetArenaForAllocation());
}
inline std::string* ChatData::release_pid() {
  // @@protoc_insertion_point(field_release:ChatData.pid)
  return pid_.Release();
}
inline void ChatData::set_allocated_pid(std::string* pid) {
  if (pid != nullptr) {
    
  } else {
    
  }
  pid_.SetAllocated(pid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (pid_.IsDefault()) {
    pid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ChatData.pid)
}

// string content = 2;
inline void ChatData::clear_content() {
  content_.ClearToEmpty();
}
inline const std::string& ChatData::content() const {
  // @@protoc_insertion_point(field_get:ChatData.content)
  return _internal_content();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ChatData::set_content(ArgT0&& arg0, ArgT... args) {
 
 content_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ChatData.content)
}
inline std::string* ChatData::mutable_content() {
  std::string* _s = _internal_mutable_content();
  // @@protoc_insertion_point(field_mutable:ChatData.content)
  return _s;
}
inline const std::string& ChatData::_internal_content() const {
  return content_.Get();
}
inline void ChatData::_internal_set_content(const std::string& value) {
  
  content_.Set(value, GetArenaForAllocation());
}
inline std::string* ChatData::_internal_mutable_content() {
  
  return content_.Mutable(GetArenaForAllocation());
}
inline std::string* ChatData::release_content() {
  // @@protoc_insertion_point(field_release:ChatData.content)
  return content_.Release();
}
inline void ChatData::set_allocated_content(std::string* content) {
  if (content != nullptr) {
    
  } else {
    
  }
  content_.SetAllocated(content, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (content_.IsDefault()) {
    content_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ChatData.content)
}

// uint32 sendTime = 3;
inline void ChatData::clear_sendtime() {
  sendtime_ = 0u;
}
inline uint32_t ChatData::_internal_sendtime() const {
  return sendtime_;
}
inline uint32_t ChatData::sendtime() const {
  // @@protoc_insertion_point(field_get:ChatData.sendTime)
  return _internal_sendtime();
}
inline void ChatData::_internal_set_sendtime(uint32_t value) {
  
  sendtime_ = value;
}
inline void ChatData::set_sendtime(uint32_t value) {
  _internal_set_sendtime(value);
  // @@protoc_insertion_point(field_set:ChatData.sendTime)
}

// -------------------------------------------------------------------

// AllChatData

// string pid = 1;
inline void AllChatData::clear_pid() {
  pid_.ClearToEmpty();
}
inline const std::string& AllChatData::pid() const {
  // @@protoc_insertion_point(field_get:AllChatData.pid)
  return _internal_pid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AllChatData::set_pid(ArgT0&& arg0, ArgT... args) {
 
 pid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:AllChatData.pid)
}
inline std::string* AllChatData::mutable_pid() {
  std::string* _s = _internal_mutable_pid();
  // @@protoc_insertion_point(field_mutable:AllChatData.pid)
  return _s;
}
inline const std::string& AllChatData::_internal_pid() const {
  return pid_.Get();
}
inline void AllChatData::_internal_set_pid(const std::string& value) {
  
  pid_.Set(value, GetArenaForAllocation());
}
inline std::string* AllChatData::_internal_mutable_pid() {
  
  return pid_.Mutable(GetArenaForAllocation());
}
inline std::string* AllChatData::release_pid() {
  // @@protoc_insertion_point(field_release:AllChatData.pid)
  return pid_.Release();
}
inline void AllChatData::set_allocated_pid(std::string* pid) {
  if (pid != nullptr) {
    
  } else {
    
  }
  pid_.SetAllocated(pid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (pid_.IsDefault()) {
    pid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:AllChatData.pid)
}

// repeated .ChatData data = 2;
inline int AllChatData::_internal_data_size() const {
  return data_.size();
}
inline int AllChatData::data_size() const {
  return _internal_data_size();
}
inline void AllChatData::clear_data() {
  data_.Clear();
}
inline ::ChatData* AllChatData::mutable_data(int index) {
  // @@protoc_insertion_point(field_mutable:AllChatData.data)
  return data_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ChatData >*
AllChatData::mutable_data() {
  // @@protoc_insertion_point(field_mutable_list:AllChatData.data)
  return &data_;
}
inline const ::ChatData& AllChatData::_internal_data(int index) const {
  return data_.Get(index);
}
inline const ::ChatData& AllChatData::data(int index) const {
  // @@protoc_insertion_point(field_get:AllChatData.data)
  return _internal_data(index);
}
inline ::ChatData* AllChatData::_internal_add_data() {
  return data_.Add();
}
inline ::ChatData* AllChatData::add_data() {
  ::ChatData* _add = _internal_add_data();
  // @@protoc_insertion_point(field_add:AllChatData.data)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ChatData >&
AllChatData::data() const {
  // @@protoc_insertion_point(field_list:AllChatData.data)
  return data_;
}

// -------------------------------------------------------------------

// ReqChatInfo

// int32 channel = 1;
inline void ReqChatInfo::clear_channel() {
  channel_ = 0;
}
inline int32_t ReqChatInfo::_internal_channel() const {
  return channel_;
}
inline int32_t ReqChatInfo::channel() const {
  // @@protoc_insertion_point(field_get:ReqChatInfo.channel)
  return _internal_channel();
}
inline void ReqChatInfo::_internal_set_channel(int32_t value) {
  
  channel_ = value;
}
inline void ReqChatInfo::set_channel(int32_t value) {
  _internal_set_channel(value);
  // @@protoc_insertion_point(field_set:ReqChatInfo.channel)
}

// -------------------------------------------------------------------

// ResChatInfo

// int32 channel = 1;
inline void ResChatInfo::clear_channel() {
  channel_ = 0;
}
inline int32_t ResChatInfo::_internal_channel() const {
  return channel_;
}
inline int32_t ResChatInfo::channel() const {
  // @@protoc_insertion_point(field_get:ResChatInfo.channel)
  return _internal_channel();
}
inline void ResChatInfo::_internal_set_channel(int32_t value) {
  
  channel_ = value;
}
inline void ResChatInfo::set_channel(int32_t value) {
  _internal_set_channel(value);
  // @@protoc_insertion_point(field_set:ResChatInfo.channel)
}

// repeated .PayerBaseInfo baseInfo = 2;
inline int ResChatInfo::_internal_baseinfo_size() const {
  return baseinfo_.size();
}
inline int ResChatInfo::baseinfo_size() const {
  return _internal_baseinfo_size();
}
inline ::PayerBaseInfo* ResChatInfo::mutable_baseinfo(int index) {
  // @@protoc_insertion_point(field_mutable:ResChatInfo.baseInfo)
  return baseinfo_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PayerBaseInfo >*
ResChatInfo::mutable_baseinfo() {
  // @@protoc_insertion_point(field_mutable_list:ResChatInfo.baseInfo)
  return &baseinfo_;
}
inline const ::PayerBaseInfo& ResChatInfo::_internal_baseinfo(int index) const {
  return baseinfo_.Get(index);
}
inline const ::PayerBaseInfo& ResChatInfo::baseinfo(int index) const {
  // @@protoc_insertion_point(field_get:ResChatInfo.baseInfo)
  return _internal_baseinfo(index);
}
inline ::PayerBaseInfo* ResChatInfo::_internal_add_baseinfo() {
  return baseinfo_.Add();
}
inline ::PayerBaseInfo* ResChatInfo::add_baseinfo() {
  ::PayerBaseInfo* _add = _internal_add_baseinfo();
  // @@protoc_insertion_point(field_add:ResChatInfo.baseInfo)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PayerBaseInfo >&
ResChatInfo::baseinfo() const {
  // @@protoc_insertion_point(field_list:ResChatInfo.baseInfo)
  return baseinfo_;
}

// repeated .AllChatData data = 3;
inline int ResChatInfo::_internal_data_size() const {
  return data_.size();
}
inline int ResChatInfo::data_size() const {
  return _internal_data_size();
}
inline void ResChatInfo::clear_data() {
  data_.Clear();
}
inline ::AllChatData* ResChatInfo::mutable_data(int index) {
  // @@protoc_insertion_point(field_mutable:ResChatInfo.data)
  return data_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::AllChatData >*
ResChatInfo::mutable_data() {
  // @@protoc_insertion_point(field_mutable_list:ResChatInfo.data)
  return &data_;
}
inline const ::AllChatData& ResChatInfo::_internal_data(int index) const {
  return data_.Get(index);
}
inline const ::AllChatData& ResChatInfo::data(int index) const {
  // @@protoc_insertion_point(field_get:ResChatInfo.data)
  return _internal_data(index);
}
inline ::AllChatData* ResChatInfo::_internal_add_data() {
  return data_.Add();
}
inline ::AllChatData* ResChatInfo::add_data() {
  ::AllChatData* _add = _internal_add_data();
  // @@protoc_insertion_point(field_add:ResChatInfo.data)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::AllChatData >&
ResChatInfo::data() const {
  // @@protoc_insertion_point(field_list:ResChatInfo.data)
  return data_;
}

// -------------------------------------------------------------------

// ReqSendChat

// int32 channel = 1;
inline void ReqSendChat::clear_channel() {
  channel_ = 0;
}
inline int32_t ReqSendChat::_internal_channel() const {
  return channel_;
}
inline int32_t ReqSendChat::channel() const {
  // @@protoc_insertion_point(field_get:ReqSendChat.channel)
  return _internal_channel();
}
inline void ReqSendChat::_internal_set_channel(int32_t value) {
  
  channel_ = value;
}
inline void ReqSendChat::set_channel(int32_t value) {
  _internal_set_channel(value);
  // @@protoc_insertion_point(field_set:ReqSendChat.channel)
}

// string content = 2;
inline void ReqSendChat::clear_content() {
  content_.ClearToEmpty();
}
inline const std::string& ReqSendChat::content() const {
  // @@protoc_insertion_point(field_get:ReqSendChat.content)
  return _internal_content();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ReqSendChat::set_content(ArgT0&& arg0, ArgT... args) {
 
 content_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ReqSendChat.content)
}
inline std::string* ReqSendChat::mutable_content() {
  std::string* _s = _internal_mutable_content();
  // @@protoc_insertion_point(field_mutable:ReqSendChat.content)
  return _s;
}
inline const std::string& ReqSendChat::_internal_content() const {
  return content_.Get();
}
inline void ReqSendChat::_internal_set_content(const std::string& value) {
  
  content_.Set(value, GetArenaForAllocation());
}
inline std::string* ReqSendChat::_internal_mutable_content() {
  
  return content_.Mutable(GetArenaForAllocation());
}
inline std::string* ReqSendChat::release_content() {
  // @@protoc_insertion_point(field_release:ReqSendChat.content)
  return content_.Release();
}
inline void ReqSendChat::set_allocated_content(std::string* content) {
  if (content != nullptr) {
    
  } else {
    
  }
  content_.SetAllocated(content, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (content_.IsDefault()) {
    content_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ReqSendChat.content)
}

// string otherPid = 3;
inline void ReqSendChat::clear_otherpid() {
  otherpid_.ClearToEmpty();
}
inline const std::string& ReqSendChat::otherpid() const {
  // @@protoc_insertion_point(field_get:ReqSendChat.otherPid)
  return _internal_otherpid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ReqSendChat::set_otherpid(ArgT0&& arg0, ArgT... args) {
 
 otherpid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ReqSendChat.otherPid)
}
inline std::string* ReqSendChat::mutable_otherpid() {
  std::string* _s = _internal_mutable_otherpid();
  // @@protoc_insertion_point(field_mutable:ReqSendChat.otherPid)
  return _s;
}
inline const std::string& ReqSendChat::_internal_otherpid() const {
  return otherpid_.Get();
}
inline void ReqSendChat::_internal_set_otherpid(const std::string& value) {
  
  otherpid_.Set(value, GetArenaForAllocation());
}
inline std::string* ReqSendChat::_internal_mutable_otherpid() {
  
  return otherpid_.Mutable(GetArenaForAllocation());
}
inline std::string* ReqSendChat::release_otherpid() {
  // @@protoc_insertion_point(field_release:ReqSendChat.otherPid)
  return otherpid_.Release();
}
inline void ReqSendChat::set_allocated_otherpid(std::string* otherpid) {
  if (otherpid != nullptr) {
    
  } else {
    
  }
  otherpid_.SetAllocated(otherpid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (otherpid_.IsDefault()) {
    otherpid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ReqSendChat.otherPid)
}

// -------------------------------------------------------------------

// NotifyAddNewChat

// int32 channel = 1;
inline void NotifyAddNewChat::clear_channel() {
  channel_ = 0;
}
inline int32_t NotifyAddNewChat::_internal_channel() const {
  return channel_;
}
inline int32_t NotifyAddNewChat::channel() const {
  // @@protoc_insertion_point(field_get:NotifyAddNewChat.channel)
  return _internal_channel();
}
inline void NotifyAddNewChat::_internal_set_channel(int32_t value) {
  
  channel_ = value;
}
inline void NotifyAddNewChat::set_channel(int32_t value) {
  _internal_set_channel(value);
  // @@protoc_insertion_point(field_set:NotifyAddNewChat.channel)
}

// .ChatData data = 2;
inline bool NotifyAddNewChat::_internal_has_data() const {
  return this != internal_default_instance() && data_ != nullptr;
}
inline bool NotifyAddNewChat::has_data() const {
  return _internal_has_data();
}
inline void NotifyAddNewChat::clear_data() {
  if (GetArenaForAllocation() == nullptr && data_ != nullptr) {
    delete data_;
  }
  data_ = nullptr;
}
inline const ::ChatData& NotifyAddNewChat::_internal_data() const {
  const ::ChatData* p = data_;
  return p != nullptr ? *p : reinterpret_cast<const ::ChatData&>(
      ::_ChatData_default_instance_);
}
inline const ::ChatData& NotifyAddNewChat::data() const {
  // @@protoc_insertion_point(field_get:NotifyAddNewChat.data)
  return _internal_data();
}
inline void NotifyAddNewChat::unsafe_arena_set_allocated_data(
    ::ChatData* data) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(data_);
  }
  data_ = data;
  if (data) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:NotifyAddNewChat.data)
}
inline ::ChatData* NotifyAddNewChat::release_data() {
  
  ::ChatData* temp = data_;
  data_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ChatData* NotifyAddNewChat::unsafe_arena_release_data() {
  // @@protoc_insertion_point(field_release:NotifyAddNewChat.data)
  
  ::ChatData* temp = data_;
  data_ = nullptr;
  return temp;
}
inline ::ChatData* NotifyAddNewChat::_internal_mutable_data() {
  
  if (data_ == nullptr) {
    auto* p = CreateMaybeMessage<::ChatData>(GetArenaForAllocation());
    data_ = p;
  }
  return data_;
}
inline ::ChatData* NotifyAddNewChat::mutable_data() {
  ::ChatData* _msg = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:NotifyAddNewChat.data)
  return _msg;
}
inline void NotifyAddNewChat::set_allocated_data(::ChatData* data) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete data_;
  }
  if (data) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(data);
    if (message_arena != submessage_arena) {
      data = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, data, submessage_arena);
    }
    
  } else {
    
  }
  data_ = data;
  // @@protoc_insertion_point(field_set_allocated:NotifyAddNewChat.data)
}

// .PayerBaseInfo baseInfo = 3;
inline bool NotifyAddNewChat::_internal_has_baseinfo() const {
  return this != internal_default_instance() && baseinfo_ != nullptr;
}
inline bool NotifyAddNewChat::has_baseinfo() const {
  return _internal_has_baseinfo();
}
inline const ::PayerBaseInfo& NotifyAddNewChat::_internal_baseinfo() const {
  const ::PayerBaseInfo* p = baseinfo_;
  return p != nullptr ? *p : reinterpret_cast<const ::PayerBaseInfo&>(
      ::_PayerBaseInfo_default_instance_);
}
inline const ::PayerBaseInfo& NotifyAddNewChat::baseinfo() const {
  // @@protoc_insertion_point(field_get:NotifyAddNewChat.baseInfo)
  return _internal_baseinfo();
}
inline void NotifyAddNewChat::unsafe_arena_set_allocated_baseinfo(
    ::PayerBaseInfo* baseinfo) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(baseinfo_);
  }
  baseinfo_ = baseinfo;
  if (baseinfo) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:NotifyAddNewChat.baseInfo)
}
inline ::PayerBaseInfo* NotifyAddNewChat::release_baseinfo() {
  
  ::PayerBaseInfo* temp = baseinfo_;
  baseinfo_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PayerBaseInfo* NotifyAddNewChat::unsafe_arena_release_baseinfo() {
  // @@protoc_insertion_point(field_release:NotifyAddNewChat.baseInfo)
  
  ::PayerBaseInfo* temp = baseinfo_;
  baseinfo_ = nullptr;
  return temp;
}
inline ::PayerBaseInfo* NotifyAddNewChat::_internal_mutable_baseinfo() {
  
  if (baseinfo_ == nullptr) {
    auto* p = CreateMaybeMessage<::PayerBaseInfo>(GetArenaForAllocation());
    baseinfo_ = p;
  }
  return baseinfo_;
}
inline ::PayerBaseInfo* NotifyAddNewChat::mutable_baseinfo() {
  ::PayerBaseInfo* _msg = _internal_mutable_baseinfo();
  // @@protoc_insertion_point(field_mutable:NotifyAddNewChat.baseInfo)
  return _msg;
}
inline void NotifyAddNewChat::set_allocated_baseinfo(::PayerBaseInfo* baseinfo) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(baseinfo_);
  }
  if (baseinfo) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(baseinfo));
    if (message_arena != submessage_arena) {
      baseinfo = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, baseinfo, submessage_arena);
    }
    
  } else {
    
  }
  baseinfo_ = baseinfo;
  // @@protoc_insertion_point(field_set_allocated:NotifyAddNewChat.baseInfo)
}

// -------------------------------------------------------------------

// ReqGetCrossChatData

// int32 channel = 1;
inline void ReqGetCrossChatData::clear_channel() {
  channel_ = 0;
}
inline int32_t ReqGetCrossChatData::_internal_channel() const {
  return channel_;
}
inline int32_t ReqGetCrossChatData::channel() const {
  // @@protoc_insertion_point(field_get:ReqGetCrossChatData.channel)
  return _internal_channel();
}
inline void ReqGetCrossChatData::_internal_set_channel(int32_t value) {
  
  channel_ = value;
}
inline void ReqGetCrossChatData::set_channel(int32_t value) {
  _internal_set_channel(value);
  // @@protoc_insertion_point(field_set:ReqGetCrossChatData.channel)
}

// string pid = 2;
inline void ReqGetCrossChatData::clear_pid() {
  pid_.ClearToEmpty();
}
inline const std::string& ReqGetCrossChatData::pid() const {
  // @@protoc_insertion_point(field_get:ReqGetCrossChatData.pid)
  return _internal_pid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ReqGetCrossChatData::set_pid(ArgT0&& arg0, ArgT... args) {
 
 pid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ReqGetCrossChatData.pid)
}
inline std::string* ReqGetCrossChatData::mutable_pid() {
  std::string* _s = _internal_mutable_pid();
  // @@protoc_insertion_point(field_mutable:ReqGetCrossChatData.pid)
  return _s;
}
inline const std::string& ReqGetCrossChatData::_internal_pid() const {
  return pid_.Get();
}
inline void ReqGetCrossChatData::_internal_set_pid(const std::string& value) {
  
  pid_.Set(value, GetArenaForAllocation());
}
inline std::string* ReqGetCrossChatData::_internal_mutable_pid() {
  
  return pid_.Mutable(GetArenaForAllocation());
}
inline std::string* ReqGetCrossChatData::release_pid() {
  // @@protoc_insertion_point(field_release:ReqGetCrossChatData.pid)
  return pid_.Release();
}
inline void ReqGetCrossChatData::set_allocated_pid(std::string* pid) {
  if (pid != nullptr) {
    
  } else {
    
  }
  pid_.SetAllocated(pid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (pid_.IsDefault()) {
    pid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ReqGetCrossChatData.pid)
}

// repeated string pids = 3;
inline int ReqGetCrossChatData::_internal_pids_size() const {
  return pids_.size();
}
inline int ReqGetCrossChatData::pids_size() const {
  return _internal_pids_size();
}
inline void ReqGetCrossChatData::clear_pids() {
  pids_.Clear();
}
inline std::string* ReqGetCrossChatData::add_pids() {
  std::string* _s = _internal_add_pids();
  // @@protoc_insertion_point(field_add_mutable:ReqGetCrossChatData.pids)
  return _s;
}
inline const std::string& ReqGetCrossChatData::_internal_pids(int index) const {
  return pids_.Get(index);
}
inline const std::string& ReqGetCrossChatData::pids(int index) const {
  // @@protoc_insertion_point(field_get:ReqGetCrossChatData.pids)
  return _internal_pids(index);
}
inline std::string* ReqGetCrossChatData::mutable_pids(int index) {
  // @@protoc_insertion_point(field_mutable:ReqGetCrossChatData.pids)
  return pids_.Mutable(index);
}
inline void ReqGetCrossChatData::set_pids(int index, const std::string& value) {
  pids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:ReqGetCrossChatData.pids)
}
inline void ReqGetCrossChatData::set_pids(int index, std::string&& value) {
  pids_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:ReqGetCrossChatData.pids)
}
inline void ReqGetCrossChatData::set_pids(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  pids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:ReqGetCrossChatData.pids)
}
inline void ReqGetCrossChatData::set_pids(int index, const char* value, size_t size) {
  pids_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ReqGetCrossChatData.pids)
}
inline std::string* ReqGetCrossChatData::_internal_add_pids() {
  return pids_.Add();
}
inline void ReqGetCrossChatData::add_pids(const std::string& value) {
  pids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:ReqGetCrossChatData.pids)
}
inline void ReqGetCrossChatData::add_pids(std::string&& value) {
  pids_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:ReqGetCrossChatData.pids)
}
inline void ReqGetCrossChatData::add_pids(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  pids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:ReqGetCrossChatData.pids)
}
inline void ReqGetCrossChatData::add_pids(const char* value, size_t size) {
  pids_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:ReqGetCrossChatData.pids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
ReqGetCrossChatData::pids() const {
  // @@protoc_insertion_point(field_list:ReqGetCrossChatData.pids)
  return pids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
ReqGetCrossChatData::mutable_pids() {
  // @@protoc_insertion_point(field_mutable_list:ReqGetCrossChatData.pids)
  return &pids_;
}

// -------------------------------------------------------------------

// ResCrossPlayerBaseInfo

// repeated .PayerBaseInfo baseInfo = 1;
inline int ResCrossPlayerBaseInfo::_internal_baseinfo_size() const {
  return baseinfo_.size();
}
inline int ResCrossPlayerBaseInfo::baseinfo_size() const {
  return _internal_baseinfo_size();
}
inline ::PayerBaseInfo* ResCrossPlayerBaseInfo::mutable_baseinfo(int index) {
  // @@protoc_insertion_point(field_mutable:ResCrossPlayerBaseInfo.baseInfo)
  return baseinfo_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PayerBaseInfo >*
ResCrossPlayerBaseInfo::mutable_baseinfo() {
  // @@protoc_insertion_point(field_mutable_list:ResCrossPlayerBaseInfo.baseInfo)
  return &baseinfo_;
}
inline const ::PayerBaseInfo& ResCrossPlayerBaseInfo::_internal_baseinfo(int index) const {
  return baseinfo_.Get(index);
}
inline const ::PayerBaseInfo& ResCrossPlayerBaseInfo::baseinfo(int index) const {
  // @@protoc_insertion_point(field_get:ResCrossPlayerBaseInfo.baseInfo)
  return _internal_baseinfo(index);
}
inline ::PayerBaseInfo* ResCrossPlayerBaseInfo::_internal_add_baseinfo() {
  return baseinfo_.Add();
}
inline ::PayerBaseInfo* ResCrossPlayerBaseInfo::add_baseinfo() {
  ::PayerBaseInfo* _add = _internal_add_baseinfo();
  // @@protoc_insertion_point(field_add:ResCrossPlayerBaseInfo.baseInfo)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PayerBaseInfo >&
ResCrossPlayerBaseInfo::baseinfo() const {
  // @@protoc_insertion_point(field_list:ResCrossPlayerBaseInfo.baseInfo)
  return baseinfo_;
}

// string pid = 2;
inline void ResCrossPlayerBaseInfo::clear_pid() {
  pid_.ClearToEmpty();
}
inline const std::string& ResCrossPlayerBaseInfo::pid() const {
  // @@protoc_insertion_point(field_get:ResCrossPlayerBaseInfo.pid)
  return _internal_pid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ResCrossPlayerBaseInfo::set_pid(ArgT0&& arg0, ArgT... args) {
 
 pid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ResCrossPlayerBaseInfo.pid)
}
inline std::string* ResCrossPlayerBaseInfo::mutable_pid() {
  std::string* _s = _internal_mutable_pid();
  // @@protoc_insertion_point(field_mutable:ResCrossPlayerBaseInfo.pid)
  return _s;
}
inline const std::string& ResCrossPlayerBaseInfo::_internal_pid() const {
  return pid_.Get();
}
inline void ResCrossPlayerBaseInfo::_internal_set_pid(const std::string& value) {
  
  pid_.Set(value, GetArenaForAllocation());
}
inline std::string* ResCrossPlayerBaseInfo::_internal_mutable_pid() {
  
  return pid_.Mutable(GetArenaForAllocation());
}
inline std::string* ResCrossPlayerBaseInfo::release_pid() {
  // @@protoc_insertion_point(field_release:ResCrossPlayerBaseInfo.pid)
  return pid_.Release();
}
inline void ResCrossPlayerBaseInfo::set_allocated_pid(std::string* pid) {
  if (pid != nullptr) {
    
  } else {
    
  }
  pid_.SetAllocated(pid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (pid_.IsDefault()) {
    pid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ResCrossPlayerBaseInfo.pid)
}

// int32 channel = 3;
inline void ResCrossPlayerBaseInfo::clear_channel() {
  channel_ = 0;
}
inline int32_t ResCrossPlayerBaseInfo::_internal_channel() const {
  return channel_;
}
inline int32_t ResCrossPlayerBaseInfo::channel() const {
  // @@protoc_insertion_point(field_get:ResCrossPlayerBaseInfo.channel)
  return _internal_channel();
}
inline void ResCrossPlayerBaseInfo::_internal_set_channel(int32_t value) {
  
  channel_ = value;
}
inline void ResCrossPlayerBaseInfo::set_channel(int32_t value) {
  _internal_set_channel(value);
  // @@protoc_insertion_point(field_set:ResCrossPlayerBaseInfo.channel)
}

// -------------------------------------------------------------------

// ReqCrossSendChat

// int32 channel = 1;
inline void ReqCrossSendChat::clear_channel() {
  channel_ = 0;
}
inline int32_t ReqCrossSendChat::_internal_channel() const {
  return channel_;
}
inline int32_t ReqCrossSendChat::channel() const {
  // @@protoc_insertion_point(field_get:ReqCrossSendChat.channel)
  return _internal_channel();
}
inline void ReqCrossSendChat::_internal_set_channel(int32_t value) {
  
  channel_ = value;
}
inline void ReqCrossSendChat::set_channel(int32_t value) {
  _internal_set_channel(value);
  // @@protoc_insertion_point(field_set:ReqCrossSendChat.channel)
}

// string content = 2;
inline void ReqCrossSendChat::clear_content() {
  content_.ClearToEmpty();
}
inline const std::string& ReqCrossSendChat::content() const {
  // @@protoc_insertion_point(field_get:ReqCrossSendChat.content)
  return _internal_content();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ReqCrossSendChat::set_content(ArgT0&& arg0, ArgT... args) {
 
 content_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ReqCrossSendChat.content)
}
inline std::string* ReqCrossSendChat::mutable_content() {
  std::string* _s = _internal_mutable_content();
  // @@protoc_insertion_point(field_mutable:ReqCrossSendChat.content)
  return _s;
}
inline const std::string& ReqCrossSendChat::_internal_content() const {
  return content_.Get();
}
inline void ReqCrossSendChat::_internal_set_content(const std::string& value) {
  
  content_.Set(value, GetArenaForAllocation());
}
inline std::string* ReqCrossSendChat::_internal_mutable_content() {
  
  return content_.Mutable(GetArenaForAllocation());
}
inline std::string* ReqCrossSendChat::release_content() {
  // @@protoc_insertion_point(field_release:ReqCrossSendChat.content)
  return content_.Release();
}
inline void ReqCrossSendChat::set_allocated_content(std::string* content) {
  if (content != nullptr) {
    
  } else {
    
  }
  content_.SetAllocated(content, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (content_.IsDefault()) {
    content_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ReqCrossSendChat.content)
}

// string otherPid = 3;
inline void ReqCrossSendChat::clear_otherpid() {
  otherpid_.ClearToEmpty();
}
inline const std::string& ReqCrossSendChat::otherpid() const {
  // @@protoc_insertion_point(field_get:ReqCrossSendChat.otherPid)
  return _internal_otherpid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ReqCrossSendChat::set_otherpid(ArgT0&& arg0, ArgT... args) {
 
 otherpid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ReqCrossSendChat.otherPid)
}
inline std::string* ReqCrossSendChat::mutable_otherpid() {
  std::string* _s = _internal_mutable_otherpid();
  // @@protoc_insertion_point(field_mutable:ReqCrossSendChat.otherPid)
  return _s;
}
inline const std::string& ReqCrossSendChat::_internal_otherpid() const {
  return otherpid_.Get();
}
inline void ReqCrossSendChat::_internal_set_otherpid(const std::string& value) {
  
  otherpid_.Set(value, GetArenaForAllocation());
}
inline std::string* ReqCrossSendChat::_internal_mutable_otherpid() {
  
  return otherpid_.Mutable(GetArenaForAllocation());
}
inline std::string* ReqCrossSendChat::release_otherpid() {
  // @@protoc_insertion_point(field_release:ReqCrossSendChat.otherPid)
  return otherpid_.Release();
}
inline void ReqCrossSendChat::set_allocated_otherpid(std::string* otherpid) {
  if (otherpid != nullptr) {
    
  } else {
    
  }
  otherpid_.SetAllocated(otherpid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (otherpid_.IsDefault()) {
    otherpid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ReqCrossSendChat.otherPid)
}

// string pid = 4;
inline void ReqCrossSendChat::clear_pid() {
  pid_.ClearToEmpty();
}
inline const std::string& ReqCrossSendChat::pid() const {
  // @@protoc_insertion_point(field_get:ReqCrossSendChat.pid)
  return _internal_pid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ReqCrossSendChat::set_pid(ArgT0&& arg0, ArgT... args) {
 
 pid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ReqCrossSendChat.pid)
}
inline std::string* ReqCrossSendChat::mutable_pid() {
  std::string* _s = _internal_mutable_pid();
  // @@protoc_insertion_point(field_mutable:ReqCrossSendChat.pid)
  return _s;
}
inline const std::string& ReqCrossSendChat::_internal_pid() const {
  return pid_.Get();
}
inline void ReqCrossSendChat::_internal_set_pid(const std::string& value) {
  
  pid_.Set(value, GetArenaForAllocation());
}
inline std::string* ReqCrossSendChat::_internal_mutable_pid() {
  
  return pid_.Mutable(GetArenaForAllocation());
}
inline std::string* ReqCrossSendChat::release_pid() {
  // @@protoc_insertion_point(field_release:ReqCrossSendChat.pid)
  return pid_.Release();
}
inline void ReqCrossSendChat::set_allocated_pid(std::string* pid) {
  if (pid != nullptr) {
    
  } else {
    
  }
  pid_.SetAllocated(pid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (pid_.IsDefault()) {
    pid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ReqCrossSendChat.pid)
}

// -------------------------------------------------------------------

// ResCrossSendChat

// int32 channel = 1;
inline void ResCrossSendChat::clear_channel() {
  channel_ = 0;
}
inline int32_t ResCrossSendChat::_internal_channel() const {
  return channel_;
}
inline int32_t ResCrossSendChat::channel() const {
  // @@protoc_insertion_point(field_get:ResCrossSendChat.channel)
  return _internal_channel();
}
inline void ResCrossSendChat::_internal_set_channel(int32_t value) {
  
  channel_ = value;
}
inline void ResCrossSendChat::set_channel(int32_t value) {
  _internal_set_channel(value);
  // @@protoc_insertion_point(field_set:ResCrossSendChat.channel)
}

// .ChatData data = 2;
inline bool ResCrossSendChat::_internal_has_data() const {
  return this != internal_default_instance() && data_ != nullptr;
}
inline bool ResCrossSendChat::has_data() const {
  return _internal_has_data();
}
inline void ResCrossSendChat::clear_data() {
  if (GetArenaForAllocation() == nullptr && data_ != nullptr) {
    delete data_;
  }
  data_ = nullptr;
}
inline const ::ChatData& ResCrossSendChat::_internal_data() const {
  const ::ChatData* p = data_;
  return p != nullptr ? *p : reinterpret_cast<const ::ChatData&>(
      ::_ChatData_default_instance_);
}
inline const ::ChatData& ResCrossSendChat::data() const {
  // @@protoc_insertion_point(field_get:ResCrossSendChat.data)
  return _internal_data();
}
inline void ResCrossSendChat::unsafe_arena_set_allocated_data(
    ::ChatData* data) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(data_);
  }
  data_ = data;
  if (data) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ResCrossSendChat.data)
}
inline ::ChatData* ResCrossSendChat::release_data() {
  
  ::ChatData* temp = data_;
  data_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ChatData* ResCrossSendChat::unsafe_arena_release_data() {
  // @@protoc_insertion_point(field_release:ResCrossSendChat.data)
  
  ::ChatData* temp = data_;
  data_ = nullptr;
  return temp;
}
inline ::ChatData* ResCrossSendChat::_internal_mutable_data() {
  
  if (data_ == nullptr) {
    auto* p = CreateMaybeMessage<::ChatData>(GetArenaForAllocation());
    data_ = p;
  }
  return data_;
}
inline ::ChatData* ResCrossSendChat::mutable_data() {
  ::ChatData* _msg = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:ResCrossSendChat.data)
  return _msg;
}
inline void ResCrossSendChat::set_allocated_data(::ChatData* data) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete data_;
  }
  if (data) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(data);
    if (message_arena != submessage_arena) {
      data = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, data, submessage_arena);
    }
    
  } else {
    
  }
  data_ = data;
  // @@protoc_insertion_point(field_set_allocated:ResCrossSendChat.data)
}

// repeated .PayerBaseInfo baseInfo = 3;
inline int ResCrossSendChat::_internal_baseinfo_size() const {
  return baseinfo_.size();
}
inline int ResCrossSendChat::baseinfo_size() const {
  return _internal_baseinfo_size();
}
inline ::PayerBaseInfo* ResCrossSendChat::mutable_baseinfo(int index) {
  // @@protoc_insertion_point(field_mutable:ResCrossSendChat.baseInfo)
  return baseinfo_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PayerBaseInfo >*
ResCrossSendChat::mutable_baseinfo() {
  // @@protoc_insertion_point(field_mutable_list:ResCrossSendChat.baseInfo)
  return &baseinfo_;
}
inline const ::PayerBaseInfo& ResCrossSendChat::_internal_baseinfo(int index) const {
  return baseinfo_.Get(index);
}
inline const ::PayerBaseInfo& ResCrossSendChat::baseinfo(int index) const {
  // @@protoc_insertion_point(field_get:ResCrossSendChat.baseInfo)
  return _internal_baseinfo(index);
}
inline ::PayerBaseInfo* ResCrossSendChat::_internal_add_baseinfo() {
  return baseinfo_.Add();
}
inline ::PayerBaseInfo* ResCrossSendChat::add_baseinfo() {
  ::PayerBaseInfo* _add = _internal_add_baseinfo();
  // @@protoc_insertion_point(field_add:ResCrossSendChat.baseInfo)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PayerBaseInfo >&
ResCrossSendChat::baseinfo() const {
  // @@protoc_insertion_point(field_list:ResCrossSendChat.baseInfo)
  return baseinfo_;
}

// -------------------------------------------------------------------

// ReqAddNewChatData

// int32 channel = 1;
inline void ReqAddNewChatData::clear_channel() {
  channel_ = 0;
}
inline int32_t ReqAddNewChatData::_internal_channel() const {
  return channel_;
}
inline int32_t ReqAddNewChatData::channel() const {
  // @@protoc_insertion_point(field_get:ReqAddNewChatData.channel)
  return _internal_channel();
}
inline void ReqAddNewChatData::_internal_set_channel(int32_t value) {
  
  channel_ = value;
}
inline void ReqAddNewChatData::set_channel(int32_t value) {
  _internal_set_channel(value);
  // @@protoc_insertion_point(field_set:ReqAddNewChatData.channel)
}

// string content = 2;
inline void ReqAddNewChatData::clear_content() {
  content_.ClearToEmpty();
}
inline const std::string& ReqAddNewChatData::content() const {
  // @@protoc_insertion_point(field_get:ReqAddNewChatData.content)
  return _internal_content();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ReqAddNewChatData::set_content(ArgT0&& arg0, ArgT... args) {
 
 content_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ReqAddNewChatData.content)
}
inline std::string* ReqAddNewChatData::mutable_content() {
  std::string* _s = _internal_mutable_content();
  // @@protoc_insertion_point(field_mutable:ReqAddNewChatData.content)
  return _s;
}
inline const std::string& ReqAddNewChatData::_internal_content() const {
  return content_.Get();
}
inline void ReqAddNewChatData::_internal_set_content(const std::string& value) {
  
  content_.Set(value, GetArenaForAllocation());
}
inline std::string* ReqAddNewChatData::_internal_mutable_content() {
  
  return content_.Mutable(GetArenaForAllocation());
}
inline std::string* ReqAddNewChatData::release_content() {
  // @@protoc_insertion_point(field_release:ReqAddNewChatData.content)
  return content_.Release();
}
inline void ReqAddNewChatData::set_allocated_content(std::string* content) {
  if (content != nullptr) {
    
  } else {
    
  }
  content_.SetAllocated(content, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (content_.IsDefault()) {
    content_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ReqAddNewChatData.content)
}

// string otherPid = 3;
inline void ReqAddNewChatData::clear_otherpid() {
  otherpid_.ClearToEmpty();
}
inline const std::string& ReqAddNewChatData::otherpid() const {
  // @@protoc_insertion_point(field_get:ReqAddNewChatData.otherPid)
  return _internal_otherpid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ReqAddNewChatData::set_otherpid(ArgT0&& arg0, ArgT... args) {
 
 otherpid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ReqAddNewChatData.otherPid)
}
inline std::string* ReqAddNewChatData::mutable_otherpid() {
  std::string* _s = _internal_mutable_otherpid();
  // @@protoc_insertion_point(field_mutable:ReqAddNewChatData.otherPid)
  return _s;
}
inline const std::string& ReqAddNewChatData::_internal_otherpid() const {
  return otherpid_.Get();
}
inline void ReqAddNewChatData::_internal_set_otherpid(const std::string& value) {
  
  otherpid_.Set(value, GetArenaForAllocation());
}
inline std::string* ReqAddNewChatData::_internal_mutable_otherpid() {
  
  return otherpid_.Mutable(GetArenaForAllocation());
}
inline std::string* ReqAddNewChatData::release_otherpid() {
  // @@protoc_insertion_point(field_release:ReqAddNewChatData.otherPid)
  return otherpid_.Release();
}
inline void ReqAddNewChatData::set_allocated_otherpid(std::string* otherpid) {
  if (otherpid != nullptr) {
    
  } else {
    
  }
  otherpid_.SetAllocated(otherpid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (otherpid_.IsDefault()) {
    otherpid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ReqAddNewChatData.otherPid)
}

// string pid = 4;
inline void ReqAddNewChatData::clear_pid() {
  pid_.ClearToEmpty();
}
inline const std::string& ReqAddNewChatData::pid() const {
  // @@protoc_insertion_point(field_get:ReqAddNewChatData.pid)
  return _internal_pid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ReqAddNewChatData::set_pid(ArgT0&& arg0, ArgT... args) {
 
 pid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ReqAddNewChatData.pid)
}
inline std::string* ReqAddNewChatData::mutable_pid() {
  std::string* _s = _internal_mutable_pid();
  // @@protoc_insertion_point(field_mutable:ReqAddNewChatData.pid)
  return _s;
}
inline const std::string& ReqAddNewChatData::_internal_pid() const {
  return pid_.Get();
}
inline void ReqAddNewChatData::_internal_set_pid(const std::string& value) {
  
  pid_.Set(value, GetArenaForAllocation());
}
inline std::string* ReqAddNewChatData::_internal_mutable_pid() {
  
  return pid_.Mutable(GetArenaForAllocation());
}
inline std::string* ReqAddNewChatData::release_pid() {
  // @@protoc_insertion_point(field_release:ReqAddNewChatData.pid)
  return pid_.Release();
}
inline void ReqAddNewChatData::set_allocated_pid(std::string* pid) {
  if (pid != nullptr) {
    
  } else {
    
  }
  pid_.SetAllocated(pid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (pid_.IsDefault()) {
    pid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ReqAddNewChatData.pid)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_Chat_2eproto
