// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: Bag.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_Bag_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_Bag_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3020000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3020003 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_bases.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_Bag_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_Bag_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_Bag_2eproto;
class BagInfo;
struct BagInfoDefaultTypeInternal;
extern BagInfoDefaultTypeInternal _BagInfo_default_instance_;
class CurrencyInfo;
struct CurrencyInfoDefaultTypeInternal;
extern CurrencyInfoDefaultTypeInternal _CurrencyInfo_default_instance_;
class EquipInfo;
struct EquipInfoDefaultTypeInternal;
extern EquipInfoDefaultTypeInternal _EquipInfo_default_instance_;
class ItemInfo;
struct ItemInfoDefaultTypeInternal;
extern ItemInfoDefaultTypeInternal _ItemInfo_default_instance_;
class NotifyBagInfoSignUp;
struct NotifyBagInfoSignUpDefaultTypeInternal;
extern NotifyBagInfoSignUpDefaultTypeInternal _NotifyBagInfoSignUp_default_instance_;
class NotifyClientRewardTips;
struct NotifyClientRewardTipsDefaultTypeInternal;
extern NotifyClientRewardTipsDefaultTypeInternal _NotifyClientRewardTips_default_instance_;
class NotifyCurrencyUpdate;
struct NotifyCurrencyUpdateDefaultTypeInternal;
extern NotifyCurrencyUpdateDefaultTypeInternal _NotifyCurrencyUpdate_default_instance_;
class NotifyDeleteCurrency;
struct NotifyDeleteCurrencyDefaultTypeInternal;
extern NotifyDeleteCurrencyDefaultTypeInternal _NotifyDeleteCurrency_default_instance_;
class NotifyDeleteItem;
struct NotifyDeleteItemDefaultTypeInternal;
extern NotifyDeleteItemDefaultTypeInternal _NotifyDeleteItem_default_instance_;
class ReqAllBagInfo;
struct ReqAllBagInfoDefaultTypeInternal;
extern ReqAllBagInfoDefaultTypeInternal _ReqAllBagInfo_default_instance_;
class ReqBagDelItem;
struct ReqBagDelItemDefaultTypeInternal;
extern ReqBagDelItemDefaultTypeInternal _ReqBagDelItem_default_instance_;
class ReqBagItemLock;
struct ReqBagItemLockDefaultTypeInternal;
extern ReqBagItemLockDefaultTypeInternal _ReqBagItemLock_default_instance_;
class ReqCurrencyInfo;
struct ReqCurrencyInfoDefaultTypeInternal;
extern ReqCurrencyInfoDefaultTypeInternal _ReqCurrencyInfo_default_instance_;
class ReqEquipLevelUp;
struct ReqEquipLevelUpDefaultTypeInternal;
extern ReqEquipLevelUpDefaultTypeInternal _ReqEquipLevelUp_default_instance_;
class ReqUseItem;
struct ReqUseItemDefaultTypeInternal;
extern ReqUseItemDefaultTypeInternal _ReqUseItem_default_instance_;
class ResAllBagInfo;
struct ResAllBagInfoDefaultTypeInternal;
extern ResAllBagInfoDefaultTypeInternal _ResAllBagInfo_default_instance_;
class ResBagItemLock;
struct ResBagItemLockDefaultTypeInternal;
extern ResBagItemLockDefaultTypeInternal _ResBagItemLock_default_instance_;
class ResCurrencyInfo;
struct ResCurrencyInfoDefaultTypeInternal;
extern ResCurrencyInfoDefaultTypeInternal _ResCurrencyInfo_default_instance_;
class ResEquipLevelUp;
struct ResEquipLevelUpDefaultTypeInternal;
extern ResEquipLevelUpDefaultTypeInternal _ResEquipLevelUp_default_instance_;
class itemAttrInfo;
struct itemAttrInfoDefaultTypeInternal;
extern itemAttrInfoDefaultTypeInternal _itemAttrInfo_default_instance_;
PROTOBUF_NAMESPACE_OPEN
template<> ::BagInfo* Arena::CreateMaybeMessage<::BagInfo>(Arena*);
template<> ::CurrencyInfo* Arena::CreateMaybeMessage<::CurrencyInfo>(Arena*);
template<> ::EquipInfo* Arena::CreateMaybeMessage<::EquipInfo>(Arena*);
template<> ::ItemInfo* Arena::CreateMaybeMessage<::ItemInfo>(Arena*);
template<> ::NotifyBagInfoSignUp* Arena::CreateMaybeMessage<::NotifyBagInfoSignUp>(Arena*);
template<> ::NotifyClientRewardTips* Arena::CreateMaybeMessage<::NotifyClientRewardTips>(Arena*);
template<> ::NotifyCurrencyUpdate* Arena::CreateMaybeMessage<::NotifyCurrencyUpdate>(Arena*);
template<> ::NotifyDeleteCurrency* Arena::CreateMaybeMessage<::NotifyDeleteCurrency>(Arena*);
template<> ::NotifyDeleteItem* Arena::CreateMaybeMessage<::NotifyDeleteItem>(Arena*);
template<> ::ReqAllBagInfo* Arena::CreateMaybeMessage<::ReqAllBagInfo>(Arena*);
template<> ::ReqBagDelItem* Arena::CreateMaybeMessage<::ReqBagDelItem>(Arena*);
template<> ::ReqBagItemLock* Arena::CreateMaybeMessage<::ReqBagItemLock>(Arena*);
template<> ::ReqCurrencyInfo* Arena::CreateMaybeMessage<::ReqCurrencyInfo>(Arena*);
template<> ::ReqEquipLevelUp* Arena::CreateMaybeMessage<::ReqEquipLevelUp>(Arena*);
template<> ::ReqUseItem* Arena::CreateMaybeMessage<::ReqUseItem>(Arena*);
template<> ::ResAllBagInfo* Arena::CreateMaybeMessage<::ResAllBagInfo>(Arena*);
template<> ::ResBagItemLock* Arena::CreateMaybeMessage<::ResBagItemLock>(Arena*);
template<> ::ResCurrencyInfo* Arena::CreateMaybeMessage<::ResCurrencyInfo>(Arena*);
template<> ::ResEquipLevelUp* Arena::CreateMaybeMessage<::ResEquipLevelUp>(Arena*);
template<> ::itemAttrInfo* Arena::CreateMaybeMessage<::itemAttrInfo>(Arena*);
PROTOBUF_NAMESPACE_CLOSE

// ===================================================================

class itemAttrInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:itemAttrInfo) */ {
 public:
  inline itemAttrInfo() : itemAttrInfo(nullptr) {}
  ~itemAttrInfo() override;
  explicit PROTOBUF_CONSTEXPR itemAttrInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  itemAttrInfo(const itemAttrInfo& from);
  itemAttrInfo(itemAttrInfo&& from) noexcept
    : itemAttrInfo() {
    *this = ::std::move(from);
  }

  inline itemAttrInfo& operator=(const itemAttrInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline itemAttrInfo& operator=(itemAttrInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const itemAttrInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const itemAttrInfo* internal_default_instance() {
    return reinterpret_cast<const itemAttrInfo*>(
               &_itemAttrInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(itemAttrInfo& a, itemAttrInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(itemAttrInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(itemAttrInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  itemAttrInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<itemAttrInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const itemAttrInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const itemAttrInfo& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(itemAttrInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "itemAttrInfo";
  }
  protected:
  explicit itemAttrInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTypeFieldNumber = 1,
    kValueFieldNumber = 2,
  };
  // int32 type = 1;
  void clear_type();
  int32_t type() const;
  void set_type(int32_t value);
  private:
  int32_t _internal_type() const;
  void _internal_set_type(int32_t value);
  public:

  // int32 value = 2;
  void clear_value();
  int32_t value() const;
  void set_value(int32_t value);
  private:
  int32_t _internal_value() const;
  void _internal_set_value(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:itemAttrInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int32_t type_;
  int32_t value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Bag_2eproto;
};
// -------------------------------------------------------------------

class EquipInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:EquipInfo) */ {
 public:
  inline EquipInfo() : EquipInfo(nullptr) {}
  ~EquipInfo() override;
  explicit PROTOBUF_CONSTEXPR EquipInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EquipInfo(const EquipInfo& from);
  EquipInfo(EquipInfo&& from) noexcept
    : EquipInfo() {
    *this = ::std::move(from);
  }

  inline EquipInfo& operator=(const EquipInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline EquipInfo& operator=(EquipInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EquipInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const EquipInfo* internal_default_instance() {
    return reinterpret_cast<const EquipInfo*>(
               &_EquipInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(EquipInfo& a, EquipInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(EquipInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EquipInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EquipInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EquipInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EquipInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const EquipInfo& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EquipInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "EquipInfo";
  }
  protected:
  explicit EquipInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAttrsFieldNumber = 3,
    kOwnerFieldNumber = 6,
    kLevelFieldNumber = 1,
    kExpFieldNumber = 2,
    kQualityFieldNumber = 4,
    kIsLockFieldNumber = 5,
    kOwnerTypeFieldNumber = 7,
    kIdxFieldNumber = 8,
  };
  // repeated .itemAttrInfo attrs = 3;
  int attrs_size() const;
  private:
  int _internal_attrs_size() const;
  public:
  void clear_attrs();
  ::itemAttrInfo* mutable_attrs(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::itemAttrInfo >*
      mutable_attrs();
  private:
  const ::itemAttrInfo& _internal_attrs(int index) const;
  ::itemAttrInfo* _internal_add_attrs();
  public:
  const ::itemAttrInfo& attrs(int index) const;
  ::itemAttrInfo* add_attrs();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::itemAttrInfo >&
      attrs() const;

  // string owner = 6;
  void clear_owner();
  const std::string& owner() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_owner(ArgT0&& arg0, ArgT... args);
  std::string* mutable_owner();
  PROTOBUF_NODISCARD std::string* release_owner();
  void set_allocated_owner(std::string* owner);
  private:
  const std::string& _internal_owner() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_owner(const std::string& value);
  std::string* _internal_mutable_owner();
  public:

  // int32 level = 1;
  void clear_level();
  int32_t level() const;
  void set_level(int32_t value);
  private:
  int32_t _internal_level() const;
  void _internal_set_level(int32_t value);
  public:

  // int32 exp = 2;
  void clear_exp();
  int32_t exp() const;
  void set_exp(int32_t value);
  private:
  int32_t _internal_exp() const;
  void _internal_set_exp(int32_t value);
  public:

  // int32 quality = 4;
  void clear_quality();
  int32_t quality() const;
  void set_quality(int32_t value);
  private:
  int32_t _internal_quality() const;
  void _internal_set_quality(int32_t value);
  public:

  // int32 isLock = 5;
  void clear_islock();
  int32_t islock() const;
  void set_islock(int32_t value);
  private:
  int32_t _internal_islock() const;
  void _internal_set_islock(int32_t value);
  public:

  // int32 ownerType = 7;
  void clear_ownertype();
  int32_t ownertype() const;
  void set_ownertype(int32_t value);
  private:
  int32_t _internal_ownertype() const;
  void _internal_set_ownertype(int32_t value);
  public:

  // int32 idx = 8;
  void clear_idx();
  int32_t idx() const;
  void set_idx(int32_t value);
  private:
  int32_t _internal_idx() const;
  void _internal_set_idx(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:EquipInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::itemAttrInfo > attrs_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr owner_;
  int32_t level_;
  int32_t exp_;
  int32_t quality_;
  int32_t islock_;
  int32_t ownertype_;
  int32_t idx_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Bag_2eproto;
};
// -------------------------------------------------------------------

class ItemInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ItemInfo) */ {
 public:
  inline ItemInfo() : ItemInfo(nullptr) {}
  ~ItemInfo() override;
  explicit PROTOBUF_CONSTEXPR ItemInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ItemInfo(const ItemInfo& from);
  ItemInfo(ItemInfo&& from) noexcept
    : ItemInfo() {
    *this = ::std::move(from);
  }

  inline ItemInfo& operator=(const ItemInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline ItemInfo& operator=(ItemInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ItemInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const ItemInfo* internal_default_instance() {
    return reinterpret_cast<const ItemInfo*>(
               &_ItemInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(ItemInfo& a, ItemInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(ItemInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ItemInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ItemInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ItemInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ItemInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ItemInfo& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ItemInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ItemInfo";
  }
  protected:
  explicit ItemInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCountFieldNumber = 2,
    kIdFieldNumber = 1,
    kTypeFieldNumber = 3,
    kOptFieldNumber = 4,
  };
  // uint64 count = 2;
  void clear_count();
  uint64_t count() const;
  void set_count(uint64_t value);
  private:
  uint64_t _internal_count() const;
  void _internal_set_count(uint64_t value);
  public:

  // int32 id = 1;
  void clear_id();
  int32_t id() const;
  void set_id(int32_t value);
  private:
  int32_t _internal_id() const;
  void _internal_set_id(int32_t value);
  public:

  // int32 type = 3;
  void clear_type();
  int32_t type() const;
  void set_type(int32_t value);
  private:
  int32_t _internal_type() const;
  void _internal_set_type(int32_t value);
  public:

  // int32 opt = 4;
  void clear_opt();
  int32_t opt() const;
  void set_opt(int32_t value);
  private:
  int32_t _internal_opt() const;
  void _internal_set_opt(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:ItemInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  uint64_t count_;
  int32_t id_;
  int32_t type_;
  int32_t opt_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Bag_2eproto;
};
// -------------------------------------------------------------------

class BagInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:BagInfo) */ {
 public:
  inline BagInfo() : BagInfo(nullptr) {}
  ~BagInfo() override;
  explicit PROTOBUF_CONSTEXPR BagInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BagInfo(const BagInfo& from);
  BagInfo(BagInfo&& from) noexcept
    : BagInfo() {
    *this = ::std::move(from);
  }

  inline BagInfo& operator=(const BagInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline BagInfo& operator=(BagInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BagInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const BagInfo* internal_default_instance() {
    return reinterpret_cast<const BagInfo*>(
               &_BagInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(BagInfo& a, BagInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(BagInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BagInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BagInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BagInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BagInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const BagInfo& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BagInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "BagInfo";
  }
  protected:
  explicit BagInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUidFieldNumber = 1,
    kItemFieldNumber = 2,
    kEquipFieldNumber = 3,
  };
  // string uid = 1;
  void clear_uid();
  const std::string& uid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_uid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_uid();
  PROTOBUF_NODISCARD std::string* release_uid();
  void set_allocated_uid(std::string* uid);
  private:
  const std::string& _internal_uid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_uid(const std::string& value);
  std::string* _internal_mutable_uid();
  public:

  // .ItemInfo item = 2;
  bool has_item() const;
  private:
  bool _internal_has_item() const;
  public:
  void clear_item();
  const ::ItemInfo& item() const;
  PROTOBUF_NODISCARD ::ItemInfo* release_item();
  ::ItemInfo* mutable_item();
  void set_allocated_item(::ItemInfo* item);
  private:
  const ::ItemInfo& _internal_item() const;
  ::ItemInfo* _internal_mutable_item();
  public:
  void unsafe_arena_set_allocated_item(
      ::ItemInfo* item);
  ::ItemInfo* unsafe_arena_release_item();

  // .EquipInfo equip = 3;
  bool has_equip() const;
  private:
  bool _internal_has_equip() const;
  public:
  void clear_equip();
  const ::EquipInfo& equip() const;
  PROTOBUF_NODISCARD ::EquipInfo* release_equip();
  ::EquipInfo* mutable_equip();
  void set_allocated_equip(::EquipInfo* equip);
  private:
  const ::EquipInfo& _internal_equip() const;
  ::EquipInfo* _internal_mutable_equip();
  public:
  void unsafe_arena_set_allocated_equip(
      ::EquipInfo* equip);
  ::EquipInfo* unsafe_arena_release_equip();

  // @@protoc_insertion_point(class_scope:BagInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr uid_;
  ::ItemInfo* item_;
  ::EquipInfo* equip_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Bag_2eproto;
};
// -------------------------------------------------------------------

class ReqAllBagInfo final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:ReqAllBagInfo) */ {
 public:
  inline ReqAllBagInfo() : ReqAllBagInfo(nullptr) {}
  explicit PROTOBUF_CONSTEXPR ReqAllBagInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ReqAllBagInfo(const ReqAllBagInfo& from);
  ReqAllBagInfo(ReqAllBagInfo&& from) noexcept
    : ReqAllBagInfo() {
    *this = ::std::move(from);
  }

  inline ReqAllBagInfo& operator=(const ReqAllBagInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReqAllBagInfo& operator=(ReqAllBagInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReqAllBagInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const ReqAllBagInfo* internal_default_instance() {
    return reinterpret_cast<const ReqAllBagInfo*>(
               &_ReqAllBagInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(ReqAllBagInfo& a, ReqAllBagInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(ReqAllBagInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReqAllBagInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReqAllBagInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ReqAllBagInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const ReqAllBagInfo& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const ReqAllBagInfo& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ReqAllBagInfo";
  }
  protected:
  explicit ReqAllBagInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:ReqAllBagInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  friend struct ::TableStruct_Bag_2eproto;
};
// -------------------------------------------------------------------

class ResAllBagInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ResAllBagInfo) */ {
 public:
  inline ResAllBagInfo() : ResAllBagInfo(nullptr) {}
  ~ResAllBagInfo() override;
  explicit PROTOBUF_CONSTEXPR ResAllBagInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ResAllBagInfo(const ResAllBagInfo& from);
  ResAllBagInfo(ResAllBagInfo&& from) noexcept
    : ResAllBagInfo() {
    *this = ::std::move(from);
  }

  inline ResAllBagInfo& operator=(const ResAllBagInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline ResAllBagInfo& operator=(ResAllBagInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ResAllBagInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const ResAllBagInfo* internal_default_instance() {
    return reinterpret_cast<const ResAllBagInfo*>(
               &_ResAllBagInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(ResAllBagInfo& a, ResAllBagInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(ResAllBagInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ResAllBagInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ResAllBagInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ResAllBagInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ResAllBagInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ResAllBagInfo& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResAllBagInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ResAllBagInfo";
  }
  protected:
  explicit ResAllBagInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBagFieldNumber = 1,
  };
  // repeated .BagInfo bag = 1;
  int bag_size() const;
  private:
  int _internal_bag_size() const;
  public:
  void clear_bag();
  ::BagInfo* mutable_bag(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::BagInfo >*
      mutable_bag();
  private:
  const ::BagInfo& _internal_bag(int index) const;
  ::BagInfo* _internal_add_bag();
  public:
  const ::BagInfo& bag(int index) const;
  ::BagInfo* add_bag();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::BagInfo >&
      bag() const;

  // @@protoc_insertion_point(class_scope:ResAllBagInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::BagInfo > bag_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Bag_2eproto;
};
// -------------------------------------------------------------------

class NotifyBagInfoSignUp final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:NotifyBagInfoSignUp) */ {
 public:
  inline NotifyBagInfoSignUp() : NotifyBagInfoSignUp(nullptr) {}
  ~NotifyBagInfoSignUp() override;
  explicit PROTOBUF_CONSTEXPR NotifyBagInfoSignUp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NotifyBagInfoSignUp(const NotifyBagInfoSignUp& from);
  NotifyBagInfoSignUp(NotifyBagInfoSignUp&& from) noexcept
    : NotifyBagInfoSignUp() {
    *this = ::std::move(from);
  }

  inline NotifyBagInfoSignUp& operator=(const NotifyBagInfoSignUp& from) {
    CopyFrom(from);
    return *this;
  }
  inline NotifyBagInfoSignUp& operator=(NotifyBagInfoSignUp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NotifyBagInfoSignUp& default_instance() {
    return *internal_default_instance();
  }
  static inline const NotifyBagInfoSignUp* internal_default_instance() {
    return reinterpret_cast<const NotifyBagInfoSignUp*>(
               &_NotifyBagInfoSignUp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(NotifyBagInfoSignUp& a, NotifyBagInfoSignUp& b) {
    a.Swap(&b);
  }
  inline void Swap(NotifyBagInfoSignUp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NotifyBagInfoSignUp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NotifyBagInfoSignUp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NotifyBagInfoSignUp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NotifyBagInfoSignUp& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const NotifyBagInfoSignUp& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NotifyBagInfoSignUp* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "NotifyBagInfoSignUp";
  }
  protected:
  explicit NotifyBagInfoSignUp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBagFieldNumber = 1,
  };
  // repeated .BagInfo bag = 1;
  int bag_size() const;
  private:
  int _internal_bag_size() const;
  public:
  void clear_bag();
  ::BagInfo* mutable_bag(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::BagInfo >*
      mutable_bag();
  private:
  const ::BagInfo& _internal_bag(int index) const;
  ::BagInfo* _internal_add_bag();
  public:
  const ::BagInfo& bag(int index) const;
  ::BagInfo* add_bag();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::BagInfo >&
      bag() const;

  // @@protoc_insertion_point(class_scope:NotifyBagInfoSignUp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::BagInfo > bag_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Bag_2eproto;
};
// -------------------------------------------------------------------

class NotifyDeleteItem final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:NotifyDeleteItem) */ {
 public:
  inline NotifyDeleteItem() : NotifyDeleteItem(nullptr) {}
  ~NotifyDeleteItem() override;
  explicit PROTOBUF_CONSTEXPR NotifyDeleteItem(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NotifyDeleteItem(const NotifyDeleteItem& from);
  NotifyDeleteItem(NotifyDeleteItem&& from) noexcept
    : NotifyDeleteItem() {
    *this = ::std::move(from);
  }

  inline NotifyDeleteItem& operator=(const NotifyDeleteItem& from) {
    CopyFrom(from);
    return *this;
  }
  inline NotifyDeleteItem& operator=(NotifyDeleteItem&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NotifyDeleteItem& default_instance() {
    return *internal_default_instance();
  }
  static inline const NotifyDeleteItem* internal_default_instance() {
    return reinterpret_cast<const NotifyDeleteItem*>(
               &_NotifyDeleteItem_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(NotifyDeleteItem& a, NotifyDeleteItem& b) {
    a.Swap(&b);
  }
  inline void Swap(NotifyDeleteItem* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NotifyDeleteItem* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NotifyDeleteItem* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NotifyDeleteItem>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NotifyDeleteItem& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const NotifyDeleteItem& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NotifyDeleteItem* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "NotifyDeleteItem";
  }
  protected:
  explicit NotifyDeleteItem(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBagFieldNumber = 1,
  };
  // repeated string bag = 1;
  int bag_size() const;
  private:
  int _internal_bag_size() const;
  public:
  void clear_bag();
  const std::string& bag(int index) const;
  std::string* mutable_bag(int index);
  void set_bag(int index, const std::string& value);
  void set_bag(int index, std::string&& value);
  void set_bag(int index, const char* value);
  void set_bag(int index, const char* value, size_t size);
  std::string* add_bag();
  void add_bag(const std::string& value);
  void add_bag(std::string&& value);
  void add_bag(const char* value);
  void add_bag(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& bag() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_bag();
  private:
  const std::string& _internal_bag(int index) const;
  std::string* _internal_add_bag();
  public:

  // @@protoc_insertion_point(class_scope:NotifyDeleteItem)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> bag_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Bag_2eproto;
};
// -------------------------------------------------------------------

class CurrencyInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CurrencyInfo) */ {
 public:
  inline CurrencyInfo() : CurrencyInfo(nullptr) {}
  ~CurrencyInfo() override;
  explicit PROTOBUF_CONSTEXPR CurrencyInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CurrencyInfo(const CurrencyInfo& from);
  CurrencyInfo(CurrencyInfo&& from) noexcept
    : CurrencyInfo() {
    *this = ::std::move(from);
  }

  inline CurrencyInfo& operator=(const CurrencyInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline CurrencyInfo& operator=(CurrencyInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CurrencyInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const CurrencyInfo* internal_default_instance() {
    return reinterpret_cast<const CurrencyInfo*>(
               &_CurrencyInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(CurrencyInfo& a, CurrencyInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(CurrencyInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CurrencyInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CurrencyInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CurrencyInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CurrencyInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CurrencyInfo& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CurrencyInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CurrencyInfo";
  }
  protected:
  explicit CurrencyInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 2,
    kIdFieldNumber = 1,
  };
  // uint64 value = 2;
  void clear_value();
  uint64_t value() const;
  void set_value(uint64_t value);
  private:
  uint64_t _internal_value() const;
  void _internal_set_value(uint64_t value);
  public:

  // int32 id = 1;
  void clear_id();
  int32_t id() const;
  void set_id(int32_t value);
  private:
  int32_t _internal_id() const;
  void _internal_set_id(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:CurrencyInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  uint64_t value_;
  int32_t id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Bag_2eproto;
};
// -------------------------------------------------------------------

class ReqCurrencyInfo final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:ReqCurrencyInfo) */ {
 public:
  inline ReqCurrencyInfo() : ReqCurrencyInfo(nullptr) {}
  explicit PROTOBUF_CONSTEXPR ReqCurrencyInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ReqCurrencyInfo(const ReqCurrencyInfo& from);
  ReqCurrencyInfo(ReqCurrencyInfo&& from) noexcept
    : ReqCurrencyInfo() {
    *this = ::std::move(from);
  }

  inline ReqCurrencyInfo& operator=(const ReqCurrencyInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReqCurrencyInfo& operator=(ReqCurrencyInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReqCurrencyInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const ReqCurrencyInfo* internal_default_instance() {
    return reinterpret_cast<const ReqCurrencyInfo*>(
               &_ReqCurrencyInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(ReqCurrencyInfo& a, ReqCurrencyInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(ReqCurrencyInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReqCurrencyInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReqCurrencyInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ReqCurrencyInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const ReqCurrencyInfo& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const ReqCurrencyInfo& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ReqCurrencyInfo";
  }
  protected:
  explicit ReqCurrencyInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:ReqCurrencyInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  friend struct ::TableStruct_Bag_2eproto;
};
// -------------------------------------------------------------------

class ResCurrencyInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ResCurrencyInfo) */ {
 public:
  inline ResCurrencyInfo() : ResCurrencyInfo(nullptr) {}
  ~ResCurrencyInfo() override;
  explicit PROTOBUF_CONSTEXPR ResCurrencyInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ResCurrencyInfo(const ResCurrencyInfo& from);
  ResCurrencyInfo(ResCurrencyInfo&& from) noexcept
    : ResCurrencyInfo() {
    *this = ::std::move(from);
  }

  inline ResCurrencyInfo& operator=(const ResCurrencyInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline ResCurrencyInfo& operator=(ResCurrencyInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ResCurrencyInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const ResCurrencyInfo* internal_default_instance() {
    return reinterpret_cast<const ResCurrencyInfo*>(
               &_ResCurrencyInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(ResCurrencyInfo& a, ResCurrencyInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(ResCurrencyInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ResCurrencyInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ResCurrencyInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ResCurrencyInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ResCurrencyInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ResCurrencyInfo& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResCurrencyInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ResCurrencyInfo";
  }
  protected:
  explicit ResCurrencyInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCurrencyFieldNumber = 1,
  };
  // repeated .CurrencyInfo currency = 1;
  int currency_size() const;
  private:
  int _internal_currency_size() const;
  public:
  void clear_currency();
  ::CurrencyInfo* mutable_currency(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CurrencyInfo >*
      mutable_currency();
  private:
  const ::CurrencyInfo& _internal_currency(int index) const;
  ::CurrencyInfo* _internal_add_currency();
  public:
  const ::CurrencyInfo& currency(int index) const;
  ::CurrencyInfo* add_currency();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CurrencyInfo >&
      currency() const;

  // @@protoc_insertion_point(class_scope:ResCurrencyInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CurrencyInfo > currency_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Bag_2eproto;
};
// -------------------------------------------------------------------

class NotifyCurrencyUpdate final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:NotifyCurrencyUpdate) */ {
 public:
  inline NotifyCurrencyUpdate() : NotifyCurrencyUpdate(nullptr) {}
  ~NotifyCurrencyUpdate() override;
  explicit PROTOBUF_CONSTEXPR NotifyCurrencyUpdate(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NotifyCurrencyUpdate(const NotifyCurrencyUpdate& from);
  NotifyCurrencyUpdate(NotifyCurrencyUpdate&& from) noexcept
    : NotifyCurrencyUpdate() {
    *this = ::std::move(from);
  }

  inline NotifyCurrencyUpdate& operator=(const NotifyCurrencyUpdate& from) {
    CopyFrom(from);
    return *this;
  }
  inline NotifyCurrencyUpdate& operator=(NotifyCurrencyUpdate&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NotifyCurrencyUpdate& default_instance() {
    return *internal_default_instance();
  }
  static inline const NotifyCurrencyUpdate* internal_default_instance() {
    return reinterpret_cast<const NotifyCurrencyUpdate*>(
               &_NotifyCurrencyUpdate_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(NotifyCurrencyUpdate& a, NotifyCurrencyUpdate& b) {
    a.Swap(&b);
  }
  inline void Swap(NotifyCurrencyUpdate* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NotifyCurrencyUpdate* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NotifyCurrencyUpdate* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NotifyCurrencyUpdate>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NotifyCurrencyUpdate& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const NotifyCurrencyUpdate& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NotifyCurrencyUpdate* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "NotifyCurrencyUpdate";
  }
  protected:
  explicit NotifyCurrencyUpdate(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCurrencyFieldNumber = 1,
  };
  // repeated .CurrencyInfo currency = 1;
  int currency_size() const;
  private:
  int _internal_currency_size() const;
  public:
  void clear_currency();
  ::CurrencyInfo* mutable_currency(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CurrencyInfo >*
      mutable_currency();
  private:
  const ::CurrencyInfo& _internal_currency(int index) const;
  ::CurrencyInfo* _internal_add_currency();
  public:
  const ::CurrencyInfo& currency(int index) const;
  ::CurrencyInfo* add_currency();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CurrencyInfo >&
      currency() const;

  // @@protoc_insertion_point(class_scope:NotifyCurrencyUpdate)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CurrencyInfo > currency_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Bag_2eproto;
};
// -------------------------------------------------------------------

class NotifyDeleteCurrency final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:NotifyDeleteCurrency) */ {
 public:
  inline NotifyDeleteCurrency() : NotifyDeleteCurrency(nullptr) {}
  ~NotifyDeleteCurrency() override;
  explicit PROTOBUF_CONSTEXPR NotifyDeleteCurrency(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NotifyDeleteCurrency(const NotifyDeleteCurrency& from);
  NotifyDeleteCurrency(NotifyDeleteCurrency&& from) noexcept
    : NotifyDeleteCurrency() {
    *this = ::std::move(from);
  }

  inline NotifyDeleteCurrency& operator=(const NotifyDeleteCurrency& from) {
    CopyFrom(from);
    return *this;
  }
  inline NotifyDeleteCurrency& operator=(NotifyDeleteCurrency&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NotifyDeleteCurrency& default_instance() {
    return *internal_default_instance();
  }
  static inline const NotifyDeleteCurrency* internal_default_instance() {
    return reinterpret_cast<const NotifyDeleteCurrency*>(
               &_NotifyDeleteCurrency_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(NotifyDeleteCurrency& a, NotifyDeleteCurrency& b) {
    a.Swap(&b);
  }
  inline void Swap(NotifyDeleteCurrency* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NotifyDeleteCurrency* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NotifyDeleteCurrency* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NotifyDeleteCurrency>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NotifyDeleteCurrency& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const NotifyDeleteCurrency& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NotifyDeleteCurrency* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "NotifyDeleteCurrency";
  }
  protected:
  explicit NotifyDeleteCurrency(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCurrencyFieldNumber = 1,
  };
  // repeated int32 currency = 1;
  int currency_size() const;
  private:
  int _internal_currency_size() const;
  public:
  void clear_currency();
  private:
  int32_t _internal_currency(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      _internal_currency() const;
  void _internal_add_currency(int32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      _internal_mutable_currency();
  public:
  int32_t currency(int index) const;
  void set_currency(int index, int32_t value);
  void add_currency(int32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      currency() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      mutable_currency();

  // @@protoc_insertion_point(class_scope:NotifyDeleteCurrency)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t > currency_;
  mutable std::atomic<int> _currency_cached_byte_size_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Bag_2eproto;
};
// -------------------------------------------------------------------

class NotifyClientRewardTips final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:NotifyClientRewardTips) */ {
 public:
  inline NotifyClientRewardTips() : NotifyClientRewardTips(nullptr) {}
  ~NotifyClientRewardTips() override;
  explicit PROTOBUF_CONSTEXPR NotifyClientRewardTips(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NotifyClientRewardTips(const NotifyClientRewardTips& from);
  NotifyClientRewardTips(NotifyClientRewardTips&& from) noexcept
    : NotifyClientRewardTips() {
    *this = ::std::move(from);
  }

  inline NotifyClientRewardTips& operator=(const NotifyClientRewardTips& from) {
    CopyFrom(from);
    return *this;
  }
  inline NotifyClientRewardTips& operator=(NotifyClientRewardTips&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NotifyClientRewardTips& default_instance() {
    return *internal_default_instance();
  }
  static inline const NotifyClientRewardTips* internal_default_instance() {
    return reinterpret_cast<const NotifyClientRewardTips*>(
               &_NotifyClientRewardTips_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(NotifyClientRewardTips& a, NotifyClientRewardTips& b) {
    a.Swap(&b);
  }
  inline void Swap(NotifyClientRewardTips* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NotifyClientRewardTips* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NotifyClientRewardTips* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NotifyClientRewardTips>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NotifyClientRewardTips& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const NotifyClientRewardTips& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NotifyClientRewardTips* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "NotifyClientRewardTips";
  }
  protected:
  explicit NotifyClientRewardTips(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 1,
    kRdTypeFieldNumber = 2,
    kParam1FieldNumber = 3,
    kParam2FieldNumber = 4,
    kParam3FieldNumber = 5,
    kParam4FieldNumber = 6,
    kParam5FieldNumber = 7,
    kParam6FieldNumber = 8,
  };
  // repeated .ItemInfo data = 1;
  int data_size() const;
  private:
  int _internal_data_size() const;
  public:
  void clear_data();
  ::ItemInfo* mutable_data(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ItemInfo >*
      mutable_data();
  private:
  const ::ItemInfo& _internal_data(int index) const;
  ::ItemInfo* _internal_add_data();
  public:
  const ::ItemInfo& data(int index) const;
  ::ItemInfo* add_data();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ItemInfo >&
      data() const;

  // uint32 rdType = 2;
  void clear_rdtype();
  uint32_t rdtype() const;
  void set_rdtype(uint32_t value);
  private:
  uint32_t _internal_rdtype() const;
  void _internal_set_rdtype(uint32_t value);
  public:

  // uint32 param1 = 3;
  void clear_param1();
  uint32_t param1() const;
  void set_param1(uint32_t value);
  private:
  uint32_t _internal_param1() const;
  void _internal_set_param1(uint32_t value);
  public:

  // uint32 param2 = 4;
  void clear_param2();
  uint32_t param2() const;
  void set_param2(uint32_t value);
  private:
  uint32_t _internal_param2() const;
  void _internal_set_param2(uint32_t value);
  public:

  // sint32 param3 = 5;
  void clear_param3();
  int32_t param3() const;
  void set_param3(int32_t value);
  private:
  int32_t _internal_param3() const;
  void _internal_set_param3(int32_t value);
  public:

  // uint64 param4 = 6;
  void clear_param4();
  uint64_t param4() const;
  void set_param4(uint64_t value);
  private:
  uint64_t _internal_param4() const;
  void _internal_set_param4(uint64_t value);
  public:

  // uint64 param5 = 7;
  void clear_param5();
  uint64_t param5() const;
  void set_param5(uint64_t value);
  private:
  uint64_t _internal_param5() const;
  void _internal_set_param5(uint64_t value);
  public:

  // sint64 param6 = 8;
  void clear_param6();
  int64_t param6() const;
  void set_param6(int64_t value);
  private:
  int64_t _internal_param6() const;
  void _internal_set_param6(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:NotifyClientRewardTips)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ItemInfo > data_;
  uint32_t rdtype_;
  uint32_t param1_;
  uint32_t param2_;
  int32_t param3_;
  uint64_t param4_;
  uint64_t param5_;
  int64_t param6_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Bag_2eproto;
};
// -------------------------------------------------------------------

class ReqBagItemLock final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ReqBagItemLock) */ {
 public:
  inline ReqBagItemLock() : ReqBagItemLock(nullptr) {}
  ~ReqBagItemLock() override;
  explicit PROTOBUF_CONSTEXPR ReqBagItemLock(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ReqBagItemLock(const ReqBagItemLock& from);
  ReqBagItemLock(ReqBagItemLock&& from) noexcept
    : ReqBagItemLock() {
    *this = ::std::move(from);
  }

  inline ReqBagItemLock& operator=(const ReqBagItemLock& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReqBagItemLock& operator=(ReqBagItemLock&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReqBagItemLock& default_instance() {
    return *internal_default_instance();
  }
  static inline const ReqBagItemLock* internal_default_instance() {
    return reinterpret_cast<const ReqBagItemLock*>(
               &_ReqBagItemLock_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(ReqBagItemLock& a, ReqBagItemLock& b) {
    a.Swap(&b);
  }
  inline void Swap(ReqBagItemLock* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReqBagItemLock* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReqBagItemLock* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ReqBagItemLock>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ReqBagItemLock& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ReqBagItemLock& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReqBagItemLock* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ReqBagItemLock";
  }
  protected:
  explicit ReqBagItemLock(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUidFieldNumber = 1,
    kIsLockFieldNumber = 2,
  };
  // string uid = 1;
  void clear_uid();
  const std::string& uid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_uid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_uid();
  PROTOBUF_NODISCARD std::string* release_uid();
  void set_allocated_uid(std::string* uid);
  private:
  const std::string& _internal_uid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_uid(const std::string& value);
  std::string* _internal_mutable_uid();
  public:

  // int32 isLock = 2;
  void clear_islock();
  int32_t islock() const;
  void set_islock(int32_t value);
  private:
  int32_t _internal_islock() const;
  void _internal_set_islock(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:ReqBagItemLock)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr uid_;
  int32_t islock_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Bag_2eproto;
};
// -------------------------------------------------------------------

class ResBagItemLock final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ResBagItemLock) */ {
 public:
  inline ResBagItemLock() : ResBagItemLock(nullptr) {}
  ~ResBagItemLock() override;
  explicit PROTOBUF_CONSTEXPR ResBagItemLock(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ResBagItemLock(const ResBagItemLock& from);
  ResBagItemLock(ResBagItemLock&& from) noexcept
    : ResBagItemLock() {
    *this = ::std::move(from);
  }

  inline ResBagItemLock& operator=(const ResBagItemLock& from) {
    CopyFrom(from);
    return *this;
  }
  inline ResBagItemLock& operator=(ResBagItemLock&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ResBagItemLock& default_instance() {
    return *internal_default_instance();
  }
  static inline const ResBagItemLock* internal_default_instance() {
    return reinterpret_cast<const ResBagItemLock*>(
               &_ResBagItemLock_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(ResBagItemLock& a, ResBagItemLock& b) {
    a.Swap(&b);
  }
  inline void Swap(ResBagItemLock* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ResBagItemLock* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ResBagItemLock* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ResBagItemLock>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ResBagItemLock& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ResBagItemLock& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResBagItemLock* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ResBagItemLock";
  }
  protected:
  explicit ResBagItemLock(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUidFieldNumber = 1,
    kIsLockFieldNumber = 2,
  };
  // string uid = 1;
  void clear_uid();
  const std::string& uid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_uid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_uid();
  PROTOBUF_NODISCARD std::string* release_uid();
  void set_allocated_uid(std::string* uid);
  private:
  const std::string& _internal_uid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_uid(const std::string& value);
  std::string* _internal_mutable_uid();
  public:

  // int32 isLock = 2;
  void clear_islock();
  int32_t islock() const;
  void set_islock(int32_t value);
  private:
  int32_t _internal_islock() const;
  void _internal_set_islock(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:ResBagItemLock)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr uid_;
  int32_t islock_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Bag_2eproto;
};
// -------------------------------------------------------------------

class ReqBagDelItem final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ReqBagDelItem) */ {
 public:
  inline ReqBagDelItem() : ReqBagDelItem(nullptr) {}
  ~ReqBagDelItem() override;
  explicit PROTOBUF_CONSTEXPR ReqBagDelItem(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ReqBagDelItem(const ReqBagDelItem& from);
  ReqBagDelItem(ReqBagDelItem&& from) noexcept
    : ReqBagDelItem() {
    *this = ::std::move(from);
  }

  inline ReqBagDelItem& operator=(const ReqBagDelItem& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReqBagDelItem& operator=(ReqBagDelItem&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReqBagDelItem& default_instance() {
    return *internal_default_instance();
  }
  static inline const ReqBagDelItem* internal_default_instance() {
    return reinterpret_cast<const ReqBagDelItem*>(
               &_ReqBagDelItem_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(ReqBagDelItem& a, ReqBagDelItem& b) {
    a.Swap(&b);
  }
  inline void Swap(ReqBagDelItem* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReqBagDelItem* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReqBagDelItem* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ReqBagDelItem>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ReqBagDelItem& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ReqBagDelItem& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReqBagDelItem* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ReqBagDelItem";
  }
  protected:
  explicit ReqBagDelItem(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUidFieldNumber = 1,
  };
  // string uid = 1;
  void clear_uid();
  const std::string& uid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_uid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_uid();
  PROTOBUF_NODISCARD std::string* release_uid();
  void set_allocated_uid(std::string* uid);
  private:
  const std::string& _internal_uid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_uid(const std::string& value);
  std::string* _internal_mutable_uid();
  public:

  // @@protoc_insertion_point(class_scope:ReqBagDelItem)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr uid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Bag_2eproto;
};
// -------------------------------------------------------------------

class ReqEquipLevelUp final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ReqEquipLevelUp) */ {
 public:
  inline ReqEquipLevelUp() : ReqEquipLevelUp(nullptr) {}
  ~ReqEquipLevelUp() override;
  explicit PROTOBUF_CONSTEXPR ReqEquipLevelUp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ReqEquipLevelUp(const ReqEquipLevelUp& from);
  ReqEquipLevelUp(ReqEquipLevelUp&& from) noexcept
    : ReqEquipLevelUp() {
    *this = ::std::move(from);
  }

  inline ReqEquipLevelUp& operator=(const ReqEquipLevelUp& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReqEquipLevelUp& operator=(ReqEquipLevelUp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReqEquipLevelUp& default_instance() {
    return *internal_default_instance();
  }
  static inline const ReqEquipLevelUp* internal_default_instance() {
    return reinterpret_cast<const ReqEquipLevelUp*>(
               &_ReqEquipLevelUp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(ReqEquipLevelUp& a, ReqEquipLevelUp& b) {
    a.Swap(&b);
  }
  inline void Swap(ReqEquipLevelUp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReqEquipLevelUp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReqEquipLevelUp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ReqEquipLevelUp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ReqEquipLevelUp& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ReqEquipLevelUp& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReqEquipLevelUp* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ReqEquipLevelUp";
  }
  protected:
  explicit ReqEquipLevelUp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kItemlistFieldNumber = 2,
    kUidsFieldNumber = 3,
    kUidFieldNumber = 1,
    kHeroIdFieldNumber = 4,
  };
  // repeated .ItemInfo itemlist = 2;
  int itemlist_size() const;
  private:
  int _internal_itemlist_size() const;
  public:
  void clear_itemlist();
  ::ItemInfo* mutable_itemlist(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ItemInfo >*
      mutable_itemlist();
  private:
  const ::ItemInfo& _internal_itemlist(int index) const;
  ::ItemInfo* _internal_add_itemlist();
  public:
  const ::ItemInfo& itemlist(int index) const;
  ::ItemInfo* add_itemlist();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ItemInfo >&
      itemlist() const;

  // repeated string uids = 3;
  int uids_size() const;
  private:
  int _internal_uids_size() const;
  public:
  void clear_uids();
  const std::string& uids(int index) const;
  std::string* mutable_uids(int index);
  void set_uids(int index, const std::string& value);
  void set_uids(int index, std::string&& value);
  void set_uids(int index, const char* value);
  void set_uids(int index, const char* value, size_t size);
  std::string* add_uids();
  void add_uids(const std::string& value);
  void add_uids(std::string&& value);
  void add_uids(const char* value);
  void add_uids(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& uids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_uids();
  private:
  const std::string& _internal_uids(int index) const;
  std::string* _internal_add_uids();
  public:

  // string uid = 1;
  void clear_uid();
  const std::string& uid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_uid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_uid();
  PROTOBUF_NODISCARD std::string* release_uid();
  void set_allocated_uid(std::string* uid);
  private:
  const std::string& _internal_uid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_uid(const std::string& value);
  std::string* _internal_mutable_uid();
  public:

  // int32 heroId = 4;
  void clear_heroid();
  int32_t heroid() const;
  void set_heroid(int32_t value);
  private:
  int32_t _internal_heroid() const;
  void _internal_set_heroid(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:ReqEquipLevelUp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ItemInfo > itemlist_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> uids_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr uid_;
  int32_t heroid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Bag_2eproto;
};
// -------------------------------------------------------------------

class ResEquipLevelUp final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ResEquipLevelUp) */ {
 public:
  inline ResEquipLevelUp() : ResEquipLevelUp(nullptr) {}
  ~ResEquipLevelUp() override;
  explicit PROTOBUF_CONSTEXPR ResEquipLevelUp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ResEquipLevelUp(const ResEquipLevelUp& from);
  ResEquipLevelUp(ResEquipLevelUp&& from) noexcept
    : ResEquipLevelUp() {
    *this = ::std::move(from);
  }

  inline ResEquipLevelUp& operator=(const ResEquipLevelUp& from) {
    CopyFrom(from);
    return *this;
  }
  inline ResEquipLevelUp& operator=(ResEquipLevelUp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ResEquipLevelUp& default_instance() {
    return *internal_default_instance();
  }
  static inline const ResEquipLevelUp* internal_default_instance() {
    return reinterpret_cast<const ResEquipLevelUp*>(
               &_ResEquipLevelUp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(ResEquipLevelUp& a, ResEquipLevelUp& b) {
    a.Swap(&b);
  }
  inline void Swap(ResEquipLevelUp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ResEquipLevelUp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ResEquipLevelUp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ResEquipLevelUp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ResEquipLevelUp& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ResEquipLevelUp& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResEquipLevelUp* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ResEquipLevelUp";
  }
  protected:
  explicit ResEquipLevelUp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAttrsFieldNumber = 5,
    kGuidFieldNumber = 1,
    kLevelFieldNumber = 2,
    kExpFieldNumber = 3,
    kHeroIdFieldNumber = 4,
  };
  // repeated .itemAttrInfo attrs = 5;
  int attrs_size() const;
  private:
  int _internal_attrs_size() const;
  public:
  void clear_attrs();
  ::itemAttrInfo* mutable_attrs(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::itemAttrInfo >*
      mutable_attrs();
  private:
  const ::itemAttrInfo& _internal_attrs(int index) const;
  ::itemAttrInfo* _internal_add_attrs();
  public:
  const ::itemAttrInfo& attrs(int index) const;
  ::itemAttrInfo* add_attrs();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::itemAttrInfo >&
      attrs() const;

  // string guid = 1;
  void clear_guid();
  const std::string& guid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_guid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_guid();
  PROTOBUF_NODISCARD std::string* release_guid();
  void set_allocated_guid(std::string* guid);
  private:
  const std::string& _internal_guid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_guid(const std::string& value);
  std::string* _internal_mutable_guid();
  public:

  // int32 level = 2;
  void clear_level();
  int32_t level() const;
  void set_level(int32_t value);
  private:
  int32_t _internal_level() const;
  void _internal_set_level(int32_t value);
  public:

  // int32 exp = 3;
  void clear_exp();
  int32_t exp() const;
  void set_exp(int32_t value);
  private:
  int32_t _internal_exp() const;
  void _internal_set_exp(int32_t value);
  public:

  // int32 heroId = 4;
  void clear_heroid();
  int32_t heroid() const;
  void set_heroid(int32_t value);
  private:
  int32_t _internal_heroid() const;
  void _internal_set_heroid(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:ResEquipLevelUp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::itemAttrInfo > attrs_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr guid_;
  int32_t level_;
  int32_t exp_;
  int32_t heroid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Bag_2eproto;
};
// -------------------------------------------------------------------

class ReqUseItem final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ReqUseItem) */ {
 public:
  inline ReqUseItem() : ReqUseItem(nullptr) {}
  ~ReqUseItem() override;
  explicit PROTOBUF_CONSTEXPR ReqUseItem(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ReqUseItem(const ReqUseItem& from);
  ReqUseItem(ReqUseItem&& from) noexcept
    : ReqUseItem() {
    *this = ::std::move(from);
  }

  inline ReqUseItem& operator=(const ReqUseItem& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReqUseItem& operator=(ReqUseItem&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReqUseItem& default_instance() {
    return *internal_default_instance();
  }
  static inline const ReqUseItem* internal_default_instance() {
    return reinterpret_cast<const ReqUseItem*>(
               &_ReqUseItem_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(ReqUseItem& a, ReqUseItem& b) {
    a.Swap(&b);
  }
  inline void Swap(ReqUseItem* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReqUseItem* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReqUseItem* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ReqUseItem>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ReqUseItem& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ReqUseItem& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReqUseItem* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ReqUseItem";
  }
  protected:
  explicit ReqUseItem(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kCntFieldNumber = 2,
  };
  // int32 id = 1;
  void clear_id();
  int32_t id() const;
  void set_id(int32_t value);
  private:
  int32_t _internal_id() const;
  void _internal_set_id(int32_t value);
  public:

  // int32 cnt = 2;
  void clear_cnt();
  int32_t cnt() const;
  void set_cnt(int32_t value);
  private:
  int32_t _internal_cnt() const;
  void _internal_set_cnt(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:ReqUseItem)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int32_t id_;
  int32_t cnt_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Bag_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// itemAttrInfo

// int32 type = 1;
inline void itemAttrInfo::clear_type() {
  type_ = 0;
}
inline int32_t itemAttrInfo::_internal_type() const {
  return type_;
}
inline int32_t itemAttrInfo::type() const {
  // @@protoc_insertion_point(field_get:itemAttrInfo.type)
  return _internal_type();
}
inline void itemAttrInfo::_internal_set_type(int32_t value) {
  
  type_ = value;
}
inline void itemAttrInfo::set_type(int32_t value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:itemAttrInfo.type)
}

// int32 value = 2;
inline void itemAttrInfo::clear_value() {
  value_ = 0;
}
inline int32_t itemAttrInfo::_internal_value() const {
  return value_;
}
inline int32_t itemAttrInfo::value() const {
  // @@protoc_insertion_point(field_get:itemAttrInfo.value)
  return _internal_value();
}
inline void itemAttrInfo::_internal_set_value(int32_t value) {
  
  value_ = value;
}
inline void itemAttrInfo::set_value(int32_t value) {
  _internal_set_value(value);
  // @@protoc_insertion_point(field_set:itemAttrInfo.value)
}

// -------------------------------------------------------------------

// EquipInfo

// int32 level = 1;
inline void EquipInfo::clear_level() {
  level_ = 0;
}
inline int32_t EquipInfo::_internal_level() const {
  return level_;
}
inline int32_t EquipInfo::level() const {
  // @@protoc_insertion_point(field_get:EquipInfo.level)
  return _internal_level();
}
inline void EquipInfo::_internal_set_level(int32_t value) {
  
  level_ = value;
}
inline void EquipInfo::set_level(int32_t value) {
  _internal_set_level(value);
  // @@protoc_insertion_point(field_set:EquipInfo.level)
}

// int32 exp = 2;
inline void EquipInfo::clear_exp() {
  exp_ = 0;
}
inline int32_t EquipInfo::_internal_exp() const {
  return exp_;
}
inline int32_t EquipInfo::exp() const {
  // @@protoc_insertion_point(field_get:EquipInfo.exp)
  return _internal_exp();
}
inline void EquipInfo::_internal_set_exp(int32_t value) {
  
  exp_ = value;
}
inline void EquipInfo::set_exp(int32_t value) {
  _internal_set_exp(value);
  // @@protoc_insertion_point(field_set:EquipInfo.exp)
}

// repeated .itemAttrInfo attrs = 3;
inline int EquipInfo::_internal_attrs_size() const {
  return attrs_.size();
}
inline int EquipInfo::attrs_size() const {
  return _internal_attrs_size();
}
inline void EquipInfo::clear_attrs() {
  attrs_.Clear();
}
inline ::itemAttrInfo* EquipInfo::mutable_attrs(int index) {
  // @@protoc_insertion_point(field_mutable:EquipInfo.attrs)
  return attrs_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::itemAttrInfo >*
EquipInfo::mutable_attrs() {
  // @@protoc_insertion_point(field_mutable_list:EquipInfo.attrs)
  return &attrs_;
}
inline const ::itemAttrInfo& EquipInfo::_internal_attrs(int index) const {
  return attrs_.Get(index);
}
inline const ::itemAttrInfo& EquipInfo::attrs(int index) const {
  // @@protoc_insertion_point(field_get:EquipInfo.attrs)
  return _internal_attrs(index);
}
inline ::itemAttrInfo* EquipInfo::_internal_add_attrs() {
  return attrs_.Add();
}
inline ::itemAttrInfo* EquipInfo::add_attrs() {
  ::itemAttrInfo* _add = _internal_add_attrs();
  // @@protoc_insertion_point(field_add:EquipInfo.attrs)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::itemAttrInfo >&
EquipInfo::attrs() const {
  // @@protoc_insertion_point(field_list:EquipInfo.attrs)
  return attrs_;
}

// int32 quality = 4;
inline void EquipInfo::clear_quality() {
  quality_ = 0;
}
inline int32_t EquipInfo::_internal_quality() const {
  return quality_;
}
inline int32_t EquipInfo::quality() const {
  // @@protoc_insertion_point(field_get:EquipInfo.quality)
  return _internal_quality();
}
inline void EquipInfo::_internal_set_quality(int32_t value) {
  
  quality_ = value;
}
inline void EquipInfo::set_quality(int32_t value) {
  _internal_set_quality(value);
  // @@protoc_insertion_point(field_set:EquipInfo.quality)
}

// int32 isLock = 5;
inline void EquipInfo::clear_islock() {
  islock_ = 0;
}
inline int32_t EquipInfo::_internal_islock() const {
  return islock_;
}
inline int32_t EquipInfo::islock() const {
  // @@protoc_insertion_point(field_get:EquipInfo.isLock)
  return _internal_islock();
}
inline void EquipInfo::_internal_set_islock(int32_t value) {
  
  islock_ = value;
}
inline void EquipInfo::set_islock(int32_t value) {
  _internal_set_islock(value);
  // @@protoc_insertion_point(field_set:EquipInfo.isLock)
}

// string owner = 6;
inline void EquipInfo::clear_owner() {
  owner_.ClearToEmpty();
}
inline const std::string& EquipInfo::owner() const {
  // @@protoc_insertion_point(field_get:EquipInfo.owner)
  return _internal_owner();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void EquipInfo::set_owner(ArgT0&& arg0, ArgT... args) {
 
 owner_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:EquipInfo.owner)
}
inline std::string* EquipInfo::mutable_owner() {
  std::string* _s = _internal_mutable_owner();
  // @@protoc_insertion_point(field_mutable:EquipInfo.owner)
  return _s;
}
inline const std::string& EquipInfo::_internal_owner() const {
  return owner_.Get();
}
inline void EquipInfo::_internal_set_owner(const std::string& value) {
  
  owner_.Set(value, GetArenaForAllocation());
}
inline std::string* EquipInfo::_internal_mutable_owner() {
  
  return owner_.Mutable(GetArenaForAllocation());
}
inline std::string* EquipInfo::release_owner() {
  // @@protoc_insertion_point(field_release:EquipInfo.owner)
  return owner_.Release();
}
inline void EquipInfo::set_allocated_owner(std::string* owner) {
  if (owner != nullptr) {
    
  } else {
    
  }
  owner_.SetAllocated(owner, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (owner_.IsDefault()) {
    owner_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:EquipInfo.owner)
}

// int32 ownerType = 7;
inline void EquipInfo::clear_ownertype() {
  ownertype_ = 0;
}
inline int32_t EquipInfo::_internal_ownertype() const {
  return ownertype_;
}
inline int32_t EquipInfo::ownertype() const {
  // @@protoc_insertion_point(field_get:EquipInfo.ownerType)
  return _internal_ownertype();
}
inline void EquipInfo::_internal_set_ownertype(int32_t value) {
  
  ownertype_ = value;
}
inline void EquipInfo::set_ownertype(int32_t value) {
  _internal_set_ownertype(value);
  // @@protoc_insertion_point(field_set:EquipInfo.ownerType)
}

// int32 idx = 8;
inline void EquipInfo::clear_idx() {
  idx_ = 0;
}
inline int32_t EquipInfo::_internal_idx() const {
  return idx_;
}
inline int32_t EquipInfo::idx() const {
  // @@protoc_insertion_point(field_get:EquipInfo.idx)
  return _internal_idx();
}
inline void EquipInfo::_internal_set_idx(int32_t value) {
  
  idx_ = value;
}
inline void EquipInfo::set_idx(int32_t value) {
  _internal_set_idx(value);
  // @@protoc_insertion_point(field_set:EquipInfo.idx)
}

// -------------------------------------------------------------------

// ItemInfo

// int32 id = 1;
inline void ItemInfo::clear_id() {
  id_ = 0;
}
inline int32_t ItemInfo::_internal_id() const {
  return id_;
}
inline int32_t ItemInfo::id() const {
  // @@protoc_insertion_point(field_get:ItemInfo.id)
  return _internal_id();
}
inline void ItemInfo::_internal_set_id(int32_t value) {
  
  id_ = value;
}
inline void ItemInfo::set_id(int32_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:ItemInfo.id)
}

// uint64 count = 2;
inline void ItemInfo::clear_count() {
  count_ = uint64_t{0u};
}
inline uint64_t ItemInfo::_internal_count() const {
  return count_;
}
inline uint64_t ItemInfo::count() const {
  // @@protoc_insertion_point(field_get:ItemInfo.count)
  return _internal_count();
}
inline void ItemInfo::_internal_set_count(uint64_t value) {
  
  count_ = value;
}
inline void ItemInfo::set_count(uint64_t value) {
  _internal_set_count(value);
  // @@protoc_insertion_point(field_set:ItemInfo.count)
}

// int32 type = 3;
inline void ItemInfo::clear_type() {
  type_ = 0;
}
inline int32_t ItemInfo::_internal_type() const {
  return type_;
}
inline int32_t ItemInfo::type() const {
  // @@protoc_insertion_point(field_get:ItemInfo.type)
  return _internal_type();
}
inline void ItemInfo::_internal_set_type(int32_t value) {
  
  type_ = value;
}
inline void ItemInfo::set_type(int32_t value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:ItemInfo.type)
}

// int32 opt = 4;
inline void ItemInfo::clear_opt() {
  opt_ = 0;
}
inline int32_t ItemInfo::_internal_opt() const {
  return opt_;
}
inline int32_t ItemInfo::opt() const {
  // @@protoc_insertion_point(field_get:ItemInfo.opt)
  return _internal_opt();
}
inline void ItemInfo::_internal_set_opt(int32_t value) {
  
  opt_ = value;
}
inline void ItemInfo::set_opt(int32_t value) {
  _internal_set_opt(value);
  // @@protoc_insertion_point(field_set:ItemInfo.opt)
}

// -------------------------------------------------------------------

// BagInfo

// string uid = 1;
inline void BagInfo::clear_uid() {
  uid_.ClearToEmpty();
}
inline const std::string& BagInfo::uid() const {
  // @@protoc_insertion_point(field_get:BagInfo.uid)
  return _internal_uid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BagInfo::set_uid(ArgT0&& arg0, ArgT... args) {
 
 uid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:BagInfo.uid)
}
inline std::string* BagInfo::mutable_uid() {
  std::string* _s = _internal_mutable_uid();
  // @@protoc_insertion_point(field_mutable:BagInfo.uid)
  return _s;
}
inline const std::string& BagInfo::_internal_uid() const {
  return uid_.Get();
}
inline void BagInfo::_internal_set_uid(const std::string& value) {
  
  uid_.Set(value, GetArenaForAllocation());
}
inline std::string* BagInfo::_internal_mutable_uid() {
  
  return uid_.Mutable(GetArenaForAllocation());
}
inline std::string* BagInfo::release_uid() {
  // @@protoc_insertion_point(field_release:BagInfo.uid)
  return uid_.Release();
}
inline void BagInfo::set_allocated_uid(std::string* uid) {
  if (uid != nullptr) {
    
  } else {
    
  }
  uid_.SetAllocated(uid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (uid_.IsDefault()) {
    uid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:BagInfo.uid)
}

// .ItemInfo item = 2;
inline bool BagInfo::_internal_has_item() const {
  return this != internal_default_instance() && item_ != nullptr;
}
inline bool BagInfo::has_item() const {
  return _internal_has_item();
}
inline void BagInfo::clear_item() {
  if (GetArenaForAllocation() == nullptr && item_ != nullptr) {
    delete item_;
  }
  item_ = nullptr;
}
inline const ::ItemInfo& BagInfo::_internal_item() const {
  const ::ItemInfo* p = item_;
  return p != nullptr ? *p : reinterpret_cast<const ::ItemInfo&>(
      ::_ItemInfo_default_instance_);
}
inline const ::ItemInfo& BagInfo::item() const {
  // @@protoc_insertion_point(field_get:BagInfo.item)
  return _internal_item();
}
inline void BagInfo::unsafe_arena_set_allocated_item(
    ::ItemInfo* item) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(item_);
  }
  item_ = item;
  if (item) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:BagInfo.item)
}
inline ::ItemInfo* BagInfo::release_item() {
  
  ::ItemInfo* temp = item_;
  item_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ItemInfo* BagInfo::unsafe_arena_release_item() {
  // @@protoc_insertion_point(field_release:BagInfo.item)
  
  ::ItemInfo* temp = item_;
  item_ = nullptr;
  return temp;
}
inline ::ItemInfo* BagInfo::_internal_mutable_item() {
  
  if (item_ == nullptr) {
    auto* p = CreateMaybeMessage<::ItemInfo>(GetArenaForAllocation());
    item_ = p;
  }
  return item_;
}
inline ::ItemInfo* BagInfo::mutable_item() {
  ::ItemInfo* _msg = _internal_mutable_item();
  // @@protoc_insertion_point(field_mutable:BagInfo.item)
  return _msg;
}
inline void BagInfo::set_allocated_item(::ItemInfo* item) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete item_;
  }
  if (item) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(item);
    if (message_arena != submessage_arena) {
      item = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, item, submessage_arena);
    }
    
  } else {
    
  }
  item_ = item;
  // @@protoc_insertion_point(field_set_allocated:BagInfo.item)
}

// .EquipInfo equip = 3;
inline bool BagInfo::_internal_has_equip() const {
  return this != internal_default_instance() && equip_ != nullptr;
}
inline bool BagInfo::has_equip() const {
  return _internal_has_equip();
}
inline void BagInfo::clear_equip() {
  if (GetArenaForAllocation() == nullptr && equip_ != nullptr) {
    delete equip_;
  }
  equip_ = nullptr;
}
inline const ::EquipInfo& BagInfo::_internal_equip() const {
  const ::EquipInfo* p = equip_;
  return p != nullptr ? *p : reinterpret_cast<const ::EquipInfo&>(
      ::_EquipInfo_default_instance_);
}
inline const ::EquipInfo& BagInfo::equip() const {
  // @@protoc_insertion_point(field_get:BagInfo.equip)
  return _internal_equip();
}
inline void BagInfo::unsafe_arena_set_allocated_equip(
    ::EquipInfo* equip) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(equip_);
  }
  equip_ = equip;
  if (equip) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:BagInfo.equip)
}
inline ::EquipInfo* BagInfo::release_equip() {
  
  ::EquipInfo* temp = equip_;
  equip_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::EquipInfo* BagInfo::unsafe_arena_release_equip() {
  // @@protoc_insertion_point(field_release:BagInfo.equip)
  
  ::EquipInfo* temp = equip_;
  equip_ = nullptr;
  return temp;
}
inline ::EquipInfo* BagInfo::_internal_mutable_equip() {
  
  if (equip_ == nullptr) {
    auto* p = CreateMaybeMessage<::EquipInfo>(GetArenaForAllocation());
    equip_ = p;
  }
  return equip_;
}
inline ::EquipInfo* BagInfo::mutable_equip() {
  ::EquipInfo* _msg = _internal_mutable_equip();
  // @@protoc_insertion_point(field_mutable:BagInfo.equip)
  return _msg;
}
inline void BagInfo::set_allocated_equip(::EquipInfo* equip) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete equip_;
  }
  if (equip) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(equip);
    if (message_arena != submessage_arena) {
      equip = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, equip, submessage_arena);
    }
    
  } else {
    
  }
  equip_ = equip;
  // @@protoc_insertion_point(field_set_allocated:BagInfo.equip)
}

// -------------------------------------------------------------------

// ReqAllBagInfo

// -------------------------------------------------------------------

// ResAllBagInfo

// repeated .BagInfo bag = 1;
inline int ResAllBagInfo::_internal_bag_size() const {
  return bag_.size();
}
inline int ResAllBagInfo::bag_size() const {
  return _internal_bag_size();
}
inline void ResAllBagInfo::clear_bag() {
  bag_.Clear();
}
inline ::BagInfo* ResAllBagInfo::mutable_bag(int index) {
  // @@protoc_insertion_point(field_mutable:ResAllBagInfo.bag)
  return bag_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::BagInfo >*
ResAllBagInfo::mutable_bag() {
  // @@protoc_insertion_point(field_mutable_list:ResAllBagInfo.bag)
  return &bag_;
}
inline const ::BagInfo& ResAllBagInfo::_internal_bag(int index) const {
  return bag_.Get(index);
}
inline const ::BagInfo& ResAllBagInfo::bag(int index) const {
  // @@protoc_insertion_point(field_get:ResAllBagInfo.bag)
  return _internal_bag(index);
}
inline ::BagInfo* ResAllBagInfo::_internal_add_bag() {
  return bag_.Add();
}
inline ::BagInfo* ResAllBagInfo::add_bag() {
  ::BagInfo* _add = _internal_add_bag();
  // @@protoc_insertion_point(field_add:ResAllBagInfo.bag)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::BagInfo >&
ResAllBagInfo::bag() const {
  // @@protoc_insertion_point(field_list:ResAllBagInfo.bag)
  return bag_;
}

// -------------------------------------------------------------------

// NotifyBagInfoSignUp

// repeated .BagInfo bag = 1;
inline int NotifyBagInfoSignUp::_internal_bag_size() const {
  return bag_.size();
}
inline int NotifyBagInfoSignUp::bag_size() const {
  return _internal_bag_size();
}
inline void NotifyBagInfoSignUp::clear_bag() {
  bag_.Clear();
}
inline ::BagInfo* NotifyBagInfoSignUp::mutable_bag(int index) {
  // @@protoc_insertion_point(field_mutable:NotifyBagInfoSignUp.bag)
  return bag_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::BagInfo >*
NotifyBagInfoSignUp::mutable_bag() {
  // @@protoc_insertion_point(field_mutable_list:NotifyBagInfoSignUp.bag)
  return &bag_;
}
inline const ::BagInfo& NotifyBagInfoSignUp::_internal_bag(int index) const {
  return bag_.Get(index);
}
inline const ::BagInfo& NotifyBagInfoSignUp::bag(int index) const {
  // @@protoc_insertion_point(field_get:NotifyBagInfoSignUp.bag)
  return _internal_bag(index);
}
inline ::BagInfo* NotifyBagInfoSignUp::_internal_add_bag() {
  return bag_.Add();
}
inline ::BagInfo* NotifyBagInfoSignUp::add_bag() {
  ::BagInfo* _add = _internal_add_bag();
  // @@protoc_insertion_point(field_add:NotifyBagInfoSignUp.bag)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::BagInfo >&
NotifyBagInfoSignUp::bag() const {
  // @@protoc_insertion_point(field_list:NotifyBagInfoSignUp.bag)
  return bag_;
}

// -------------------------------------------------------------------

// NotifyDeleteItem

// repeated string bag = 1;
inline int NotifyDeleteItem::_internal_bag_size() const {
  return bag_.size();
}
inline int NotifyDeleteItem::bag_size() const {
  return _internal_bag_size();
}
inline void NotifyDeleteItem::clear_bag() {
  bag_.Clear();
}
inline std::string* NotifyDeleteItem::add_bag() {
  std::string* _s = _internal_add_bag();
  // @@protoc_insertion_point(field_add_mutable:NotifyDeleteItem.bag)
  return _s;
}
inline const std::string& NotifyDeleteItem::_internal_bag(int index) const {
  return bag_.Get(index);
}
inline const std::string& NotifyDeleteItem::bag(int index) const {
  // @@protoc_insertion_point(field_get:NotifyDeleteItem.bag)
  return _internal_bag(index);
}
inline std::string* NotifyDeleteItem::mutable_bag(int index) {
  // @@protoc_insertion_point(field_mutable:NotifyDeleteItem.bag)
  return bag_.Mutable(index);
}
inline void NotifyDeleteItem::set_bag(int index, const std::string& value) {
  bag_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:NotifyDeleteItem.bag)
}
inline void NotifyDeleteItem::set_bag(int index, std::string&& value) {
  bag_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:NotifyDeleteItem.bag)
}
inline void NotifyDeleteItem::set_bag(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  bag_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:NotifyDeleteItem.bag)
}
inline void NotifyDeleteItem::set_bag(int index, const char* value, size_t size) {
  bag_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:NotifyDeleteItem.bag)
}
inline std::string* NotifyDeleteItem::_internal_add_bag() {
  return bag_.Add();
}
inline void NotifyDeleteItem::add_bag(const std::string& value) {
  bag_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:NotifyDeleteItem.bag)
}
inline void NotifyDeleteItem::add_bag(std::string&& value) {
  bag_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:NotifyDeleteItem.bag)
}
inline void NotifyDeleteItem::add_bag(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  bag_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:NotifyDeleteItem.bag)
}
inline void NotifyDeleteItem::add_bag(const char* value, size_t size) {
  bag_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:NotifyDeleteItem.bag)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
NotifyDeleteItem::bag() const {
  // @@protoc_insertion_point(field_list:NotifyDeleteItem.bag)
  return bag_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
NotifyDeleteItem::mutable_bag() {
  // @@protoc_insertion_point(field_mutable_list:NotifyDeleteItem.bag)
  return &bag_;
}

// -------------------------------------------------------------------

// CurrencyInfo

// int32 id = 1;
inline void CurrencyInfo::clear_id() {
  id_ = 0;
}
inline int32_t CurrencyInfo::_internal_id() const {
  return id_;
}
inline int32_t CurrencyInfo::id() const {
  // @@protoc_insertion_point(field_get:CurrencyInfo.id)
  return _internal_id();
}
inline void CurrencyInfo::_internal_set_id(int32_t value) {
  
  id_ = value;
}
inline void CurrencyInfo::set_id(int32_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:CurrencyInfo.id)
}

// uint64 value = 2;
inline void CurrencyInfo::clear_value() {
  value_ = uint64_t{0u};
}
inline uint64_t CurrencyInfo::_internal_value() const {
  return value_;
}
inline uint64_t CurrencyInfo::value() const {
  // @@protoc_insertion_point(field_get:CurrencyInfo.value)
  return _internal_value();
}
inline void CurrencyInfo::_internal_set_value(uint64_t value) {
  
  value_ = value;
}
inline void CurrencyInfo::set_value(uint64_t value) {
  _internal_set_value(value);
  // @@protoc_insertion_point(field_set:CurrencyInfo.value)
}

// -------------------------------------------------------------------

// ReqCurrencyInfo

// -------------------------------------------------------------------

// ResCurrencyInfo

// repeated .CurrencyInfo currency = 1;
inline int ResCurrencyInfo::_internal_currency_size() const {
  return currency_.size();
}
inline int ResCurrencyInfo::currency_size() const {
  return _internal_currency_size();
}
inline void ResCurrencyInfo::clear_currency() {
  currency_.Clear();
}
inline ::CurrencyInfo* ResCurrencyInfo::mutable_currency(int index) {
  // @@protoc_insertion_point(field_mutable:ResCurrencyInfo.currency)
  return currency_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CurrencyInfo >*
ResCurrencyInfo::mutable_currency() {
  // @@protoc_insertion_point(field_mutable_list:ResCurrencyInfo.currency)
  return &currency_;
}
inline const ::CurrencyInfo& ResCurrencyInfo::_internal_currency(int index) const {
  return currency_.Get(index);
}
inline const ::CurrencyInfo& ResCurrencyInfo::currency(int index) const {
  // @@protoc_insertion_point(field_get:ResCurrencyInfo.currency)
  return _internal_currency(index);
}
inline ::CurrencyInfo* ResCurrencyInfo::_internal_add_currency() {
  return currency_.Add();
}
inline ::CurrencyInfo* ResCurrencyInfo::add_currency() {
  ::CurrencyInfo* _add = _internal_add_currency();
  // @@protoc_insertion_point(field_add:ResCurrencyInfo.currency)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CurrencyInfo >&
ResCurrencyInfo::currency() const {
  // @@protoc_insertion_point(field_list:ResCurrencyInfo.currency)
  return currency_;
}

// -------------------------------------------------------------------

// NotifyCurrencyUpdate

// repeated .CurrencyInfo currency = 1;
inline int NotifyCurrencyUpdate::_internal_currency_size() const {
  return currency_.size();
}
inline int NotifyCurrencyUpdate::currency_size() const {
  return _internal_currency_size();
}
inline void NotifyCurrencyUpdate::clear_currency() {
  currency_.Clear();
}
inline ::CurrencyInfo* NotifyCurrencyUpdate::mutable_currency(int index) {
  // @@protoc_insertion_point(field_mutable:NotifyCurrencyUpdate.currency)
  return currency_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CurrencyInfo >*
NotifyCurrencyUpdate::mutable_currency() {
  // @@protoc_insertion_point(field_mutable_list:NotifyCurrencyUpdate.currency)
  return &currency_;
}
inline const ::CurrencyInfo& NotifyCurrencyUpdate::_internal_currency(int index) const {
  return currency_.Get(index);
}
inline const ::CurrencyInfo& NotifyCurrencyUpdate::currency(int index) const {
  // @@protoc_insertion_point(field_get:NotifyCurrencyUpdate.currency)
  return _internal_currency(index);
}
inline ::CurrencyInfo* NotifyCurrencyUpdate::_internal_add_currency() {
  return currency_.Add();
}
inline ::CurrencyInfo* NotifyCurrencyUpdate::add_currency() {
  ::CurrencyInfo* _add = _internal_add_currency();
  // @@protoc_insertion_point(field_add:NotifyCurrencyUpdate.currency)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CurrencyInfo >&
NotifyCurrencyUpdate::currency() const {
  // @@protoc_insertion_point(field_list:NotifyCurrencyUpdate.currency)
  return currency_;
}

// -------------------------------------------------------------------

// NotifyDeleteCurrency

// repeated int32 currency = 1;
inline int NotifyDeleteCurrency::_internal_currency_size() const {
  return currency_.size();
}
inline int NotifyDeleteCurrency::currency_size() const {
  return _internal_currency_size();
}
inline void NotifyDeleteCurrency::clear_currency() {
  currency_.Clear();
}
inline int32_t NotifyDeleteCurrency::_internal_currency(int index) const {
  return currency_.Get(index);
}
inline int32_t NotifyDeleteCurrency::currency(int index) const {
  // @@protoc_insertion_point(field_get:NotifyDeleteCurrency.currency)
  return _internal_currency(index);
}
inline void NotifyDeleteCurrency::set_currency(int index, int32_t value) {
  currency_.Set(index, value);
  // @@protoc_insertion_point(field_set:NotifyDeleteCurrency.currency)
}
inline void NotifyDeleteCurrency::_internal_add_currency(int32_t value) {
  currency_.Add(value);
}
inline void NotifyDeleteCurrency::add_currency(int32_t value) {
  _internal_add_currency(value);
  // @@protoc_insertion_point(field_add:NotifyDeleteCurrency.currency)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
NotifyDeleteCurrency::_internal_currency() const {
  return currency_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
NotifyDeleteCurrency::currency() const {
  // @@protoc_insertion_point(field_list:NotifyDeleteCurrency.currency)
  return _internal_currency();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
NotifyDeleteCurrency::_internal_mutable_currency() {
  return &currency_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
NotifyDeleteCurrency::mutable_currency() {
  // @@protoc_insertion_point(field_mutable_list:NotifyDeleteCurrency.currency)
  return _internal_mutable_currency();
}

// -------------------------------------------------------------------

// NotifyClientRewardTips

// repeated .ItemInfo data = 1;
inline int NotifyClientRewardTips::_internal_data_size() const {
  return data_.size();
}
inline int NotifyClientRewardTips::data_size() const {
  return _internal_data_size();
}
inline void NotifyClientRewardTips::clear_data() {
  data_.Clear();
}
inline ::ItemInfo* NotifyClientRewardTips::mutable_data(int index) {
  // @@protoc_insertion_point(field_mutable:NotifyClientRewardTips.data)
  return data_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ItemInfo >*
NotifyClientRewardTips::mutable_data() {
  // @@protoc_insertion_point(field_mutable_list:NotifyClientRewardTips.data)
  return &data_;
}
inline const ::ItemInfo& NotifyClientRewardTips::_internal_data(int index) const {
  return data_.Get(index);
}
inline const ::ItemInfo& NotifyClientRewardTips::data(int index) const {
  // @@protoc_insertion_point(field_get:NotifyClientRewardTips.data)
  return _internal_data(index);
}
inline ::ItemInfo* NotifyClientRewardTips::_internal_add_data() {
  return data_.Add();
}
inline ::ItemInfo* NotifyClientRewardTips::add_data() {
  ::ItemInfo* _add = _internal_add_data();
  // @@protoc_insertion_point(field_add:NotifyClientRewardTips.data)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ItemInfo >&
NotifyClientRewardTips::data() const {
  // @@protoc_insertion_point(field_list:NotifyClientRewardTips.data)
  return data_;
}

// uint32 rdType = 2;
inline void NotifyClientRewardTips::clear_rdtype() {
  rdtype_ = 0u;
}
inline uint32_t NotifyClientRewardTips::_internal_rdtype() const {
  return rdtype_;
}
inline uint32_t NotifyClientRewardTips::rdtype() const {
  // @@protoc_insertion_point(field_get:NotifyClientRewardTips.rdType)
  return _internal_rdtype();
}
inline void NotifyClientRewardTips::_internal_set_rdtype(uint32_t value) {
  
  rdtype_ = value;
}
inline void NotifyClientRewardTips::set_rdtype(uint32_t value) {
  _internal_set_rdtype(value);
  // @@protoc_insertion_point(field_set:NotifyClientRewardTips.rdType)
}

// uint32 param1 = 3;
inline void NotifyClientRewardTips::clear_param1() {
  param1_ = 0u;
}
inline uint32_t NotifyClientRewardTips::_internal_param1() const {
  return param1_;
}
inline uint32_t NotifyClientRewardTips::param1() const {
  // @@protoc_insertion_point(field_get:NotifyClientRewardTips.param1)
  return _internal_param1();
}
inline void NotifyClientRewardTips::_internal_set_param1(uint32_t value) {
  
  param1_ = value;
}
inline void NotifyClientRewardTips::set_param1(uint32_t value) {
  _internal_set_param1(value);
  // @@protoc_insertion_point(field_set:NotifyClientRewardTips.param1)
}

// uint32 param2 = 4;
inline void NotifyClientRewardTips::clear_param2() {
  param2_ = 0u;
}
inline uint32_t NotifyClientRewardTips::_internal_param2() const {
  return param2_;
}
inline uint32_t NotifyClientRewardTips::param2() const {
  // @@protoc_insertion_point(field_get:NotifyClientRewardTips.param2)
  return _internal_param2();
}
inline void NotifyClientRewardTips::_internal_set_param2(uint32_t value) {
  
  param2_ = value;
}
inline void NotifyClientRewardTips::set_param2(uint32_t value) {
  _internal_set_param2(value);
  // @@protoc_insertion_point(field_set:NotifyClientRewardTips.param2)
}

// sint32 param3 = 5;
inline void NotifyClientRewardTips::clear_param3() {
  param3_ = 0;
}
inline int32_t NotifyClientRewardTips::_internal_param3() const {
  return param3_;
}
inline int32_t NotifyClientRewardTips::param3() const {
  // @@protoc_insertion_point(field_get:NotifyClientRewardTips.param3)
  return _internal_param3();
}
inline void NotifyClientRewardTips::_internal_set_param3(int32_t value) {
  
  param3_ = value;
}
inline void NotifyClientRewardTips::set_param3(int32_t value) {
  _internal_set_param3(value);
  // @@protoc_insertion_point(field_set:NotifyClientRewardTips.param3)
}

// uint64 param4 = 6;
inline void NotifyClientRewardTips::clear_param4() {
  param4_ = uint64_t{0u};
}
inline uint64_t NotifyClientRewardTips::_internal_param4() const {
  return param4_;
}
inline uint64_t NotifyClientRewardTips::param4() const {
  // @@protoc_insertion_point(field_get:NotifyClientRewardTips.param4)
  return _internal_param4();
}
inline void NotifyClientRewardTips::_internal_set_param4(uint64_t value) {
  
  param4_ = value;
}
inline void NotifyClientRewardTips::set_param4(uint64_t value) {
  _internal_set_param4(value);
  // @@protoc_insertion_point(field_set:NotifyClientRewardTips.param4)
}

// uint64 param5 = 7;
inline void NotifyClientRewardTips::clear_param5() {
  param5_ = uint64_t{0u};
}
inline uint64_t NotifyClientRewardTips::_internal_param5() const {
  return param5_;
}
inline uint64_t NotifyClientRewardTips::param5() const {
  // @@protoc_insertion_point(field_get:NotifyClientRewardTips.param5)
  return _internal_param5();
}
inline void NotifyClientRewardTips::_internal_set_param5(uint64_t value) {
  
  param5_ = value;
}
inline void NotifyClientRewardTips::set_param5(uint64_t value) {
  _internal_set_param5(value);
  // @@protoc_insertion_point(field_set:NotifyClientRewardTips.param5)
}

// sint64 param6 = 8;
inline void NotifyClientRewardTips::clear_param6() {
  param6_ = int64_t{0};
}
inline int64_t NotifyClientRewardTips::_internal_param6() const {
  return param6_;
}
inline int64_t NotifyClientRewardTips::param6() const {
  // @@protoc_insertion_point(field_get:NotifyClientRewardTips.param6)
  return _internal_param6();
}
inline void NotifyClientRewardTips::_internal_set_param6(int64_t value) {
  
  param6_ = value;
}
inline void NotifyClientRewardTips::set_param6(int64_t value) {
  _internal_set_param6(value);
  // @@protoc_insertion_point(field_set:NotifyClientRewardTips.param6)
}

// -------------------------------------------------------------------

// ReqBagItemLock

// string uid = 1;
inline void ReqBagItemLock::clear_uid() {
  uid_.ClearToEmpty();
}
inline const std::string& ReqBagItemLock::uid() const {
  // @@protoc_insertion_point(field_get:ReqBagItemLock.uid)
  return _internal_uid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ReqBagItemLock::set_uid(ArgT0&& arg0, ArgT... args) {
 
 uid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ReqBagItemLock.uid)
}
inline std::string* ReqBagItemLock::mutable_uid() {
  std::string* _s = _internal_mutable_uid();
  // @@protoc_insertion_point(field_mutable:ReqBagItemLock.uid)
  return _s;
}
inline const std::string& ReqBagItemLock::_internal_uid() const {
  return uid_.Get();
}
inline void ReqBagItemLock::_internal_set_uid(const std::string& value) {
  
  uid_.Set(value, GetArenaForAllocation());
}
inline std::string* ReqBagItemLock::_internal_mutable_uid() {
  
  return uid_.Mutable(GetArenaForAllocation());
}
inline std::string* ReqBagItemLock::release_uid() {
  // @@protoc_insertion_point(field_release:ReqBagItemLock.uid)
  return uid_.Release();
}
inline void ReqBagItemLock::set_allocated_uid(std::string* uid) {
  if (uid != nullptr) {
    
  } else {
    
  }
  uid_.SetAllocated(uid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (uid_.IsDefault()) {
    uid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ReqBagItemLock.uid)
}

// int32 isLock = 2;
inline void ReqBagItemLock::clear_islock() {
  islock_ = 0;
}
inline int32_t ReqBagItemLock::_internal_islock() const {
  return islock_;
}
inline int32_t ReqBagItemLock::islock() const {
  // @@protoc_insertion_point(field_get:ReqBagItemLock.isLock)
  return _internal_islock();
}
inline void ReqBagItemLock::_internal_set_islock(int32_t value) {
  
  islock_ = value;
}
inline void ReqBagItemLock::set_islock(int32_t value) {
  _internal_set_islock(value);
  // @@protoc_insertion_point(field_set:ReqBagItemLock.isLock)
}

// -------------------------------------------------------------------

// ResBagItemLock

// string uid = 1;
inline void ResBagItemLock::clear_uid() {
  uid_.ClearToEmpty();
}
inline const std::string& ResBagItemLock::uid() const {
  // @@protoc_insertion_point(field_get:ResBagItemLock.uid)
  return _internal_uid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ResBagItemLock::set_uid(ArgT0&& arg0, ArgT... args) {
 
 uid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ResBagItemLock.uid)
}
inline std::string* ResBagItemLock::mutable_uid() {
  std::string* _s = _internal_mutable_uid();
  // @@protoc_insertion_point(field_mutable:ResBagItemLock.uid)
  return _s;
}
inline const std::string& ResBagItemLock::_internal_uid() const {
  return uid_.Get();
}
inline void ResBagItemLock::_internal_set_uid(const std::string& value) {
  
  uid_.Set(value, GetArenaForAllocation());
}
inline std::string* ResBagItemLock::_internal_mutable_uid() {
  
  return uid_.Mutable(GetArenaForAllocation());
}
inline std::string* ResBagItemLock::release_uid() {
  // @@protoc_insertion_point(field_release:ResBagItemLock.uid)
  return uid_.Release();
}
inline void ResBagItemLock::set_allocated_uid(std::string* uid) {
  if (uid != nullptr) {
    
  } else {
    
  }
  uid_.SetAllocated(uid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (uid_.IsDefault()) {
    uid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ResBagItemLock.uid)
}

// int32 isLock = 2;
inline void ResBagItemLock::clear_islock() {
  islock_ = 0;
}
inline int32_t ResBagItemLock::_internal_islock() const {
  return islock_;
}
inline int32_t ResBagItemLock::islock() const {
  // @@protoc_insertion_point(field_get:ResBagItemLock.isLock)
  return _internal_islock();
}
inline void ResBagItemLock::_internal_set_islock(int32_t value) {
  
  islock_ = value;
}
inline void ResBagItemLock::set_islock(int32_t value) {
  _internal_set_islock(value);
  // @@protoc_insertion_point(field_set:ResBagItemLock.isLock)
}

// -------------------------------------------------------------------

// ReqBagDelItem

// string uid = 1;
inline void ReqBagDelItem::clear_uid() {
  uid_.ClearToEmpty();
}
inline const std::string& ReqBagDelItem::uid() const {
  // @@protoc_insertion_point(field_get:ReqBagDelItem.uid)
  return _internal_uid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ReqBagDelItem::set_uid(ArgT0&& arg0, ArgT... args) {
 
 uid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ReqBagDelItem.uid)
}
inline std::string* ReqBagDelItem::mutable_uid() {
  std::string* _s = _internal_mutable_uid();
  // @@protoc_insertion_point(field_mutable:ReqBagDelItem.uid)
  return _s;
}
inline const std::string& ReqBagDelItem::_internal_uid() const {
  return uid_.Get();
}
inline void ReqBagDelItem::_internal_set_uid(const std::string& value) {
  
  uid_.Set(value, GetArenaForAllocation());
}
inline std::string* ReqBagDelItem::_internal_mutable_uid() {
  
  return uid_.Mutable(GetArenaForAllocation());
}
inline std::string* ReqBagDelItem::release_uid() {
  // @@protoc_insertion_point(field_release:ReqBagDelItem.uid)
  return uid_.Release();
}
inline void ReqBagDelItem::set_allocated_uid(std::string* uid) {
  if (uid != nullptr) {
    
  } else {
    
  }
  uid_.SetAllocated(uid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (uid_.IsDefault()) {
    uid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ReqBagDelItem.uid)
}

// -------------------------------------------------------------------

// ReqEquipLevelUp

// string uid = 1;
inline void ReqEquipLevelUp::clear_uid() {
  uid_.ClearToEmpty();
}
inline const std::string& ReqEquipLevelUp::uid() const {
  // @@protoc_insertion_point(field_get:ReqEquipLevelUp.uid)
  return _internal_uid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ReqEquipLevelUp::set_uid(ArgT0&& arg0, ArgT... args) {
 
 uid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ReqEquipLevelUp.uid)
}
inline std::string* ReqEquipLevelUp::mutable_uid() {
  std::string* _s = _internal_mutable_uid();
  // @@protoc_insertion_point(field_mutable:ReqEquipLevelUp.uid)
  return _s;
}
inline const std::string& ReqEquipLevelUp::_internal_uid() const {
  return uid_.Get();
}
inline void ReqEquipLevelUp::_internal_set_uid(const std::string& value) {
  
  uid_.Set(value, GetArenaForAllocation());
}
inline std::string* ReqEquipLevelUp::_internal_mutable_uid() {
  
  return uid_.Mutable(GetArenaForAllocation());
}
inline std::string* ReqEquipLevelUp::release_uid() {
  // @@protoc_insertion_point(field_release:ReqEquipLevelUp.uid)
  return uid_.Release();
}
inline void ReqEquipLevelUp::set_allocated_uid(std::string* uid) {
  if (uid != nullptr) {
    
  } else {
    
  }
  uid_.SetAllocated(uid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (uid_.IsDefault()) {
    uid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ReqEquipLevelUp.uid)
}

// repeated .ItemInfo itemlist = 2;
inline int ReqEquipLevelUp::_internal_itemlist_size() const {
  return itemlist_.size();
}
inline int ReqEquipLevelUp::itemlist_size() const {
  return _internal_itemlist_size();
}
inline void ReqEquipLevelUp::clear_itemlist() {
  itemlist_.Clear();
}
inline ::ItemInfo* ReqEquipLevelUp::mutable_itemlist(int index) {
  // @@protoc_insertion_point(field_mutable:ReqEquipLevelUp.itemlist)
  return itemlist_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ItemInfo >*
ReqEquipLevelUp::mutable_itemlist() {
  // @@protoc_insertion_point(field_mutable_list:ReqEquipLevelUp.itemlist)
  return &itemlist_;
}
inline const ::ItemInfo& ReqEquipLevelUp::_internal_itemlist(int index) const {
  return itemlist_.Get(index);
}
inline const ::ItemInfo& ReqEquipLevelUp::itemlist(int index) const {
  // @@protoc_insertion_point(field_get:ReqEquipLevelUp.itemlist)
  return _internal_itemlist(index);
}
inline ::ItemInfo* ReqEquipLevelUp::_internal_add_itemlist() {
  return itemlist_.Add();
}
inline ::ItemInfo* ReqEquipLevelUp::add_itemlist() {
  ::ItemInfo* _add = _internal_add_itemlist();
  // @@protoc_insertion_point(field_add:ReqEquipLevelUp.itemlist)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ItemInfo >&
ReqEquipLevelUp::itemlist() const {
  // @@protoc_insertion_point(field_list:ReqEquipLevelUp.itemlist)
  return itemlist_;
}

// repeated string uids = 3;
inline int ReqEquipLevelUp::_internal_uids_size() const {
  return uids_.size();
}
inline int ReqEquipLevelUp::uids_size() const {
  return _internal_uids_size();
}
inline void ReqEquipLevelUp::clear_uids() {
  uids_.Clear();
}
inline std::string* ReqEquipLevelUp::add_uids() {
  std::string* _s = _internal_add_uids();
  // @@protoc_insertion_point(field_add_mutable:ReqEquipLevelUp.uids)
  return _s;
}
inline const std::string& ReqEquipLevelUp::_internal_uids(int index) const {
  return uids_.Get(index);
}
inline const std::string& ReqEquipLevelUp::uids(int index) const {
  // @@protoc_insertion_point(field_get:ReqEquipLevelUp.uids)
  return _internal_uids(index);
}
inline std::string* ReqEquipLevelUp::mutable_uids(int index) {
  // @@protoc_insertion_point(field_mutable:ReqEquipLevelUp.uids)
  return uids_.Mutable(index);
}
inline void ReqEquipLevelUp::set_uids(int index, const std::string& value) {
  uids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:ReqEquipLevelUp.uids)
}
inline void ReqEquipLevelUp::set_uids(int index, std::string&& value) {
  uids_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:ReqEquipLevelUp.uids)
}
inline void ReqEquipLevelUp::set_uids(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  uids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:ReqEquipLevelUp.uids)
}
inline void ReqEquipLevelUp::set_uids(int index, const char* value, size_t size) {
  uids_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ReqEquipLevelUp.uids)
}
inline std::string* ReqEquipLevelUp::_internal_add_uids() {
  return uids_.Add();
}
inline void ReqEquipLevelUp::add_uids(const std::string& value) {
  uids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:ReqEquipLevelUp.uids)
}
inline void ReqEquipLevelUp::add_uids(std::string&& value) {
  uids_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:ReqEquipLevelUp.uids)
}
inline void ReqEquipLevelUp::add_uids(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  uids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:ReqEquipLevelUp.uids)
}
inline void ReqEquipLevelUp::add_uids(const char* value, size_t size) {
  uids_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:ReqEquipLevelUp.uids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
ReqEquipLevelUp::uids() const {
  // @@protoc_insertion_point(field_list:ReqEquipLevelUp.uids)
  return uids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
ReqEquipLevelUp::mutable_uids() {
  // @@protoc_insertion_point(field_mutable_list:ReqEquipLevelUp.uids)
  return &uids_;
}

// int32 heroId = 4;
inline void ReqEquipLevelUp::clear_heroid() {
  heroid_ = 0;
}
inline int32_t ReqEquipLevelUp::_internal_heroid() const {
  return heroid_;
}
inline int32_t ReqEquipLevelUp::heroid() const {
  // @@protoc_insertion_point(field_get:ReqEquipLevelUp.heroId)
  return _internal_heroid();
}
inline void ReqEquipLevelUp::_internal_set_heroid(int32_t value) {
  
  heroid_ = value;
}
inline void ReqEquipLevelUp::set_heroid(int32_t value) {
  _internal_set_heroid(value);
  // @@protoc_insertion_point(field_set:ReqEquipLevelUp.heroId)
}

// -------------------------------------------------------------------

// ResEquipLevelUp

// string guid = 1;
inline void ResEquipLevelUp::clear_guid() {
  guid_.ClearToEmpty();
}
inline const std::string& ResEquipLevelUp::guid() const {
  // @@protoc_insertion_point(field_get:ResEquipLevelUp.guid)
  return _internal_guid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ResEquipLevelUp::set_guid(ArgT0&& arg0, ArgT... args) {
 
 guid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ResEquipLevelUp.guid)
}
inline std::string* ResEquipLevelUp::mutable_guid() {
  std::string* _s = _internal_mutable_guid();
  // @@protoc_insertion_point(field_mutable:ResEquipLevelUp.guid)
  return _s;
}
inline const std::string& ResEquipLevelUp::_internal_guid() const {
  return guid_.Get();
}
inline void ResEquipLevelUp::_internal_set_guid(const std::string& value) {
  
  guid_.Set(value, GetArenaForAllocation());
}
inline std::string* ResEquipLevelUp::_internal_mutable_guid() {
  
  return guid_.Mutable(GetArenaForAllocation());
}
inline std::string* ResEquipLevelUp::release_guid() {
  // @@protoc_insertion_point(field_release:ResEquipLevelUp.guid)
  return guid_.Release();
}
inline void ResEquipLevelUp::set_allocated_guid(std::string* guid) {
  if (guid != nullptr) {
    
  } else {
    
  }
  guid_.SetAllocated(guid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (guid_.IsDefault()) {
    guid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ResEquipLevelUp.guid)
}

// int32 level = 2;
inline void ResEquipLevelUp::clear_level() {
  level_ = 0;
}
inline int32_t ResEquipLevelUp::_internal_level() const {
  return level_;
}
inline int32_t ResEquipLevelUp::level() const {
  // @@protoc_insertion_point(field_get:ResEquipLevelUp.level)
  return _internal_level();
}
inline void ResEquipLevelUp::_internal_set_level(int32_t value) {
  
  level_ = value;
}
inline void ResEquipLevelUp::set_level(int32_t value) {
  _internal_set_level(value);
  // @@protoc_insertion_point(field_set:ResEquipLevelUp.level)
}

// int32 exp = 3;
inline void ResEquipLevelUp::clear_exp() {
  exp_ = 0;
}
inline int32_t ResEquipLevelUp::_internal_exp() const {
  return exp_;
}
inline int32_t ResEquipLevelUp::exp() const {
  // @@protoc_insertion_point(field_get:ResEquipLevelUp.exp)
  return _internal_exp();
}
inline void ResEquipLevelUp::_internal_set_exp(int32_t value) {
  
  exp_ = value;
}
inline void ResEquipLevelUp::set_exp(int32_t value) {
  _internal_set_exp(value);
  // @@protoc_insertion_point(field_set:ResEquipLevelUp.exp)
}

// int32 heroId = 4;
inline void ResEquipLevelUp::clear_heroid() {
  heroid_ = 0;
}
inline int32_t ResEquipLevelUp::_internal_heroid() const {
  return heroid_;
}
inline int32_t ResEquipLevelUp::heroid() const {
  // @@protoc_insertion_point(field_get:ResEquipLevelUp.heroId)
  return _internal_heroid();
}
inline void ResEquipLevelUp::_internal_set_heroid(int32_t value) {
  
  heroid_ = value;
}
inline void ResEquipLevelUp::set_heroid(int32_t value) {
  _internal_set_heroid(value);
  // @@protoc_insertion_point(field_set:ResEquipLevelUp.heroId)
}

// repeated .itemAttrInfo attrs = 5;
inline int ResEquipLevelUp::_internal_attrs_size() const {
  return attrs_.size();
}
inline int ResEquipLevelUp::attrs_size() const {
  return _internal_attrs_size();
}
inline void ResEquipLevelUp::clear_attrs() {
  attrs_.Clear();
}
inline ::itemAttrInfo* ResEquipLevelUp::mutable_attrs(int index) {
  // @@protoc_insertion_point(field_mutable:ResEquipLevelUp.attrs)
  return attrs_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::itemAttrInfo >*
ResEquipLevelUp::mutable_attrs() {
  // @@protoc_insertion_point(field_mutable_list:ResEquipLevelUp.attrs)
  return &attrs_;
}
inline const ::itemAttrInfo& ResEquipLevelUp::_internal_attrs(int index) const {
  return attrs_.Get(index);
}
inline const ::itemAttrInfo& ResEquipLevelUp::attrs(int index) const {
  // @@protoc_insertion_point(field_get:ResEquipLevelUp.attrs)
  return _internal_attrs(index);
}
inline ::itemAttrInfo* ResEquipLevelUp::_internal_add_attrs() {
  return attrs_.Add();
}
inline ::itemAttrInfo* ResEquipLevelUp::add_attrs() {
  ::itemAttrInfo* _add = _internal_add_attrs();
  // @@protoc_insertion_point(field_add:ResEquipLevelUp.attrs)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::itemAttrInfo >&
ResEquipLevelUp::attrs() const {
  // @@protoc_insertion_point(field_list:ResEquipLevelUp.attrs)
  return attrs_;
}

// -------------------------------------------------------------------

// ReqUseItem

// int32 id = 1;
inline void ReqUseItem::clear_id() {
  id_ = 0;
}
inline int32_t ReqUseItem::_internal_id() const {
  return id_;
}
inline int32_t ReqUseItem::id() const {
  // @@protoc_insertion_point(field_get:ReqUseItem.id)
  return _internal_id();
}
inline void ReqUseItem::_internal_set_id(int32_t value) {
  
  id_ = value;
}
inline void ReqUseItem::set_id(int32_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:ReqUseItem.id)
}

// int32 cnt = 2;
inline void ReqUseItem::clear_cnt() {
  cnt_ = 0;
}
inline int32_t ReqUseItem::_internal_cnt() const {
  return cnt_;
}
inline int32_t ReqUseItem::cnt() const {
  // @@protoc_insertion_point(field_get:ReqUseItem.cnt)
  return _internal_cnt();
}
inline void ReqUseItem::_internal_set_cnt(int32_t value) {
  
  cnt_ = value;
}
inline void ReqUseItem::set_cnt(int32_t value) {
  _internal_set_cnt(value);
  // @@protoc_insertion_point(field_set:ReqUseItem.cnt)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_Bag_2eproto
