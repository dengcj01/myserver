// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: ServerCommon.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_ServerCommon_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_ServerCommon_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3020000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3020003 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_bases.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_ServerCommon_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_ServerCommon_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_ServerCommon_2eproto;
class BagData;
struct BagDataDefaultTypeInternal;
extern BagDataDefaultTypeInternal _BagData_default_instance_;
class LogItems;
struct LogItemsDefaultTypeInternal;
extern LogItemsDefaultTypeInternal _LogItems_default_instance_;
class LogMails;
struct LogMailsDefaultTypeInternal;
extern LogMailsDefaultTypeInternal _LogMails_default_instance_;
class PlayerBaseData;
struct PlayerBaseDataDefaultTypeInternal;
extern PlayerBaseDataDefaultTypeInternal _PlayerBaseData_default_instance_;
class ReqDbCreatePlayer;
struct ReqDbCreatePlayerDefaultTypeInternal;
extern ReqDbCreatePlayerDefaultTypeInternal _ReqDbCreatePlayer_default_instance_;
class ReqDbEnterGame;
struct ReqDbEnterGameDefaultTypeInternal;
extern ReqDbEnterGameDefaultTypeInternal _ReqDbEnterGame_default_instance_;
class ReqDbLoginAuth;
struct ReqDbLoginAuthDefaultTypeInternal;
extern ReqDbLoginAuthDefaultTypeInternal _ReqDbLoginAuth_default_instance_;
class ReqDbSelectPlayer;
struct ReqDbSelectPlayerDefaultTypeInternal;
extern ReqDbSelectPlayerDefaultTypeInternal _ReqDbSelectPlayer_default_instance_;
class ReqGameQuit;
struct ReqGameQuitDefaultTypeInternal;
extern ReqGameQuitDefaultTypeInternal _ReqGameQuit_default_instance_;
class ReqGameReport;
struct ReqGameReportDefaultTypeInternal;
extern ReqGameReportDefaultTypeInternal _ReqGameReport_default_instance_;
class ReqReturnNewName;
struct ReqReturnNewNameDefaultTypeInternal;
extern ReqReturnNewNameDefaultTypeInternal _ReqReturnNewName_default_instance_;
class ReqSavePlayerBagData;
struct ReqSavePlayerBagDataDefaultTypeInternal;
extern ReqSavePlayerBagDataDefaultTypeInternal _ReqSavePlayerBagData_default_instance_;
class ReqSavePlayerBaseData;
struct ReqSavePlayerBaseDataDefaultTypeInternal;
extern ReqSavePlayerBaseDataDefaultTypeInternal _ReqSavePlayerBaseData_default_instance_;
class ReqSavePlayerModuleData;
struct ReqSavePlayerModuleDataDefaultTypeInternal;
extern ReqSavePlayerModuleDataDefaultTypeInternal _ReqSavePlayerModuleData_default_instance_;
class ReqSelectRepeatedName;
struct ReqSelectRepeatedNameDefaultTypeInternal;
extern ReqSelectRepeatedNameDefaultTypeInternal _ReqSelectRepeatedName_default_instance_;
class ReqSendGmToGame;
struct ReqSendGmToGameDefaultTypeInternal;
extern ReqSendGmToGameDefaultTypeInternal _ReqSendGmToGame_default_instance_;
class ResDbCreatePlayer;
struct ResDbCreatePlayerDefaultTypeInternal;
extern ResDbCreatePlayerDefaultTypeInternal _ResDbCreatePlayer_default_instance_;
class ResDbEnterGame;
struct ResDbEnterGameDefaultTypeInternal;
extern ResDbEnterGameDefaultTypeInternal _ResDbEnterGame_default_instance_;
class ResDbLoginAuth;
struct ResDbLoginAuthDefaultTypeInternal;
extern ResDbLoginAuthDefaultTypeInternal _ResDbLoginAuth_default_instance_;
class ResDbSelectPlayer;
struct ResDbSelectPlayerDefaultTypeInternal;
extern ResDbSelectPlayerDefaultTypeInternal _ResDbSelectPlayer_default_instance_;
class ResReturnNewName;
struct ResReturnNewNameDefaultTypeInternal;
extern ResReturnNewNameDefaultTypeInternal _ResReturnNewName_default_instance_;
class ResReturnPlayerBagData;
struct ResReturnPlayerBagDataDefaultTypeInternal;
extern ResReturnPlayerBagDataDefaultTypeInternal _ResReturnPlayerBagData_default_instance_;
class ResReturnPlayerBaseData;
struct ResReturnPlayerBaseDataDefaultTypeInternal;
extern ResReturnPlayerBaseDataDefaultTypeInternal _ResReturnPlayerBaseData_default_instance_;
class ResReturnPlayerModuleData;
struct ResReturnPlayerModuleDataDefaultTypeInternal;
extern ResReturnPlayerModuleDataDefaultTypeInternal _ResReturnPlayerModuleData_default_instance_;
class ResSelectRepeatedName;
struct ResSelectRepeatedNameDefaultTypeInternal;
extern ResSelectRepeatedNameDefaultTypeInternal _ResSelectRepeatedName_default_instance_;
class WriteLogData;
struct WriteLogDataDefaultTypeInternal;
extern WriteLogDataDefaultTypeInternal _WriteLogData_default_instance_;
class WriteMailData;
struct WriteMailDataDefaultTypeInternal;
extern WriteMailDataDefaultTypeInternal _WriteMailData_default_instance_;
PROTOBUF_NAMESPACE_OPEN
template<> ::BagData* Arena::CreateMaybeMessage<::BagData>(Arena*);
template<> ::LogItems* Arena::CreateMaybeMessage<::LogItems>(Arena*);
template<> ::LogMails* Arena::CreateMaybeMessage<::LogMails>(Arena*);
template<> ::PlayerBaseData* Arena::CreateMaybeMessage<::PlayerBaseData>(Arena*);
template<> ::ReqDbCreatePlayer* Arena::CreateMaybeMessage<::ReqDbCreatePlayer>(Arena*);
template<> ::ReqDbEnterGame* Arena::CreateMaybeMessage<::ReqDbEnterGame>(Arena*);
template<> ::ReqDbLoginAuth* Arena::CreateMaybeMessage<::ReqDbLoginAuth>(Arena*);
template<> ::ReqDbSelectPlayer* Arena::CreateMaybeMessage<::ReqDbSelectPlayer>(Arena*);
template<> ::ReqGameQuit* Arena::CreateMaybeMessage<::ReqGameQuit>(Arena*);
template<> ::ReqGameReport* Arena::CreateMaybeMessage<::ReqGameReport>(Arena*);
template<> ::ReqReturnNewName* Arena::CreateMaybeMessage<::ReqReturnNewName>(Arena*);
template<> ::ReqSavePlayerBagData* Arena::CreateMaybeMessage<::ReqSavePlayerBagData>(Arena*);
template<> ::ReqSavePlayerBaseData* Arena::CreateMaybeMessage<::ReqSavePlayerBaseData>(Arena*);
template<> ::ReqSavePlayerModuleData* Arena::CreateMaybeMessage<::ReqSavePlayerModuleData>(Arena*);
template<> ::ReqSelectRepeatedName* Arena::CreateMaybeMessage<::ReqSelectRepeatedName>(Arena*);
template<> ::ReqSendGmToGame* Arena::CreateMaybeMessage<::ReqSendGmToGame>(Arena*);
template<> ::ResDbCreatePlayer* Arena::CreateMaybeMessage<::ResDbCreatePlayer>(Arena*);
template<> ::ResDbEnterGame* Arena::CreateMaybeMessage<::ResDbEnterGame>(Arena*);
template<> ::ResDbLoginAuth* Arena::CreateMaybeMessage<::ResDbLoginAuth>(Arena*);
template<> ::ResDbSelectPlayer* Arena::CreateMaybeMessage<::ResDbSelectPlayer>(Arena*);
template<> ::ResReturnNewName* Arena::CreateMaybeMessage<::ResReturnNewName>(Arena*);
template<> ::ResReturnPlayerBagData* Arena::CreateMaybeMessage<::ResReturnPlayerBagData>(Arena*);
template<> ::ResReturnPlayerBaseData* Arena::CreateMaybeMessage<::ResReturnPlayerBaseData>(Arena*);
template<> ::ResReturnPlayerModuleData* Arena::CreateMaybeMessage<::ResReturnPlayerModuleData>(Arena*);
template<> ::ResSelectRepeatedName* Arena::CreateMaybeMessage<::ResSelectRepeatedName>(Arena*);
template<> ::WriteLogData* Arena::CreateMaybeMessage<::WriteLogData>(Arena*);
template<> ::WriteMailData* Arena::CreateMaybeMessage<::WriteMailData>(Arena*);
PROTOBUF_NAMESPACE_CLOSE

// ===================================================================

class ReqDbLoginAuth final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ReqDbLoginAuth) */ {
 public:
  inline ReqDbLoginAuth() : ReqDbLoginAuth(nullptr) {}
  ~ReqDbLoginAuth() override;
  explicit PROTOBUF_CONSTEXPR ReqDbLoginAuth(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ReqDbLoginAuth(const ReqDbLoginAuth& from);
  ReqDbLoginAuth(ReqDbLoginAuth&& from) noexcept
    : ReqDbLoginAuth() {
    *this = ::std::move(from);
  }

  inline ReqDbLoginAuth& operator=(const ReqDbLoginAuth& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReqDbLoginAuth& operator=(ReqDbLoginAuth&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReqDbLoginAuth& default_instance() {
    return *internal_default_instance();
  }
  static inline const ReqDbLoginAuth* internal_default_instance() {
    return reinterpret_cast<const ReqDbLoginAuth*>(
               &_ReqDbLoginAuth_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(ReqDbLoginAuth& a, ReqDbLoginAuth& b) {
    a.Swap(&b);
  }
  inline void Swap(ReqDbLoginAuth* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReqDbLoginAuth* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReqDbLoginAuth* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ReqDbLoginAuth>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ReqDbLoginAuth& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ReqDbLoginAuth& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReqDbLoginAuth* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ReqDbLoginAuth";
  }
  protected:
  explicit ReqDbLoginAuth(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAccountFieldNumber = 1,
    kPasswordFieldNumber = 2,
    kPfFieldNumber = 3,
    kCsessionIdFieldNumber = 5,
    kSessionIdFieldNumber = 6,
    kFromServerIdFieldNumber = 4,
  };
  // string account = 1;
  void clear_account();
  const std::string& account() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_account(ArgT0&& arg0, ArgT... args);
  std::string* mutable_account();
  PROTOBUF_NODISCARD std::string* release_account();
  void set_allocated_account(std::string* account);
  private:
  const std::string& _internal_account() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_account(const std::string& value);
  std::string* _internal_mutable_account();
  public:

  // string password = 2;
  void clear_password();
  const std::string& password() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_password(ArgT0&& arg0, ArgT... args);
  std::string* mutable_password();
  PROTOBUF_NODISCARD std::string* release_password();
  void set_allocated_password(std::string* password);
  private:
  const std::string& _internal_password() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_password(const std::string& value);
  std::string* _internal_mutable_password();
  public:

  // string pf = 3;
  void clear_pf();
  const std::string& pf() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_pf(ArgT0&& arg0, ArgT... args);
  std::string* mutable_pf();
  PROTOBUF_NODISCARD std::string* release_pf();
  void set_allocated_pf(std::string* pf);
  private:
  const std::string& _internal_pf() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_pf(const std::string& value);
  std::string* _internal_mutable_pf();
  public:

  // uint64 csessionId = 5;
  void clear_csessionid();
  uint64_t csessionid() const;
  void set_csessionid(uint64_t value);
  private:
  uint64_t _internal_csessionid() const;
  void _internal_set_csessionid(uint64_t value);
  public:

  // uint64 sessionId = 6;
  void clear_sessionid();
  uint64_t sessionid() const;
  void set_sessionid(uint64_t value);
  private:
  uint64_t _internal_sessionid() const;
  void _internal_set_sessionid(uint64_t value);
  public:

  // sint32 fromServerId = 4;
  void clear_fromserverid();
  int32_t fromserverid() const;
  void set_fromserverid(int32_t value);
  private:
  int32_t _internal_fromserverid() const;
  void _internal_set_fromserverid(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:ReqDbLoginAuth)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr account_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr password_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr pf_;
  uint64_t csessionid_;
  uint64_t sessionid_;
  int32_t fromserverid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ServerCommon_2eproto;
};
// -------------------------------------------------------------------

class ResDbLoginAuth final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ResDbLoginAuth) */ {
 public:
  inline ResDbLoginAuth() : ResDbLoginAuth(nullptr) {}
  ~ResDbLoginAuth() override;
  explicit PROTOBUF_CONSTEXPR ResDbLoginAuth(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ResDbLoginAuth(const ResDbLoginAuth& from);
  ResDbLoginAuth(ResDbLoginAuth&& from) noexcept
    : ResDbLoginAuth() {
    *this = ::std::move(from);
  }

  inline ResDbLoginAuth& operator=(const ResDbLoginAuth& from) {
    CopyFrom(from);
    return *this;
  }
  inline ResDbLoginAuth& operator=(ResDbLoginAuth&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ResDbLoginAuth& default_instance() {
    return *internal_default_instance();
  }
  static inline const ResDbLoginAuth* internal_default_instance() {
    return reinterpret_cast<const ResDbLoginAuth*>(
               &_ResDbLoginAuth_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(ResDbLoginAuth& a, ResDbLoginAuth& b) {
    a.Swap(&b);
  }
  inline void Swap(ResDbLoginAuth* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ResDbLoginAuth* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ResDbLoginAuth* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ResDbLoginAuth>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ResDbLoginAuth& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ResDbLoginAuth& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResDbLoginAuth* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ResDbLoginAuth";
  }
  protected:
  explicit ResDbLoginAuth(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAccountFieldNumber = 1,
    kPfFieldNumber = 3,
    kGmlvFieldNumber = 2,
    kFcmTimeFieldNumber = 4,
    kCodeFieldNumber = 5,
    kFromServerIdFieldNumber = 6,
    kCsessionIdFieldNumber = 7,
    kSessionIdFieldNumber = 8,
  };
  // string account = 1;
  void clear_account();
  const std::string& account() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_account(ArgT0&& arg0, ArgT... args);
  std::string* mutable_account();
  PROTOBUF_NODISCARD std::string* release_account();
  void set_allocated_account(std::string* account);
  private:
  const std::string& _internal_account() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_account(const std::string& value);
  std::string* _internal_mutable_account();
  public:

  // string pf = 3;
  void clear_pf();
  const std::string& pf() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_pf(ArgT0&& arg0, ArgT... args);
  std::string* mutable_pf();
  PROTOBUF_NODISCARD std::string* release_pf();
  void set_allocated_pf(std::string* pf);
  private:
  const std::string& _internal_pf() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_pf(const std::string& value);
  std::string* _internal_mutable_pf();
  public:

  // sint32 gmlv = 2;
  void clear_gmlv();
  int32_t gmlv() const;
  void set_gmlv(int32_t value);
  private:
  int32_t _internal_gmlv() const;
  void _internal_set_gmlv(int32_t value);
  public:

  // sint32 fcmTime = 4;
  void clear_fcmtime();
  int32_t fcmtime() const;
  void set_fcmtime(int32_t value);
  private:
  int32_t _internal_fcmtime() const;
  void _internal_set_fcmtime(int32_t value);
  public:

  // sint32 code = 5;
  void clear_code();
  int32_t code() const;
  void set_code(int32_t value);
  private:
  int32_t _internal_code() const;
  void _internal_set_code(int32_t value);
  public:

  // sint32 fromServerId = 6;
  void clear_fromserverid();
  int32_t fromserverid() const;
  void set_fromserverid(int32_t value);
  private:
  int32_t _internal_fromserverid() const;
  void _internal_set_fromserverid(int32_t value);
  public:

  // uint64 csessionId = 7;
  void clear_csessionid();
  uint64_t csessionid() const;
  void set_csessionid(uint64_t value);
  private:
  uint64_t _internal_csessionid() const;
  void _internal_set_csessionid(uint64_t value);
  public:

  // uint64 sessionId = 8;
  void clear_sessionid();
  uint64_t sessionid() const;
  void set_sessionid(uint64_t value);
  private:
  uint64_t _internal_sessionid() const;
  void _internal_set_sessionid(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:ResDbLoginAuth)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr account_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr pf_;
  int32_t gmlv_;
  int32_t fcmtime_;
  int32_t code_;
  int32_t fromserverid_;
  uint64_t csessionid_;
  uint64_t sessionid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ServerCommon_2eproto;
};
// -------------------------------------------------------------------

class ReqDbSelectPlayer final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ReqDbSelectPlayer) */ {
 public:
  inline ReqDbSelectPlayer() : ReqDbSelectPlayer(nullptr) {}
  ~ReqDbSelectPlayer() override;
  explicit PROTOBUF_CONSTEXPR ReqDbSelectPlayer(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ReqDbSelectPlayer(const ReqDbSelectPlayer& from);
  ReqDbSelectPlayer(ReqDbSelectPlayer&& from) noexcept
    : ReqDbSelectPlayer() {
    *this = ::std::move(from);
  }

  inline ReqDbSelectPlayer& operator=(const ReqDbSelectPlayer& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReqDbSelectPlayer& operator=(ReqDbSelectPlayer&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReqDbSelectPlayer& default_instance() {
    return *internal_default_instance();
  }
  static inline const ReqDbSelectPlayer* internal_default_instance() {
    return reinterpret_cast<const ReqDbSelectPlayer*>(
               &_ReqDbSelectPlayer_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(ReqDbSelectPlayer& a, ReqDbSelectPlayer& b) {
    a.Swap(&b);
  }
  inline void Swap(ReqDbSelectPlayer* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReqDbSelectPlayer* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReqDbSelectPlayer* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ReqDbSelectPlayer>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ReqDbSelectPlayer& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ReqDbSelectPlayer& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReqDbSelectPlayer* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ReqDbSelectPlayer";
  }
  protected:
  explicit ReqDbSelectPlayer(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAccountFieldNumber = 3,
    kPfFieldNumber = 4,
    kCsessionIdFieldNumber = 1,
    kSessionIdFieldNumber = 5,
    kFromServerIdFieldNumber = 2,
  };
  // string account = 3;
  void clear_account();
  const std::string& account() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_account(ArgT0&& arg0, ArgT... args);
  std::string* mutable_account();
  PROTOBUF_NODISCARD std::string* release_account();
  void set_allocated_account(std::string* account);
  private:
  const std::string& _internal_account() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_account(const std::string& value);
  std::string* _internal_mutable_account();
  public:

  // string pf = 4;
  void clear_pf();
  const std::string& pf() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_pf(ArgT0&& arg0, ArgT... args);
  std::string* mutable_pf();
  PROTOBUF_NODISCARD std::string* release_pf();
  void set_allocated_pf(std::string* pf);
  private:
  const std::string& _internal_pf() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_pf(const std::string& value);
  std::string* _internal_mutable_pf();
  public:

  // uint64 csessionId = 1;
  void clear_csessionid();
  uint64_t csessionid() const;
  void set_csessionid(uint64_t value);
  private:
  uint64_t _internal_csessionid() const;
  void _internal_set_csessionid(uint64_t value);
  public:

  // uint64 sessionId = 5;
  void clear_sessionid();
  uint64_t sessionid() const;
  void set_sessionid(uint64_t value);
  private:
  uint64_t _internal_sessionid() const;
  void _internal_set_sessionid(uint64_t value);
  public:

  // sint32 fromServerId = 2;
  void clear_fromserverid();
  int32_t fromserverid() const;
  void set_fromserverid(int32_t value);
  private:
  int32_t _internal_fromserverid() const;
  void _internal_set_fromserverid(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:ReqDbSelectPlayer)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr account_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr pf_;
  uint64_t csessionid_;
  uint64_t sessionid_;
  int32_t fromserverid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ServerCommon_2eproto;
};
// -------------------------------------------------------------------

class ResDbSelectPlayer final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ResDbSelectPlayer) */ {
 public:
  inline ResDbSelectPlayer() : ResDbSelectPlayer(nullptr) {}
  ~ResDbSelectPlayer() override;
  explicit PROTOBUF_CONSTEXPR ResDbSelectPlayer(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ResDbSelectPlayer(const ResDbSelectPlayer& from);
  ResDbSelectPlayer(ResDbSelectPlayer&& from) noexcept
    : ResDbSelectPlayer() {
    *this = ::std::move(from);
  }

  inline ResDbSelectPlayer& operator=(const ResDbSelectPlayer& from) {
    CopyFrom(from);
    return *this;
  }
  inline ResDbSelectPlayer& operator=(ResDbSelectPlayer&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ResDbSelectPlayer& default_instance() {
    return *internal_default_instance();
  }
  static inline const ResDbSelectPlayer* internal_default_instance() {
    return reinterpret_cast<const ResDbSelectPlayer*>(
               &_ResDbSelectPlayer_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(ResDbSelectPlayer& a, ResDbSelectPlayer& b) {
    a.Swap(&b);
  }
  inline void Swap(ResDbSelectPlayer* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ResDbSelectPlayer* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ResDbSelectPlayer* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ResDbSelectPlayer>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ResDbSelectPlayer& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ResDbSelectPlayer& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResDbSelectPlayer* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ResDbSelectPlayer";
  }
  protected:
  explicit ResDbSelectPlayer(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPidFieldNumber = 1,
    kCsessionIdFieldNumber = 2,
    kSessionIdFieldNumber = 4,
    kCodeFieldNumber = 3,
  };
  // uint64 pid = 1;
  void clear_pid();
  uint64_t pid() const;
  void set_pid(uint64_t value);
  private:
  uint64_t _internal_pid() const;
  void _internal_set_pid(uint64_t value);
  public:

  // uint64 csessionId = 2;
  void clear_csessionid();
  uint64_t csessionid() const;
  void set_csessionid(uint64_t value);
  private:
  uint64_t _internal_csessionid() const;
  void _internal_set_csessionid(uint64_t value);
  public:

  // uint64 sessionId = 4;
  void clear_sessionid();
  uint64_t sessionid() const;
  void set_sessionid(uint64_t value);
  private:
  uint64_t _internal_sessionid() const;
  void _internal_set_sessionid(uint64_t value);
  public:

  // sint32 code = 3;
  void clear_code();
  int32_t code() const;
  void set_code(int32_t value);
  private:
  int32_t _internal_code() const;
  void _internal_set_code(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:ResDbSelectPlayer)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  uint64_t pid_;
  uint64_t csessionid_;
  uint64_t sessionid_;
  int32_t code_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ServerCommon_2eproto;
};
// -------------------------------------------------------------------

class ReqDbCreatePlayer final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ReqDbCreatePlayer) */ {
 public:
  inline ReqDbCreatePlayer() : ReqDbCreatePlayer(nullptr) {}
  ~ReqDbCreatePlayer() override;
  explicit PROTOBUF_CONSTEXPR ReqDbCreatePlayer(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ReqDbCreatePlayer(const ReqDbCreatePlayer& from);
  ReqDbCreatePlayer(ReqDbCreatePlayer&& from) noexcept
    : ReqDbCreatePlayer() {
    *this = ::std::move(from);
  }

  inline ReqDbCreatePlayer& operator=(const ReqDbCreatePlayer& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReqDbCreatePlayer& operator=(ReqDbCreatePlayer&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReqDbCreatePlayer& default_instance() {
    return *internal_default_instance();
  }
  static inline const ReqDbCreatePlayer* internal_default_instance() {
    return reinterpret_cast<const ReqDbCreatePlayer*>(
               &_ReqDbCreatePlayer_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(ReqDbCreatePlayer& a, ReqDbCreatePlayer& b) {
    a.Swap(&b);
  }
  inline void Swap(ReqDbCreatePlayer* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReqDbCreatePlayer* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReqDbCreatePlayer* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ReqDbCreatePlayer>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ReqDbCreatePlayer& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ReqDbCreatePlayer& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReqDbCreatePlayer* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ReqDbCreatePlayer";
  }
  protected:
  explicit ReqDbCreatePlayer(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 2,
    kAccountFieldNumber = 5,
    kPfFieldNumber = 6,
    kPidFieldNumber = 3,
    kCsessionIdFieldNumber = 4,
    kSexFieldNumber = 1,
    kFromServerIdFieldNumber = 7,
    kSessionIdFieldNumber = 9,
    kServerIdFieldNumber = 8,
  };
  // bytes name = 2;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string account = 5;
  void clear_account();
  const std::string& account() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_account(ArgT0&& arg0, ArgT... args);
  std::string* mutable_account();
  PROTOBUF_NODISCARD std::string* release_account();
  void set_allocated_account(std::string* account);
  private:
  const std::string& _internal_account() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_account(const std::string& value);
  std::string* _internal_mutable_account();
  public:

  // string pf = 6;
  void clear_pf();
  const std::string& pf() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_pf(ArgT0&& arg0, ArgT... args);
  std::string* mutable_pf();
  PROTOBUF_NODISCARD std::string* release_pf();
  void set_allocated_pf(std::string* pf);
  private:
  const std::string& _internal_pf() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_pf(const std::string& value);
  std::string* _internal_mutable_pf();
  public:

  // uint64 pid = 3;
  void clear_pid();
  uint64_t pid() const;
  void set_pid(uint64_t value);
  private:
  uint64_t _internal_pid() const;
  void _internal_set_pid(uint64_t value);
  public:

  // uint64 csessionId = 4;
  void clear_csessionid();
  uint64_t csessionid() const;
  void set_csessionid(uint64_t value);
  private:
  uint64_t _internal_csessionid() const;
  void _internal_set_csessionid(uint64_t value);
  public:

  // sint32 sex = 1;
  void clear_sex();
  int32_t sex() const;
  void set_sex(int32_t value);
  private:
  int32_t _internal_sex() const;
  void _internal_set_sex(int32_t value);
  public:

  // sint32 fromServerId = 7;
  void clear_fromserverid();
  int32_t fromserverid() const;
  void set_fromserverid(int32_t value);
  private:
  int32_t _internal_fromserverid() const;
  void _internal_set_fromserverid(int32_t value);
  public:

  // uint64 sessionId = 9;
  void clear_sessionid();
  uint64_t sessionid() const;
  void set_sessionid(uint64_t value);
  private:
  uint64_t _internal_sessionid() const;
  void _internal_set_sessionid(uint64_t value);
  public:

  // sint32 serverId = 8;
  void clear_serverid();
  int32_t serverid() const;
  void set_serverid(int32_t value);
  private:
  int32_t _internal_serverid() const;
  void _internal_set_serverid(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:ReqDbCreatePlayer)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr account_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr pf_;
  uint64_t pid_;
  uint64_t csessionid_;
  int32_t sex_;
  int32_t fromserverid_;
  uint64_t sessionid_;
  int32_t serverid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ServerCommon_2eproto;
};
// -------------------------------------------------------------------

class ResDbCreatePlayer final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ResDbCreatePlayer) */ {
 public:
  inline ResDbCreatePlayer() : ResDbCreatePlayer(nullptr) {}
  ~ResDbCreatePlayer() override;
  explicit PROTOBUF_CONSTEXPR ResDbCreatePlayer(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ResDbCreatePlayer(const ResDbCreatePlayer& from);
  ResDbCreatePlayer(ResDbCreatePlayer&& from) noexcept
    : ResDbCreatePlayer() {
    *this = ::std::move(from);
  }

  inline ResDbCreatePlayer& operator=(const ResDbCreatePlayer& from) {
    CopyFrom(from);
    return *this;
  }
  inline ResDbCreatePlayer& operator=(ResDbCreatePlayer&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ResDbCreatePlayer& default_instance() {
    return *internal_default_instance();
  }
  static inline const ResDbCreatePlayer* internal_default_instance() {
    return reinterpret_cast<const ResDbCreatePlayer*>(
               &_ResDbCreatePlayer_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(ResDbCreatePlayer& a, ResDbCreatePlayer& b) {
    a.Swap(&b);
  }
  inline void Swap(ResDbCreatePlayer* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ResDbCreatePlayer* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ResDbCreatePlayer* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ResDbCreatePlayer>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ResDbCreatePlayer& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ResDbCreatePlayer& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResDbCreatePlayer* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ResDbCreatePlayer";
  }
  protected:
  explicit ResDbCreatePlayer(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 2,
    kSexFieldNumber = 1,
    kCodeFieldNumber = 4,
    kPidFieldNumber = 3,
    kCsessionIdFieldNumber = 5,
    kSessionIdFieldNumber = 7,
  };
  // bytes name = 2;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // sint32 sex = 1;
  void clear_sex();
  int32_t sex() const;
  void set_sex(int32_t value);
  private:
  int32_t _internal_sex() const;
  void _internal_set_sex(int32_t value);
  public:

  // sint32 code = 4;
  void clear_code();
  int32_t code() const;
  void set_code(int32_t value);
  private:
  int32_t _internal_code() const;
  void _internal_set_code(int32_t value);
  public:

  // uint64 pid = 3;
  void clear_pid();
  uint64_t pid() const;
  void set_pid(uint64_t value);
  private:
  uint64_t _internal_pid() const;
  void _internal_set_pid(uint64_t value);
  public:

  // uint64 csessionId = 5;
  void clear_csessionid();
  uint64_t csessionid() const;
  void set_csessionid(uint64_t value);
  private:
  uint64_t _internal_csessionid() const;
  void _internal_set_csessionid(uint64_t value);
  public:

  // uint64 sessionId = 7;
  void clear_sessionid();
  uint64_t sessionid() const;
  void set_sessionid(uint64_t value);
  private:
  uint64_t _internal_sessionid() const;
  void _internal_set_sessionid(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:ResDbCreatePlayer)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  int32_t sex_;
  int32_t code_;
  uint64_t pid_;
  uint64_t csessionid_;
  uint64_t sessionid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ServerCommon_2eproto;
};
// -------------------------------------------------------------------

class ReqDbEnterGame final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ReqDbEnterGame) */ {
 public:
  inline ReqDbEnterGame() : ReqDbEnterGame(nullptr) {}
  ~ReqDbEnterGame() override;
  explicit PROTOBUF_CONSTEXPR ReqDbEnterGame(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ReqDbEnterGame(const ReqDbEnterGame& from);
  ReqDbEnterGame(ReqDbEnterGame&& from) noexcept
    : ReqDbEnterGame() {
    *this = ::std::move(from);
  }

  inline ReqDbEnterGame& operator=(const ReqDbEnterGame& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReqDbEnterGame& operator=(ReqDbEnterGame&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReqDbEnterGame& default_instance() {
    return *internal_default_instance();
  }
  static inline const ReqDbEnterGame* internal_default_instance() {
    return reinterpret_cast<const ReqDbEnterGame*>(
               &_ReqDbEnterGame_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(ReqDbEnterGame& a, ReqDbEnterGame& b) {
    a.Swap(&b);
  }
  inline void Swap(ReqDbEnterGame* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReqDbEnterGame* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReqDbEnterGame* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ReqDbEnterGame>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ReqDbEnterGame& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ReqDbEnterGame& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReqDbEnterGame* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ReqDbEnterGame";
  }
  protected:
  explicit ReqDbEnterGame(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPidFieldNumber = 1,
    kCsessionIdFieldNumber = 2,
    kSessionIdFieldNumber = 3,
  };
  // uint64 pid = 1;
  void clear_pid();
  uint64_t pid() const;
  void set_pid(uint64_t value);
  private:
  uint64_t _internal_pid() const;
  void _internal_set_pid(uint64_t value);
  public:

  // uint64 csessionId = 2;
  void clear_csessionid();
  uint64_t csessionid() const;
  void set_csessionid(uint64_t value);
  private:
  uint64_t _internal_csessionid() const;
  void _internal_set_csessionid(uint64_t value);
  public:

  // uint64 sessionId = 3;
  void clear_sessionid();
  uint64_t sessionid() const;
  void set_sessionid(uint64_t value);
  private:
  uint64_t _internal_sessionid() const;
  void _internal_set_sessionid(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:ReqDbEnterGame)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  uint64_t pid_;
  uint64_t csessionid_;
  uint64_t sessionid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ServerCommon_2eproto;
};
// -------------------------------------------------------------------

class ResDbEnterGame final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ResDbEnterGame) */ {
 public:
  inline ResDbEnterGame() : ResDbEnterGame(nullptr) {}
  ~ResDbEnterGame() override;
  explicit PROTOBUF_CONSTEXPR ResDbEnterGame(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ResDbEnterGame(const ResDbEnterGame& from);
  ResDbEnterGame(ResDbEnterGame&& from) noexcept
    : ResDbEnterGame() {
    *this = ::std::move(from);
  }

  inline ResDbEnterGame& operator=(const ResDbEnterGame& from) {
    CopyFrom(from);
    return *this;
  }
  inline ResDbEnterGame& operator=(ResDbEnterGame&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ResDbEnterGame& default_instance() {
    return *internal_default_instance();
  }
  static inline const ResDbEnterGame* internal_default_instance() {
    return reinterpret_cast<const ResDbEnterGame*>(
               &_ResDbEnterGame_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(ResDbEnterGame& a, ResDbEnterGame& b) {
    a.Swap(&b);
  }
  inline void Swap(ResDbEnterGame* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ResDbEnterGame* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ResDbEnterGame* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ResDbEnterGame>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ResDbEnterGame& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ResDbEnterGame& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResDbEnterGame* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ResDbEnterGame";
  }
  protected:
  explicit ResDbEnterGame(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPidFieldNumber = 1,
    kCsessionIdFieldNumber = 3,
    kSessionIdFieldNumber = 4,
    kCodeFieldNumber = 2,
  };
  // uint64 pid = 1;
  void clear_pid();
  uint64_t pid() const;
  void set_pid(uint64_t value);
  private:
  uint64_t _internal_pid() const;
  void _internal_set_pid(uint64_t value);
  public:

  // uint64 csessionId = 3;
  void clear_csessionid();
  uint64_t csessionid() const;
  void set_csessionid(uint64_t value);
  private:
  uint64_t _internal_csessionid() const;
  void _internal_set_csessionid(uint64_t value);
  public:

  // uint64 sessionId = 4;
  void clear_sessionid();
  uint64_t sessionid() const;
  void set_sessionid(uint64_t value);
  private:
  uint64_t _internal_sessionid() const;
  void _internal_set_sessionid(uint64_t value);
  public:

  // sint32 code = 2;
  void clear_code();
  int32_t code() const;
  void set_code(int32_t value);
  private:
  int32_t _internal_code() const;
  void _internal_set_code(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:ResDbEnterGame)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  uint64_t pid_;
  uint64_t csessionid_;
  uint64_t sessionid_;
  int32_t code_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ServerCommon_2eproto;
};
// -------------------------------------------------------------------

class PlayerBaseData final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:PlayerBaseData) */ {
 public:
  inline PlayerBaseData() : PlayerBaseData(nullptr) {}
  ~PlayerBaseData() override;
  explicit PROTOBUF_CONSTEXPR PlayerBaseData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PlayerBaseData(const PlayerBaseData& from);
  PlayerBaseData(PlayerBaseData&& from) noexcept
    : PlayerBaseData() {
    *this = ::std::move(from);
  }

  inline PlayerBaseData& operator=(const PlayerBaseData& from) {
    CopyFrom(from);
    return *this;
  }
  inline PlayerBaseData& operator=(PlayerBaseData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PlayerBaseData& default_instance() {
    return *internal_default_instance();
  }
  static inline const PlayerBaseData* internal_default_instance() {
    return reinterpret_cast<const PlayerBaseData*>(
               &_PlayerBaseData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(PlayerBaseData& a, PlayerBaseData& b) {
    a.Swap(&b);
  }
  inline void Swap(PlayerBaseData* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PlayerBaseData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PlayerBaseData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PlayerBaseData>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PlayerBaseData& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const PlayerBaseData& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PlayerBaseData* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "PlayerBaseData";
  }
  protected:
  explicit PlayerBaseData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 2,
    kIconFieldNumber = 3,
    kAccountFieldNumber = 4,
    kPfFieldNumber = 5,
    kExtraFieldNumber = 18,
    kPidFieldNumber = 1,
    kPowerFieldNumber = 7,
    kCreateTimeFieldNumber = 6,
    kLevelFieldNumber = 8,
    kVipFieldNumber = 9,
    kExpFieldNumber = 10,
    kSessionIdFieldNumber = 11,
    kGuildIdFieldNumber = 13,
    kLoginTimeFieldNumber = 12,
    kChargeValFieldNumber = 14,
    kHeadIconFieldNumber = 15,
    kTitleFieldNumber = 16,
    kSkinFieldNumber = 17,
    kFromServerIdFieldNumber = 19,
    kLogoutTimeFieldNumber = 20,
  };
  // bytes name = 2;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string icon = 3;
  void clear_icon();
  const std::string& icon() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_icon(ArgT0&& arg0, ArgT... args);
  std::string* mutable_icon();
  PROTOBUF_NODISCARD std::string* release_icon();
  void set_allocated_icon(std::string* icon);
  private:
  const std::string& _internal_icon() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_icon(const std::string& value);
  std::string* _internal_mutable_icon();
  public:

  // string account = 4;
  void clear_account();
  const std::string& account() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_account(ArgT0&& arg0, ArgT... args);
  std::string* mutable_account();
  PROTOBUF_NODISCARD std::string* release_account();
  void set_allocated_account(std::string* account);
  private:
  const std::string& _internal_account() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_account(const std::string& value);
  std::string* _internal_mutable_account();
  public:

  // string pf = 5;
  void clear_pf();
  const std::string& pf() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_pf(ArgT0&& arg0, ArgT... args);
  std::string* mutable_pf();
  PROTOBUF_NODISCARD std::string* release_pf();
  void set_allocated_pf(std::string* pf);
  private:
  const std::string& _internal_pf() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_pf(const std::string& value);
  std::string* _internal_mutable_pf();
  public:

  // bytes extra = 18;
  void clear_extra();
  const std::string& extra() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_extra(ArgT0&& arg0, ArgT... args);
  std::string* mutable_extra();
  PROTOBUF_NODISCARD std::string* release_extra();
  void set_allocated_extra(std::string* extra);
  private:
  const std::string& _internal_extra() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_extra(const std::string& value);
  std::string* _internal_mutable_extra();
  public:

  // uint64 pid = 1;
  void clear_pid();
  uint64_t pid() const;
  void set_pid(uint64_t value);
  private:
  uint64_t _internal_pid() const;
  void _internal_set_pid(uint64_t value);
  public:

  // uint64 power = 7;
  void clear_power();
  uint64_t power() const;
  void set_power(uint64_t value);
  private:
  uint64_t _internal_power() const;
  void _internal_set_power(uint64_t value);
  public:

  // sint32 createTime = 6;
  void clear_createtime();
  int32_t createtime() const;
  void set_createtime(int32_t value);
  private:
  int32_t _internal_createtime() const;
  void _internal_set_createtime(int32_t value);
  public:

  // sint32 level = 8;
  void clear_level();
  int32_t level() const;
  void set_level(int32_t value);
  private:
  int32_t _internal_level() const;
  void _internal_set_level(int32_t value);
  public:

  // sint32 vip = 9;
  void clear_vip();
  int32_t vip() const;
  void set_vip(int32_t value);
  private:
  int32_t _internal_vip() const;
  void _internal_set_vip(int32_t value);
  public:

  // sint32 exp = 10;
  void clear_exp();
  int32_t exp() const;
  void set_exp(int32_t value);
  private:
  int32_t _internal_exp() const;
  void _internal_set_exp(int32_t value);
  public:

  // uint64 sessionId = 11;
  void clear_sessionid();
  uint64_t sessionid() const;
  void set_sessionid(uint64_t value);
  private:
  uint64_t _internal_sessionid() const;
  void _internal_set_sessionid(uint64_t value);
  public:

  // uint64 guildId = 13;
  void clear_guildid();
  uint64_t guildid() const;
  void set_guildid(uint64_t value);
  private:
  uint64_t _internal_guildid() const;
  void _internal_set_guildid(uint64_t value);
  public:

  // sint32 loginTime = 12;
  void clear_logintime();
  int32_t logintime() const;
  void set_logintime(int32_t value);
  private:
  int32_t _internal_logintime() const;
  void _internal_set_logintime(int32_t value);
  public:

  // sint32 chargeVal = 14;
  void clear_chargeval();
  int32_t chargeval() const;
  void set_chargeval(int32_t value);
  private:
  int32_t _internal_chargeval() const;
  void _internal_set_chargeval(int32_t value);
  public:

  // sint32 headIcon = 15;
  void clear_headicon();
  int32_t headicon() const;
  void set_headicon(int32_t value);
  private:
  int32_t _internal_headicon() const;
  void _internal_set_headicon(int32_t value);
  public:

  // sint32 title = 16;
  void clear_title();
  int32_t title() const;
  void set_title(int32_t value);
  private:
  int32_t _internal_title() const;
  void _internal_set_title(int32_t value);
  public:

  // sint32 skin = 17;
  void clear_skin();
  int32_t skin() const;
  void set_skin(int32_t value);
  private:
  int32_t _internal_skin() const;
  void _internal_set_skin(int32_t value);
  public:

  // sint32 fromServerId = 19;
  void clear_fromserverid();
  int32_t fromserverid() const;
  void set_fromserverid(int32_t value);
  private:
  int32_t _internal_fromserverid() const;
  void _internal_set_fromserverid(int32_t value);
  public:

  // sint32 logoutTime = 20;
  void clear_logouttime();
  int32_t logouttime() const;
  void set_logouttime(int32_t value);
  private:
  int32_t _internal_logouttime() const;
  void _internal_set_logouttime(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:PlayerBaseData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr icon_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr account_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr pf_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr extra_;
  uint64_t pid_;
  uint64_t power_;
  int32_t createtime_;
  int32_t level_;
  int32_t vip_;
  int32_t exp_;
  uint64_t sessionid_;
  uint64_t guildid_;
  int32_t logintime_;
  int32_t chargeval_;
  int32_t headicon_;
  int32_t title_;
  int32_t skin_;
  int32_t fromserverid_;
  int32_t logouttime_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ServerCommon_2eproto;
};
// -------------------------------------------------------------------

class BagData final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:BagData) */ {
 public:
  inline BagData() : BagData(nullptr) {}
  ~BagData() override;
  explicit PROTOBUF_CONSTEXPR BagData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BagData(const BagData& from);
  BagData(BagData&& from) noexcept
    : BagData() {
    *this = ::std::move(from);
  }

  inline BagData& operator=(const BagData& from) {
    CopyFrom(from);
    return *this;
  }
  inline BagData& operator=(BagData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BagData& default_instance() {
    return *internal_default_instance();
  }
  static inline const BagData* internal_default_instance() {
    return reinterpret_cast<const BagData*>(
               &_BagData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(BagData& a, BagData& b) {
    a.Swap(&b);
  }
  inline void Swap(BagData* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BagData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BagData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BagData>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BagData& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const BagData& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BagData* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "BagData";
  }
  protected:
  explicit BagData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGuidFieldNumber = 1,
    kCountFieldNumber = 3,
    kItemIdFieldNumber = 2,
    kTimeFieldNumber = 4,
    kLevelFieldNumber = 5,
    kExpFieldNumber = 6,
    kOwnerFieldNumber = 7,
    kStarFieldNumber = 8,
    kStepFieldNumber = 9,
  };
  // uint64 guid = 1;
  void clear_guid();
  uint64_t guid() const;
  void set_guid(uint64_t value);
  private:
  uint64_t _internal_guid() const;
  void _internal_set_guid(uint64_t value);
  public:

  // uint64 count = 3;
  void clear_count();
  uint64_t count() const;
  void set_count(uint64_t value);
  private:
  uint64_t _internal_count() const;
  void _internal_set_count(uint64_t value);
  public:

  // uint32 itemId = 2;
  void clear_itemid();
  uint32_t itemid() const;
  void set_itemid(uint32_t value);
  private:
  uint32_t _internal_itemid() const;
  void _internal_set_itemid(uint32_t value);
  public:

  // sint32 time = 4;
  void clear_time();
  int32_t time() const;
  void set_time(int32_t value);
  private:
  int32_t _internal_time() const;
  void _internal_set_time(int32_t value);
  public:

  // sint32 level = 5;
  void clear_level();
  int32_t level() const;
  void set_level(int32_t value);
  private:
  int32_t _internal_level() const;
  void _internal_set_level(int32_t value);
  public:

  // sint32 exp = 6;
  void clear_exp();
  int32_t exp() const;
  void set_exp(int32_t value);
  private:
  int32_t _internal_exp() const;
  void _internal_set_exp(int32_t value);
  public:

  // uint64 owner = 7;
  void clear_owner();
  uint64_t owner() const;
  void set_owner(uint64_t value);
  private:
  uint64_t _internal_owner() const;
  void _internal_set_owner(uint64_t value);
  public:

  // sint32 star = 8;
  void clear_star();
  int32_t star() const;
  void set_star(int32_t value);
  private:
  int32_t _internal_star() const;
  void _internal_set_star(int32_t value);
  public:

  // sint32 step = 9;
  void clear_step();
  int32_t step() const;
  void set_step(int32_t value);
  private:
  int32_t _internal_step() const;
  void _internal_set_step(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:BagData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  uint64_t guid_;
  uint64_t count_;
  uint32_t itemid_;
  int32_t time_;
  int32_t level_;
  int32_t exp_;
  uint64_t owner_;
  int32_t star_;
  int32_t step_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ServerCommon_2eproto;
};
// -------------------------------------------------------------------

class ResReturnPlayerBaseData final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ResReturnPlayerBaseData) */ {
 public:
  inline ResReturnPlayerBaseData() : ResReturnPlayerBaseData(nullptr) {}
  ~ResReturnPlayerBaseData() override;
  explicit PROTOBUF_CONSTEXPR ResReturnPlayerBaseData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ResReturnPlayerBaseData(const ResReturnPlayerBaseData& from);
  ResReturnPlayerBaseData(ResReturnPlayerBaseData&& from) noexcept
    : ResReturnPlayerBaseData() {
    *this = ::std::move(from);
  }

  inline ResReturnPlayerBaseData& operator=(const ResReturnPlayerBaseData& from) {
    CopyFrom(from);
    return *this;
  }
  inline ResReturnPlayerBaseData& operator=(ResReturnPlayerBaseData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ResReturnPlayerBaseData& default_instance() {
    return *internal_default_instance();
  }
  static inline const ResReturnPlayerBaseData* internal_default_instance() {
    return reinterpret_cast<const ResReturnPlayerBaseData*>(
               &_ResReturnPlayerBaseData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(ResReturnPlayerBaseData& a, ResReturnPlayerBaseData& b) {
    a.Swap(&b);
  }
  inline void Swap(ResReturnPlayerBaseData* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ResReturnPlayerBaseData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ResReturnPlayerBaseData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ResReturnPlayerBaseData>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ResReturnPlayerBaseData& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ResReturnPlayerBaseData& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResReturnPlayerBaseData* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ResReturnPlayerBaseData";
  }
  protected:
  explicit ResReturnPlayerBaseData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 2,
    kPidFieldNumber = 1,
    kCsessionIdFieldNumber = 3,
    kSessionIdFieldNumber = 4,
  };
  // .PlayerBaseData data = 2;
  bool has_data() const;
  private:
  bool _internal_has_data() const;
  public:
  void clear_data();
  const ::PlayerBaseData& data() const;
  PROTOBUF_NODISCARD ::PlayerBaseData* release_data();
  ::PlayerBaseData* mutable_data();
  void set_allocated_data(::PlayerBaseData* data);
  private:
  const ::PlayerBaseData& _internal_data() const;
  ::PlayerBaseData* _internal_mutable_data();
  public:
  void unsafe_arena_set_allocated_data(
      ::PlayerBaseData* data);
  ::PlayerBaseData* unsafe_arena_release_data();

  // uint64 pid = 1;
  void clear_pid();
  uint64_t pid() const;
  void set_pid(uint64_t value);
  private:
  uint64_t _internal_pid() const;
  void _internal_set_pid(uint64_t value);
  public:

  // uint64 csessionId = 3;
  void clear_csessionid();
  uint64_t csessionid() const;
  void set_csessionid(uint64_t value);
  private:
  uint64_t _internal_csessionid() const;
  void _internal_set_csessionid(uint64_t value);
  public:

  // uint64 sessionId = 4;
  void clear_sessionid();
  uint64_t sessionid() const;
  void set_sessionid(uint64_t value);
  private:
  uint64_t _internal_sessionid() const;
  void _internal_set_sessionid(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:ResReturnPlayerBaseData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PlayerBaseData* data_;
  uint64_t pid_;
  uint64_t csessionid_;
  uint64_t sessionid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ServerCommon_2eproto;
};
// -------------------------------------------------------------------

class ResReturnPlayerBagData final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ResReturnPlayerBagData) */ {
 public:
  inline ResReturnPlayerBagData() : ResReturnPlayerBagData(nullptr) {}
  ~ResReturnPlayerBagData() override;
  explicit PROTOBUF_CONSTEXPR ResReturnPlayerBagData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ResReturnPlayerBagData(const ResReturnPlayerBagData& from);
  ResReturnPlayerBagData(ResReturnPlayerBagData&& from) noexcept
    : ResReturnPlayerBagData() {
    *this = ::std::move(from);
  }

  inline ResReturnPlayerBagData& operator=(const ResReturnPlayerBagData& from) {
    CopyFrom(from);
    return *this;
  }
  inline ResReturnPlayerBagData& operator=(ResReturnPlayerBagData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ResReturnPlayerBagData& default_instance() {
    return *internal_default_instance();
  }
  static inline const ResReturnPlayerBagData* internal_default_instance() {
    return reinterpret_cast<const ResReturnPlayerBagData*>(
               &_ResReturnPlayerBagData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(ResReturnPlayerBagData& a, ResReturnPlayerBagData& b) {
    a.Swap(&b);
  }
  inline void Swap(ResReturnPlayerBagData* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ResReturnPlayerBagData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ResReturnPlayerBagData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ResReturnPlayerBagData>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ResReturnPlayerBagData& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ResReturnPlayerBagData& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResReturnPlayerBagData* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ResReturnPlayerBagData";
  }
  protected:
  explicit ResReturnPlayerBagData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 2,
    kPidFieldNumber = 1,
    kCsessionIdFieldNumber = 3,
    kSessionIdFieldNumber = 4,
  };
  // repeated .BagData data = 2;
  int data_size() const;
  private:
  int _internal_data_size() const;
  public:
  void clear_data();
  ::BagData* mutable_data(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::BagData >*
      mutable_data();
  private:
  const ::BagData& _internal_data(int index) const;
  ::BagData* _internal_add_data();
  public:
  const ::BagData& data(int index) const;
  ::BagData* add_data();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::BagData >&
      data() const;

  // uint64 pid = 1;
  void clear_pid();
  uint64_t pid() const;
  void set_pid(uint64_t value);
  private:
  uint64_t _internal_pid() const;
  void _internal_set_pid(uint64_t value);
  public:

  // uint64 csessionId = 3;
  void clear_csessionid();
  uint64_t csessionid() const;
  void set_csessionid(uint64_t value);
  private:
  uint64_t _internal_csessionid() const;
  void _internal_set_csessionid(uint64_t value);
  public:

  // uint64 sessionId = 4;
  void clear_sessionid();
  uint64_t sessionid() const;
  void set_sessionid(uint64_t value);
  private:
  uint64_t _internal_sessionid() const;
  void _internal_set_sessionid(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:ResReturnPlayerBagData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::BagData > data_;
  uint64_t pid_;
  uint64_t csessionid_;
  uint64_t sessionid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ServerCommon_2eproto;
};
// -------------------------------------------------------------------

class ResReturnPlayerModuleData final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ResReturnPlayerModuleData) */ {
 public:
  inline ResReturnPlayerModuleData() : ResReturnPlayerModuleData(nullptr) {}
  ~ResReturnPlayerModuleData() override;
  explicit PROTOBUF_CONSTEXPR ResReturnPlayerModuleData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ResReturnPlayerModuleData(const ResReturnPlayerModuleData& from);
  ResReturnPlayerModuleData(ResReturnPlayerModuleData&& from) noexcept
    : ResReturnPlayerModuleData() {
    *this = ::std::move(from);
  }

  inline ResReturnPlayerModuleData& operator=(const ResReturnPlayerModuleData& from) {
    CopyFrom(from);
    return *this;
  }
  inline ResReturnPlayerModuleData& operator=(ResReturnPlayerModuleData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ResReturnPlayerModuleData& default_instance() {
    return *internal_default_instance();
  }
  static inline const ResReturnPlayerModuleData* internal_default_instance() {
    return reinterpret_cast<const ResReturnPlayerModuleData*>(
               &_ResReturnPlayerModuleData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(ResReturnPlayerModuleData& a, ResReturnPlayerModuleData& b) {
    a.Swap(&b);
  }
  inline void Swap(ResReturnPlayerModuleData* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ResReturnPlayerModuleData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ResReturnPlayerModuleData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ResReturnPlayerModuleData>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ResReturnPlayerModuleData& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ResReturnPlayerModuleData& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResReturnPlayerModuleData* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ResReturnPlayerModuleData";
  }
  protected:
  explicit ResReturnPlayerModuleData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 2,
    kCsessionIdFieldNumber = 3,
    kSessionIdFieldNumber = 4,
    kModuleIdFieldNumber = 1,
  };
  // bytes data = 2;
  void clear_data();
  const std::string& data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_data();
  PROTOBUF_NODISCARD std::string* release_data();
  void set_allocated_data(std::string* data);
  private:
  const std::string& _internal_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_data(const std::string& value);
  std::string* _internal_mutable_data();
  public:

  // uint64 csessionId = 3;
  void clear_csessionid();
  uint64_t csessionid() const;
  void set_csessionid(uint64_t value);
  private:
  uint64_t _internal_csessionid() const;
  void _internal_set_csessionid(uint64_t value);
  public:

  // uint64 sessionId = 4;
  void clear_sessionid();
  uint64_t sessionid() const;
  void set_sessionid(uint64_t value);
  private:
  uint64_t _internal_sessionid() const;
  void _internal_set_sessionid(uint64_t value);
  public:

  // sint32 moduleId = 1;
  void clear_moduleid();
  int32_t moduleid() const;
  void set_moduleid(int32_t value);
  private:
  int32_t _internal_moduleid() const;
  void _internal_set_moduleid(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:ResReturnPlayerModuleData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_;
  uint64_t csessionid_;
  uint64_t sessionid_;
  int32_t moduleid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ServerCommon_2eproto;
};
// -------------------------------------------------------------------

class ReqSavePlayerBaseData final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ReqSavePlayerBaseData) */ {
 public:
  inline ReqSavePlayerBaseData() : ReqSavePlayerBaseData(nullptr) {}
  ~ReqSavePlayerBaseData() override;
  explicit PROTOBUF_CONSTEXPR ReqSavePlayerBaseData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ReqSavePlayerBaseData(const ReqSavePlayerBaseData& from);
  ReqSavePlayerBaseData(ReqSavePlayerBaseData&& from) noexcept
    : ReqSavePlayerBaseData() {
    *this = ::std::move(from);
  }

  inline ReqSavePlayerBaseData& operator=(const ReqSavePlayerBaseData& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReqSavePlayerBaseData& operator=(ReqSavePlayerBaseData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReqSavePlayerBaseData& default_instance() {
    return *internal_default_instance();
  }
  static inline const ReqSavePlayerBaseData* internal_default_instance() {
    return reinterpret_cast<const ReqSavePlayerBaseData*>(
               &_ReqSavePlayerBaseData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(ReqSavePlayerBaseData& a, ReqSavePlayerBaseData& b) {
    a.Swap(&b);
  }
  inline void Swap(ReqSavePlayerBaseData* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReqSavePlayerBaseData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReqSavePlayerBaseData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ReqSavePlayerBaseData>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ReqSavePlayerBaseData& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ReqSavePlayerBaseData& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReqSavePlayerBaseData* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ReqSavePlayerBaseData";
  }
  protected:
  explicit ReqSavePlayerBaseData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 2,
    kPidFieldNumber = 1,
  };
  // .PlayerBaseData data = 2;
  bool has_data() const;
  private:
  bool _internal_has_data() const;
  public:
  void clear_data();
  const ::PlayerBaseData& data() const;
  PROTOBUF_NODISCARD ::PlayerBaseData* release_data();
  ::PlayerBaseData* mutable_data();
  void set_allocated_data(::PlayerBaseData* data);
  private:
  const ::PlayerBaseData& _internal_data() const;
  ::PlayerBaseData* _internal_mutable_data();
  public:
  void unsafe_arena_set_allocated_data(
      ::PlayerBaseData* data);
  ::PlayerBaseData* unsafe_arena_release_data();

  // uint64 pid = 1;
  void clear_pid();
  uint64_t pid() const;
  void set_pid(uint64_t value);
  private:
  uint64_t _internal_pid() const;
  void _internal_set_pid(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:ReqSavePlayerBaseData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PlayerBaseData* data_;
  uint64_t pid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ServerCommon_2eproto;
};
// -------------------------------------------------------------------

class ReqSavePlayerBagData final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ReqSavePlayerBagData) */ {
 public:
  inline ReqSavePlayerBagData() : ReqSavePlayerBagData(nullptr) {}
  ~ReqSavePlayerBagData() override;
  explicit PROTOBUF_CONSTEXPR ReqSavePlayerBagData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ReqSavePlayerBagData(const ReqSavePlayerBagData& from);
  ReqSavePlayerBagData(ReqSavePlayerBagData&& from) noexcept
    : ReqSavePlayerBagData() {
    *this = ::std::move(from);
  }

  inline ReqSavePlayerBagData& operator=(const ReqSavePlayerBagData& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReqSavePlayerBagData& operator=(ReqSavePlayerBagData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReqSavePlayerBagData& default_instance() {
    return *internal_default_instance();
  }
  static inline const ReqSavePlayerBagData* internal_default_instance() {
    return reinterpret_cast<const ReqSavePlayerBagData*>(
               &_ReqSavePlayerBagData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(ReqSavePlayerBagData& a, ReqSavePlayerBagData& b) {
    a.Swap(&b);
  }
  inline void Swap(ReqSavePlayerBagData* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReqSavePlayerBagData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReqSavePlayerBagData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ReqSavePlayerBagData>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ReqSavePlayerBagData& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ReqSavePlayerBagData& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReqSavePlayerBagData* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ReqSavePlayerBagData";
  }
  protected:
  explicit ReqSavePlayerBagData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 2,
    kPidFieldNumber = 1,
  };
  // repeated .BagData data = 2;
  int data_size() const;
  private:
  int _internal_data_size() const;
  public:
  void clear_data();
  ::BagData* mutable_data(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::BagData >*
      mutable_data();
  private:
  const ::BagData& _internal_data(int index) const;
  ::BagData* _internal_add_data();
  public:
  const ::BagData& data(int index) const;
  ::BagData* add_data();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::BagData >&
      data() const;

  // uint64 pid = 1;
  void clear_pid();
  uint64_t pid() const;
  void set_pid(uint64_t value);
  private:
  uint64_t _internal_pid() const;
  void _internal_set_pid(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:ReqSavePlayerBagData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::BagData > data_;
  uint64_t pid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ServerCommon_2eproto;
};
// -------------------------------------------------------------------

class ReqSavePlayerModuleData final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ReqSavePlayerModuleData) */ {
 public:
  inline ReqSavePlayerModuleData() : ReqSavePlayerModuleData(nullptr) {}
  ~ReqSavePlayerModuleData() override;
  explicit PROTOBUF_CONSTEXPR ReqSavePlayerModuleData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ReqSavePlayerModuleData(const ReqSavePlayerModuleData& from);
  ReqSavePlayerModuleData(ReqSavePlayerModuleData&& from) noexcept
    : ReqSavePlayerModuleData() {
    *this = ::std::move(from);
  }

  inline ReqSavePlayerModuleData& operator=(const ReqSavePlayerModuleData& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReqSavePlayerModuleData& operator=(ReqSavePlayerModuleData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReqSavePlayerModuleData& default_instance() {
    return *internal_default_instance();
  }
  static inline const ReqSavePlayerModuleData* internal_default_instance() {
    return reinterpret_cast<const ReqSavePlayerModuleData*>(
               &_ReqSavePlayerModuleData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(ReqSavePlayerModuleData& a, ReqSavePlayerModuleData& b) {
    a.Swap(&b);
  }
  inline void Swap(ReqSavePlayerModuleData* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReqSavePlayerModuleData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReqSavePlayerModuleData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ReqSavePlayerModuleData>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ReqSavePlayerModuleData& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ReqSavePlayerModuleData& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReqSavePlayerModuleData* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ReqSavePlayerModuleData";
  }
  protected:
  explicit ReqSavePlayerModuleData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 3,
    kPidFieldNumber = 1,
    kModuleIdFieldNumber = 2,
    kServerIdFieldNumber = 4,
  };
  // bytes data = 3;
  void clear_data();
  const std::string& data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_data();
  PROTOBUF_NODISCARD std::string* release_data();
  void set_allocated_data(std::string* data);
  private:
  const std::string& _internal_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_data(const std::string& value);
  std::string* _internal_mutable_data();
  public:

  // uint64 pid = 1;
  void clear_pid();
  uint64_t pid() const;
  void set_pid(uint64_t value);
  private:
  uint64_t _internal_pid() const;
  void _internal_set_pid(uint64_t value);
  public:

  // sint32 moduleId = 2;
  void clear_moduleid();
  int32_t moduleid() const;
  void set_moduleid(int32_t value);
  private:
  int32_t _internal_moduleid() const;
  void _internal_set_moduleid(int32_t value);
  public:

  // sint32 serverId = 4;
  void clear_serverid();
  int32_t serverid() const;
  void set_serverid(int32_t value);
  private:
  int32_t _internal_serverid() const;
  void _internal_set_serverid(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:ReqSavePlayerModuleData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_;
  uint64_t pid_;
  int32_t moduleid_;
  int32_t serverid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ServerCommon_2eproto;
};
// -------------------------------------------------------------------

class ReqSendGmToGame final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ReqSendGmToGame) */ {
 public:
  inline ReqSendGmToGame() : ReqSendGmToGame(nullptr) {}
  ~ReqSendGmToGame() override;
  explicit PROTOBUF_CONSTEXPR ReqSendGmToGame(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ReqSendGmToGame(const ReqSendGmToGame& from);
  ReqSendGmToGame(ReqSendGmToGame&& from) noexcept
    : ReqSendGmToGame() {
    *this = ::std::move(from);
  }

  inline ReqSendGmToGame& operator=(const ReqSendGmToGame& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReqSendGmToGame& operator=(ReqSendGmToGame&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReqSendGmToGame& default_instance() {
    return *internal_default_instance();
  }
  static inline const ReqSendGmToGame* internal_default_instance() {
    return reinterpret_cast<const ReqSendGmToGame*>(
               &_ReqSendGmToGame_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(ReqSendGmToGame& a, ReqSendGmToGame& b) {
    a.Swap(&b);
  }
  inline void Swap(ReqSendGmToGame* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReqSendGmToGame* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReqSendGmToGame* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ReqSendGmToGame>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ReqSendGmToGame& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ReqSendGmToGame& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReqSendGmToGame* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ReqSendGmToGame";
  }
  protected:
  explicit ReqSendGmToGame(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCmdFieldNumber = 1,
  };
  // string cmd = 1;
  void clear_cmd();
  const std::string& cmd() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_cmd(ArgT0&& arg0, ArgT... args);
  std::string* mutable_cmd();
  PROTOBUF_NODISCARD std::string* release_cmd();
  void set_allocated_cmd(std::string* cmd);
  private:
  const std::string& _internal_cmd() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_cmd(const std::string& value);
  std::string* _internal_mutable_cmd();
  public:

  // @@protoc_insertion_point(class_scope:ReqSendGmToGame)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr cmd_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ServerCommon_2eproto;
};
// -------------------------------------------------------------------

class ReqGameReport final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ReqGameReport) */ {
 public:
  inline ReqGameReport() : ReqGameReport(nullptr) {}
  ~ReqGameReport() override;
  explicit PROTOBUF_CONSTEXPR ReqGameReport(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ReqGameReport(const ReqGameReport& from);
  ReqGameReport(ReqGameReport&& from) noexcept
    : ReqGameReport() {
    *this = ::std::move(from);
  }

  inline ReqGameReport& operator=(const ReqGameReport& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReqGameReport& operator=(ReqGameReport&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReqGameReport& default_instance() {
    return *internal_default_instance();
  }
  static inline const ReqGameReport* internal_default_instance() {
    return reinterpret_cast<const ReqGameReport*>(
               &_ReqGameReport_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(ReqGameReport& a, ReqGameReport& b) {
    a.Swap(&b);
  }
  inline void Swap(ReqGameReport* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReqGameReport* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReqGameReport* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ReqGameReport>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ReqGameReport& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ReqGameReport& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReqGameReport* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ReqGameReport";
  }
  protected:
  explicit ReqGameReport(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kServerIdFieldNumber = 1,
  };
  // sint32 serverId = 1;
  void clear_serverid();
  int32_t serverid() const;
  void set_serverid(int32_t value);
  private:
  int32_t _internal_serverid() const;
  void _internal_set_serverid(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:ReqGameReport)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int32_t serverid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ServerCommon_2eproto;
};
// -------------------------------------------------------------------

class ReqGameQuit final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:ReqGameQuit) */ {
 public:
  inline ReqGameQuit() : ReqGameQuit(nullptr) {}
  explicit PROTOBUF_CONSTEXPR ReqGameQuit(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ReqGameQuit(const ReqGameQuit& from);
  ReqGameQuit(ReqGameQuit&& from) noexcept
    : ReqGameQuit() {
    *this = ::std::move(from);
  }

  inline ReqGameQuit& operator=(const ReqGameQuit& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReqGameQuit& operator=(ReqGameQuit&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReqGameQuit& default_instance() {
    return *internal_default_instance();
  }
  static inline const ReqGameQuit* internal_default_instance() {
    return reinterpret_cast<const ReqGameQuit*>(
               &_ReqGameQuit_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(ReqGameQuit& a, ReqGameQuit& b) {
    a.Swap(&b);
  }
  inline void Swap(ReqGameQuit* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReqGameQuit* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReqGameQuit* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ReqGameQuit>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const ReqGameQuit& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const ReqGameQuit& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ReqGameQuit";
  }
  protected:
  explicit ReqGameQuit(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:ReqGameQuit)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  friend struct ::TableStruct_ServerCommon_2eproto;
};
// -------------------------------------------------------------------

class LogItems final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:LogItems) */ {
 public:
  inline LogItems() : LogItems(nullptr) {}
  ~LogItems() override;
  explicit PROTOBUF_CONSTEXPR LogItems(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LogItems(const LogItems& from);
  LogItems(LogItems&& from) noexcept
    : LogItems() {
    *this = ::std::move(from);
  }

  inline LogItems& operator=(const LogItems& from) {
    CopyFrom(from);
    return *this;
  }
  inline LogItems& operator=(LogItems&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LogItems& default_instance() {
    return *internal_default_instance();
  }
  static inline const LogItems* internal_default_instance() {
    return reinterpret_cast<const LogItems*>(
               &_LogItems_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(LogItems& a, LogItems& b) {
    a.Swap(&b);
  }
  inline void Swap(LogItems* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LogItems* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LogItems* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LogItems>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LogItems& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const LogItems& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LogItems* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "LogItems";
  }
  protected:
  explicit LogItems(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCntFieldNumber = 2,
    kOldCntFieldNumber = 3,
    kIdFieldNumber = 1,
  };
  // uint64 cnt = 2;
  void clear_cnt();
  uint64_t cnt() const;
  void set_cnt(uint64_t value);
  private:
  uint64_t _internal_cnt() const;
  void _internal_set_cnt(uint64_t value);
  public:

  // uint64 oldCnt = 3;
  void clear_oldcnt();
  uint64_t oldcnt() const;
  void set_oldcnt(uint64_t value);
  private:
  uint64_t _internal_oldcnt() const;
  void _internal_set_oldcnt(uint64_t value);
  public:

  // sint32 id = 1;
  void clear_id();
  int32_t id() const;
  void set_id(int32_t value);
  private:
  int32_t _internal_id() const;
  void _internal_set_id(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:LogItems)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  uint64_t cnt_;
  uint64_t oldcnt_;
  int32_t id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ServerCommon_2eproto;
};
// -------------------------------------------------------------------

class WriteLogData final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:WriteLogData) */ {
 public:
  inline WriteLogData() : WriteLogData(nullptr) {}
  ~WriteLogData() override;
  explicit PROTOBUF_CONSTEXPR WriteLogData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  WriteLogData(const WriteLogData& from);
  WriteLogData(WriteLogData&& from) noexcept
    : WriteLogData() {
    *this = ::std::move(from);
  }

  inline WriteLogData& operator=(const WriteLogData& from) {
    CopyFrom(from);
    return *this;
  }
  inline WriteLogData& operator=(WriteLogData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const WriteLogData& default_instance() {
    return *internal_default_instance();
  }
  static inline const WriteLogData* internal_default_instance() {
    return reinterpret_cast<const WriteLogData*>(
               &_WriteLogData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(WriteLogData& a, WriteLogData& b) {
    a.Swap(&b);
  }
  inline void Swap(WriteLogData* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WriteLogData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  WriteLogData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<WriteLogData>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const WriteLogData& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const WriteLogData& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WriteLogData* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "WriteLogData";
  }
  protected:
  explicit WriteLogData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 8,
    kAccountFieldNumber = 2,
    kPfFieldNumber = 3,
    kDescFieldNumber = 4,
    kExtraFieldNumber = 6,
    kNameFieldNumber = 7,
    kPidFieldNumber = 1,
    kServerIdFieldNumber = 5,
  };
  // repeated .LogItems data = 8;
  int data_size() const;
  private:
  int _internal_data_size() const;
  public:
  void clear_data();
  ::LogItems* mutable_data(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::LogItems >*
      mutable_data();
  private:
  const ::LogItems& _internal_data(int index) const;
  ::LogItems* _internal_add_data();
  public:
  const ::LogItems& data(int index) const;
  ::LogItems* add_data();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::LogItems >&
      data() const;

  // string account = 2;
  void clear_account();
  const std::string& account() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_account(ArgT0&& arg0, ArgT... args);
  std::string* mutable_account();
  PROTOBUF_NODISCARD std::string* release_account();
  void set_allocated_account(std::string* account);
  private:
  const std::string& _internal_account() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_account(const std::string& value);
  std::string* _internal_mutable_account();
  public:

  // string pf = 3;
  void clear_pf();
  const std::string& pf() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_pf(ArgT0&& arg0, ArgT... args);
  std::string* mutable_pf();
  PROTOBUF_NODISCARD std::string* release_pf();
  void set_allocated_pf(std::string* pf);
  private:
  const std::string& _internal_pf() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_pf(const std::string& value);
  std::string* _internal_mutable_pf();
  public:

  // bytes desc = 4;
  void clear_desc();
  const std::string& desc() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_desc(ArgT0&& arg0, ArgT... args);
  std::string* mutable_desc();
  PROTOBUF_NODISCARD std::string* release_desc();
  void set_allocated_desc(std::string* desc);
  private:
  const std::string& _internal_desc() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_desc(const std::string& value);
  std::string* _internal_mutable_desc();
  public:

  // bytes extra = 6;
  void clear_extra();
  const std::string& extra() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_extra(ArgT0&& arg0, ArgT... args);
  std::string* mutable_extra();
  PROTOBUF_NODISCARD std::string* release_extra();
  void set_allocated_extra(std::string* extra);
  private:
  const std::string& _internal_extra() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_extra(const std::string& value);
  std::string* _internal_mutable_extra();
  public:

  // bytes name = 7;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // uint64 pid = 1;
  void clear_pid();
  uint64_t pid() const;
  void set_pid(uint64_t value);
  private:
  uint64_t _internal_pid() const;
  void _internal_set_pid(uint64_t value);
  public:

  // sint32 serverId = 5;
  void clear_serverid();
  int32_t serverid() const;
  void set_serverid(int32_t value);
  private:
  int32_t _internal_serverid() const;
  void _internal_set_serverid(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:WriteLogData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::LogItems > data_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr account_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr pf_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr desc_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr extra_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  uint64_t pid_;
  int32_t serverid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ServerCommon_2eproto;
};
// -------------------------------------------------------------------

class LogMails final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:LogMails) */ {
 public:
  inline LogMails() : LogMails(nullptr) {}
  ~LogMails() override;
  explicit PROTOBUF_CONSTEXPR LogMails(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LogMails(const LogMails& from);
  LogMails(LogMails&& from) noexcept
    : LogMails() {
    *this = ::std::move(from);
  }

  inline LogMails& operator=(const LogMails& from) {
    CopyFrom(from);
    return *this;
  }
  inline LogMails& operator=(LogMails&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LogMails& default_instance() {
    return *internal_default_instance();
  }
  static inline const LogMails* internal_default_instance() {
    return reinterpret_cast<const LogMails*>(
               &_LogMails_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(LogMails& a, LogMails& b) {
    a.Swap(&b);
  }
  inline void Swap(LogMails* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LogMails* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LogMails* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LogMails>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LogMails& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const LogMails& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LogMails* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "LogMails";
  }
  protected:
  explicit LogMails(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTitleFieldNumber = 2,
    kContentFieldNumber = 3,
    kRewardFieldNumber = 4,
    kDescFieldNumber = 5,
    kExtraFieldNumber = 7,
    kMailIdFieldNumber = 1,
    kExpireTimeFieldNumber = 6,
  };
  // bytes title = 2;
  void clear_title();
  const std::string& title() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_title(ArgT0&& arg0, ArgT... args);
  std::string* mutable_title();
  PROTOBUF_NODISCARD std::string* release_title();
  void set_allocated_title(std::string* title);
  private:
  const std::string& _internal_title() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_title(const std::string& value);
  std::string* _internal_mutable_title();
  public:

  // bytes content = 3;
  void clear_content();
  const std::string& content() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_content(ArgT0&& arg0, ArgT... args);
  std::string* mutable_content();
  PROTOBUF_NODISCARD std::string* release_content();
  void set_allocated_content(std::string* content);
  private:
  const std::string& _internal_content() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_content(const std::string& value);
  std::string* _internal_mutable_content();
  public:

  // string reward = 4;
  void clear_reward();
  const std::string& reward() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_reward(ArgT0&& arg0, ArgT... args);
  std::string* mutable_reward();
  PROTOBUF_NODISCARD std::string* release_reward();
  void set_allocated_reward(std::string* reward);
  private:
  const std::string& _internal_reward() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_reward(const std::string& value);
  std::string* _internal_mutable_reward();
  public:

  // bytes desc = 5;
  void clear_desc();
  const std::string& desc() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_desc(ArgT0&& arg0, ArgT... args);
  std::string* mutable_desc();
  PROTOBUF_NODISCARD std::string* release_desc();
  void set_allocated_desc(std::string* desc);
  private:
  const std::string& _internal_desc() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_desc(const std::string& value);
  std::string* _internal_mutable_desc();
  public:

  // bytes extra = 7;
  void clear_extra();
  const std::string& extra() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_extra(ArgT0&& arg0, ArgT... args);
  std::string* mutable_extra();
  PROTOBUF_NODISCARD std::string* release_extra();
  void set_allocated_extra(std::string* extra);
  private:
  const std::string& _internal_extra() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_extra(const std::string& value);
  std::string* _internal_mutable_extra();
  public:

  // uint64 mailId = 1;
  void clear_mailid();
  uint64_t mailid() const;
  void set_mailid(uint64_t value);
  private:
  uint64_t _internal_mailid() const;
  void _internal_set_mailid(uint64_t value);
  public:

  // sint32 expireTime = 6;
  void clear_expiretime();
  int32_t expiretime() const;
  void set_expiretime(int32_t value);
  private:
  int32_t _internal_expiretime() const;
  void _internal_set_expiretime(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:LogMails)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr title_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr content_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr reward_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr desc_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr extra_;
  uint64_t mailid_;
  int32_t expiretime_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ServerCommon_2eproto;
};
// -------------------------------------------------------------------

class WriteMailData final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:WriteMailData) */ {
 public:
  inline WriteMailData() : WriteMailData(nullptr) {}
  ~WriteMailData() override;
  explicit PROTOBUF_CONSTEXPR WriteMailData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  WriteMailData(const WriteMailData& from);
  WriteMailData(WriteMailData&& from) noexcept
    : WriteMailData() {
    *this = ::std::move(from);
  }

  inline WriteMailData& operator=(const WriteMailData& from) {
    CopyFrom(from);
    return *this;
  }
  inline WriteMailData& operator=(WriteMailData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const WriteMailData& default_instance() {
    return *internal_default_instance();
  }
  static inline const WriteMailData* internal_default_instance() {
    return reinterpret_cast<const WriteMailData*>(
               &_WriteMailData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(WriteMailData& a, WriteMailData& b) {
    a.Swap(&b);
  }
  inline void Swap(WriteMailData* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WriteMailData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  WriteMailData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<WriteMailData>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const WriteMailData& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const WriteMailData& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WriteMailData* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "WriteMailData";
  }
  protected:
  explicit WriteMailData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 6,
    kAccountFieldNumber = 2,
    kPfFieldNumber = 3,
    kNameFieldNumber = 5,
    kPidFieldNumber = 1,
    kServerIdFieldNumber = 4,
  };
  // repeated .LogMails data = 6;
  int data_size() const;
  private:
  int _internal_data_size() const;
  public:
  void clear_data();
  ::LogMails* mutable_data(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::LogMails >*
      mutable_data();
  private:
  const ::LogMails& _internal_data(int index) const;
  ::LogMails* _internal_add_data();
  public:
  const ::LogMails& data(int index) const;
  ::LogMails* add_data();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::LogMails >&
      data() const;

  // string account = 2;
  void clear_account();
  const std::string& account() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_account(ArgT0&& arg0, ArgT... args);
  std::string* mutable_account();
  PROTOBUF_NODISCARD std::string* release_account();
  void set_allocated_account(std::string* account);
  private:
  const std::string& _internal_account() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_account(const std::string& value);
  std::string* _internal_mutable_account();
  public:

  // string pf = 3;
  void clear_pf();
  const std::string& pf() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_pf(ArgT0&& arg0, ArgT... args);
  std::string* mutable_pf();
  PROTOBUF_NODISCARD std::string* release_pf();
  void set_allocated_pf(std::string* pf);
  private:
  const std::string& _internal_pf() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_pf(const std::string& value);
  std::string* _internal_mutable_pf();
  public:

  // bytes name = 5;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // uint64 pid = 1;
  void clear_pid();
  uint64_t pid() const;
  void set_pid(uint64_t value);
  private:
  uint64_t _internal_pid() const;
  void _internal_set_pid(uint64_t value);
  public:

  // sint32 serverId = 4;
  void clear_serverid();
  int32_t serverid() const;
  void set_serverid(int32_t value);
  private:
  int32_t _internal_serverid() const;
  void _internal_set_serverid(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:WriteMailData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::LogMails > data_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr account_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr pf_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  uint64_t pid_;
  int32_t serverid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ServerCommon_2eproto;
};
// -------------------------------------------------------------------

class ReqSelectRepeatedName final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ReqSelectRepeatedName) */ {
 public:
  inline ReqSelectRepeatedName() : ReqSelectRepeatedName(nullptr) {}
  ~ReqSelectRepeatedName() override;
  explicit PROTOBUF_CONSTEXPR ReqSelectRepeatedName(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ReqSelectRepeatedName(const ReqSelectRepeatedName& from);
  ReqSelectRepeatedName(ReqSelectRepeatedName&& from) noexcept
    : ReqSelectRepeatedName() {
    *this = ::std::move(from);
  }

  inline ReqSelectRepeatedName& operator=(const ReqSelectRepeatedName& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReqSelectRepeatedName& operator=(ReqSelectRepeatedName&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReqSelectRepeatedName& default_instance() {
    return *internal_default_instance();
  }
  static inline const ReqSelectRepeatedName* internal_default_instance() {
    return reinterpret_cast<const ReqSelectRepeatedName*>(
               &_ReqSelectRepeatedName_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(ReqSelectRepeatedName& a, ReqSelectRepeatedName& b) {
    a.Swap(&b);
  }
  inline void Swap(ReqSelectRepeatedName* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReqSelectRepeatedName* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReqSelectRepeatedName* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ReqSelectRepeatedName>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ReqSelectRepeatedName& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ReqSelectRepeatedName& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReqSelectRepeatedName* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ReqSelectRepeatedName";
  }
  protected:
  explicit ReqSelectRepeatedName(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kPidFieldNumber = 2,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // uint64 pid = 2;
  void clear_pid();
  uint64_t pid() const;
  void set_pid(uint64_t value);
  private:
  uint64_t _internal_pid() const;
  void _internal_set_pid(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:ReqSelectRepeatedName)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  uint64_t pid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ServerCommon_2eproto;
};
// -------------------------------------------------------------------

class ResSelectRepeatedName final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ResSelectRepeatedName) */ {
 public:
  inline ResSelectRepeatedName() : ResSelectRepeatedName(nullptr) {}
  ~ResSelectRepeatedName() override;
  explicit PROTOBUF_CONSTEXPR ResSelectRepeatedName(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ResSelectRepeatedName(const ResSelectRepeatedName& from);
  ResSelectRepeatedName(ResSelectRepeatedName&& from) noexcept
    : ResSelectRepeatedName() {
    *this = ::std::move(from);
  }

  inline ResSelectRepeatedName& operator=(const ResSelectRepeatedName& from) {
    CopyFrom(from);
    return *this;
  }
  inline ResSelectRepeatedName& operator=(ResSelectRepeatedName&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ResSelectRepeatedName& default_instance() {
    return *internal_default_instance();
  }
  static inline const ResSelectRepeatedName* internal_default_instance() {
    return reinterpret_cast<const ResSelectRepeatedName*>(
               &_ResSelectRepeatedName_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(ResSelectRepeatedName& a, ResSelectRepeatedName& b) {
    a.Swap(&b);
  }
  inline void Swap(ResSelectRepeatedName* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ResSelectRepeatedName* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ResSelectRepeatedName* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ResSelectRepeatedName>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ResSelectRepeatedName& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ResSelectRepeatedName& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResSelectRepeatedName* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ResSelectRepeatedName";
  }
  protected:
  explicit ResSelectRepeatedName(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kPidFieldNumber = 3,
    kResFieldNumber = 2,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // uint64 pid = 3;
  void clear_pid();
  uint64_t pid() const;
  void set_pid(uint64_t value);
  private:
  uint64_t _internal_pid() const;
  void _internal_set_pid(uint64_t value);
  public:

  // int32 res = 2;
  void clear_res();
  int32_t res() const;
  void set_res(int32_t value);
  private:
  int32_t _internal_res() const;
  void _internal_set_res(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:ResSelectRepeatedName)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  uint64_t pid_;
  int32_t res_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ServerCommon_2eproto;
};
// -------------------------------------------------------------------

class ReqReturnNewName final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:ReqReturnNewName) */ {
 public:
  inline ReqReturnNewName() : ReqReturnNewName(nullptr) {}
  explicit PROTOBUF_CONSTEXPR ReqReturnNewName(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ReqReturnNewName(const ReqReturnNewName& from);
  ReqReturnNewName(ReqReturnNewName&& from) noexcept
    : ReqReturnNewName() {
    *this = ::std::move(from);
  }

  inline ReqReturnNewName& operator=(const ReqReturnNewName& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReqReturnNewName& operator=(ReqReturnNewName&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReqReturnNewName& default_instance() {
    return *internal_default_instance();
  }
  static inline const ReqReturnNewName* internal_default_instance() {
    return reinterpret_cast<const ReqReturnNewName*>(
               &_ReqReturnNewName_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(ReqReturnNewName& a, ReqReturnNewName& b) {
    a.Swap(&b);
  }
  inline void Swap(ReqReturnNewName* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReqReturnNewName* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReqReturnNewName* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ReqReturnNewName>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const ReqReturnNewName& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const ReqReturnNewName& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ReqReturnNewName";
  }
  protected:
  explicit ReqReturnNewName(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:ReqReturnNewName)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  friend struct ::TableStruct_ServerCommon_2eproto;
};
// -------------------------------------------------------------------

class ResReturnNewName final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ResReturnNewName) */ {
 public:
  inline ResReturnNewName() : ResReturnNewName(nullptr) {}
  ~ResReturnNewName() override;
  explicit PROTOBUF_CONSTEXPR ResReturnNewName(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ResReturnNewName(const ResReturnNewName& from);
  ResReturnNewName(ResReturnNewName&& from) noexcept
    : ResReturnNewName() {
    *this = ::std::move(from);
  }

  inline ResReturnNewName& operator=(const ResReturnNewName& from) {
    CopyFrom(from);
    return *this;
  }
  inline ResReturnNewName& operator=(ResReturnNewName&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ResReturnNewName& default_instance() {
    return *internal_default_instance();
  }
  static inline const ResReturnNewName* internal_default_instance() {
    return reinterpret_cast<const ResReturnNewName*>(
               &_ResReturnNewName_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(ResReturnNewName& a, ResReturnNewName& b) {
    a.Swap(&b);
  }
  inline void Swap(ResReturnNewName* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ResReturnNewName* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ResReturnNewName* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ResReturnNewName>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ResReturnNewName& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ResReturnNewName& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResReturnNewName* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ResReturnNewName";
  }
  protected:
  explicit ResReturnNewName(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // @@protoc_insertion_point(class_scope:ResReturnNewName)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ServerCommon_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// ReqDbLoginAuth

// string account = 1;
inline void ReqDbLoginAuth::clear_account() {
  account_.ClearToEmpty();
}
inline const std::string& ReqDbLoginAuth::account() const {
  // @@protoc_insertion_point(field_get:ReqDbLoginAuth.account)
  return _internal_account();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ReqDbLoginAuth::set_account(ArgT0&& arg0, ArgT... args) {
 
 account_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ReqDbLoginAuth.account)
}
inline std::string* ReqDbLoginAuth::mutable_account() {
  std::string* _s = _internal_mutable_account();
  // @@protoc_insertion_point(field_mutable:ReqDbLoginAuth.account)
  return _s;
}
inline const std::string& ReqDbLoginAuth::_internal_account() const {
  return account_.Get();
}
inline void ReqDbLoginAuth::_internal_set_account(const std::string& value) {
  
  account_.Set(value, GetArenaForAllocation());
}
inline std::string* ReqDbLoginAuth::_internal_mutable_account() {
  
  return account_.Mutable(GetArenaForAllocation());
}
inline std::string* ReqDbLoginAuth::release_account() {
  // @@protoc_insertion_point(field_release:ReqDbLoginAuth.account)
  return account_.Release();
}
inline void ReqDbLoginAuth::set_allocated_account(std::string* account) {
  if (account != nullptr) {
    
  } else {
    
  }
  account_.SetAllocated(account, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (account_.IsDefault()) {
    account_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ReqDbLoginAuth.account)
}

// string password = 2;
inline void ReqDbLoginAuth::clear_password() {
  password_.ClearToEmpty();
}
inline const std::string& ReqDbLoginAuth::password() const {
  // @@protoc_insertion_point(field_get:ReqDbLoginAuth.password)
  return _internal_password();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ReqDbLoginAuth::set_password(ArgT0&& arg0, ArgT... args) {
 
 password_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ReqDbLoginAuth.password)
}
inline std::string* ReqDbLoginAuth::mutable_password() {
  std::string* _s = _internal_mutable_password();
  // @@protoc_insertion_point(field_mutable:ReqDbLoginAuth.password)
  return _s;
}
inline const std::string& ReqDbLoginAuth::_internal_password() const {
  return password_.Get();
}
inline void ReqDbLoginAuth::_internal_set_password(const std::string& value) {
  
  password_.Set(value, GetArenaForAllocation());
}
inline std::string* ReqDbLoginAuth::_internal_mutable_password() {
  
  return password_.Mutable(GetArenaForAllocation());
}
inline std::string* ReqDbLoginAuth::release_password() {
  // @@protoc_insertion_point(field_release:ReqDbLoginAuth.password)
  return password_.Release();
}
inline void ReqDbLoginAuth::set_allocated_password(std::string* password) {
  if (password != nullptr) {
    
  } else {
    
  }
  password_.SetAllocated(password, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (password_.IsDefault()) {
    password_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ReqDbLoginAuth.password)
}

// string pf = 3;
inline void ReqDbLoginAuth::clear_pf() {
  pf_.ClearToEmpty();
}
inline const std::string& ReqDbLoginAuth::pf() const {
  // @@protoc_insertion_point(field_get:ReqDbLoginAuth.pf)
  return _internal_pf();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ReqDbLoginAuth::set_pf(ArgT0&& arg0, ArgT... args) {
 
 pf_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ReqDbLoginAuth.pf)
}
inline std::string* ReqDbLoginAuth::mutable_pf() {
  std::string* _s = _internal_mutable_pf();
  // @@protoc_insertion_point(field_mutable:ReqDbLoginAuth.pf)
  return _s;
}
inline const std::string& ReqDbLoginAuth::_internal_pf() const {
  return pf_.Get();
}
inline void ReqDbLoginAuth::_internal_set_pf(const std::string& value) {
  
  pf_.Set(value, GetArenaForAllocation());
}
inline std::string* ReqDbLoginAuth::_internal_mutable_pf() {
  
  return pf_.Mutable(GetArenaForAllocation());
}
inline std::string* ReqDbLoginAuth::release_pf() {
  // @@protoc_insertion_point(field_release:ReqDbLoginAuth.pf)
  return pf_.Release();
}
inline void ReqDbLoginAuth::set_allocated_pf(std::string* pf) {
  if (pf != nullptr) {
    
  } else {
    
  }
  pf_.SetAllocated(pf, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (pf_.IsDefault()) {
    pf_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ReqDbLoginAuth.pf)
}

// sint32 fromServerId = 4;
inline void ReqDbLoginAuth::clear_fromserverid() {
  fromserverid_ = 0;
}
inline int32_t ReqDbLoginAuth::_internal_fromserverid() const {
  return fromserverid_;
}
inline int32_t ReqDbLoginAuth::fromserverid() const {
  // @@protoc_insertion_point(field_get:ReqDbLoginAuth.fromServerId)
  return _internal_fromserverid();
}
inline void ReqDbLoginAuth::_internal_set_fromserverid(int32_t value) {
  
  fromserverid_ = value;
}
inline void ReqDbLoginAuth::set_fromserverid(int32_t value) {
  _internal_set_fromserverid(value);
  // @@protoc_insertion_point(field_set:ReqDbLoginAuth.fromServerId)
}

// uint64 csessionId = 5;
inline void ReqDbLoginAuth::clear_csessionid() {
  csessionid_ = uint64_t{0u};
}
inline uint64_t ReqDbLoginAuth::_internal_csessionid() const {
  return csessionid_;
}
inline uint64_t ReqDbLoginAuth::csessionid() const {
  // @@protoc_insertion_point(field_get:ReqDbLoginAuth.csessionId)
  return _internal_csessionid();
}
inline void ReqDbLoginAuth::_internal_set_csessionid(uint64_t value) {
  
  csessionid_ = value;
}
inline void ReqDbLoginAuth::set_csessionid(uint64_t value) {
  _internal_set_csessionid(value);
  // @@protoc_insertion_point(field_set:ReqDbLoginAuth.csessionId)
}

// uint64 sessionId = 6;
inline void ReqDbLoginAuth::clear_sessionid() {
  sessionid_ = uint64_t{0u};
}
inline uint64_t ReqDbLoginAuth::_internal_sessionid() const {
  return sessionid_;
}
inline uint64_t ReqDbLoginAuth::sessionid() const {
  // @@protoc_insertion_point(field_get:ReqDbLoginAuth.sessionId)
  return _internal_sessionid();
}
inline void ReqDbLoginAuth::_internal_set_sessionid(uint64_t value) {
  
  sessionid_ = value;
}
inline void ReqDbLoginAuth::set_sessionid(uint64_t value) {
  _internal_set_sessionid(value);
  // @@protoc_insertion_point(field_set:ReqDbLoginAuth.sessionId)
}

// -------------------------------------------------------------------

// ResDbLoginAuth

// string account = 1;
inline void ResDbLoginAuth::clear_account() {
  account_.ClearToEmpty();
}
inline const std::string& ResDbLoginAuth::account() const {
  // @@protoc_insertion_point(field_get:ResDbLoginAuth.account)
  return _internal_account();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ResDbLoginAuth::set_account(ArgT0&& arg0, ArgT... args) {
 
 account_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ResDbLoginAuth.account)
}
inline std::string* ResDbLoginAuth::mutable_account() {
  std::string* _s = _internal_mutable_account();
  // @@protoc_insertion_point(field_mutable:ResDbLoginAuth.account)
  return _s;
}
inline const std::string& ResDbLoginAuth::_internal_account() const {
  return account_.Get();
}
inline void ResDbLoginAuth::_internal_set_account(const std::string& value) {
  
  account_.Set(value, GetArenaForAllocation());
}
inline std::string* ResDbLoginAuth::_internal_mutable_account() {
  
  return account_.Mutable(GetArenaForAllocation());
}
inline std::string* ResDbLoginAuth::release_account() {
  // @@protoc_insertion_point(field_release:ResDbLoginAuth.account)
  return account_.Release();
}
inline void ResDbLoginAuth::set_allocated_account(std::string* account) {
  if (account != nullptr) {
    
  } else {
    
  }
  account_.SetAllocated(account, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (account_.IsDefault()) {
    account_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ResDbLoginAuth.account)
}

// sint32 gmlv = 2;
inline void ResDbLoginAuth::clear_gmlv() {
  gmlv_ = 0;
}
inline int32_t ResDbLoginAuth::_internal_gmlv() const {
  return gmlv_;
}
inline int32_t ResDbLoginAuth::gmlv() const {
  // @@protoc_insertion_point(field_get:ResDbLoginAuth.gmlv)
  return _internal_gmlv();
}
inline void ResDbLoginAuth::_internal_set_gmlv(int32_t value) {
  
  gmlv_ = value;
}
inline void ResDbLoginAuth::set_gmlv(int32_t value) {
  _internal_set_gmlv(value);
  // @@protoc_insertion_point(field_set:ResDbLoginAuth.gmlv)
}

// string pf = 3;
inline void ResDbLoginAuth::clear_pf() {
  pf_.ClearToEmpty();
}
inline const std::string& ResDbLoginAuth::pf() const {
  // @@protoc_insertion_point(field_get:ResDbLoginAuth.pf)
  return _internal_pf();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ResDbLoginAuth::set_pf(ArgT0&& arg0, ArgT... args) {
 
 pf_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ResDbLoginAuth.pf)
}
inline std::string* ResDbLoginAuth::mutable_pf() {
  std::string* _s = _internal_mutable_pf();
  // @@protoc_insertion_point(field_mutable:ResDbLoginAuth.pf)
  return _s;
}
inline const std::string& ResDbLoginAuth::_internal_pf() const {
  return pf_.Get();
}
inline void ResDbLoginAuth::_internal_set_pf(const std::string& value) {
  
  pf_.Set(value, GetArenaForAllocation());
}
inline std::string* ResDbLoginAuth::_internal_mutable_pf() {
  
  return pf_.Mutable(GetArenaForAllocation());
}
inline std::string* ResDbLoginAuth::release_pf() {
  // @@protoc_insertion_point(field_release:ResDbLoginAuth.pf)
  return pf_.Release();
}
inline void ResDbLoginAuth::set_allocated_pf(std::string* pf) {
  if (pf != nullptr) {
    
  } else {
    
  }
  pf_.SetAllocated(pf, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (pf_.IsDefault()) {
    pf_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ResDbLoginAuth.pf)
}

// sint32 fcmTime = 4;
inline void ResDbLoginAuth::clear_fcmtime() {
  fcmtime_ = 0;
}
inline int32_t ResDbLoginAuth::_internal_fcmtime() const {
  return fcmtime_;
}
inline int32_t ResDbLoginAuth::fcmtime() const {
  // @@protoc_insertion_point(field_get:ResDbLoginAuth.fcmTime)
  return _internal_fcmtime();
}
inline void ResDbLoginAuth::_internal_set_fcmtime(int32_t value) {
  
  fcmtime_ = value;
}
inline void ResDbLoginAuth::set_fcmtime(int32_t value) {
  _internal_set_fcmtime(value);
  // @@protoc_insertion_point(field_set:ResDbLoginAuth.fcmTime)
}

// sint32 code = 5;
inline void ResDbLoginAuth::clear_code() {
  code_ = 0;
}
inline int32_t ResDbLoginAuth::_internal_code() const {
  return code_;
}
inline int32_t ResDbLoginAuth::code() const {
  // @@protoc_insertion_point(field_get:ResDbLoginAuth.code)
  return _internal_code();
}
inline void ResDbLoginAuth::_internal_set_code(int32_t value) {
  
  code_ = value;
}
inline void ResDbLoginAuth::set_code(int32_t value) {
  _internal_set_code(value);
  // @@protoc_insertion_point(field_set:ResDbLoginAuth.code)
}

// sint32 fromServerId = 6;
inline void ResDbLoginAuth::clear_fromserverid() {
  fromserverid_ = 0;
}
inline int32_t ResDbLoginAuth::_internal_fromserverid() const {
  return fromserverid_;
}
inline int32_t ResDbLoginAuth::fromserverid() const {
  // @@protoc_insertion_point(field_get:ResDbLoginAuth.fromServerId)
  return _internal_fromserverid();
}
inline void ResDbLoginAuth::_internal_set_fromserverid(int32_t value) {
  
  fromserverid_ = value;
}
inline void ResDbLoginAuth::set_fromserverid(int32_t value) {
  _internal_set_fromserverid(value);
  // @@protoc_insertion_point(field_set:ResDbLoginAuth.fromServerId)
}

// uint64 csessionId = 7;
inline void ResDbLoginAuth::clear_csessionid() {
  csessionid_ = uint64_t{0u};
}
inline uint64_t ResDbLoginAuth::_internal_csessionid() const {
  return csessionid_;
}
inline uint64_t ResDbLoginAuth::csessionid() const {
  // @@protoc_insertion_point(field_get:ResDbLoginAuth.csessionId)
  return _internal_csessionid();
}
inline void ResDbLoginAuth::_internal_set_csessionid(uint64_t value) {
  
  csessionid_ = value;
}
inline void ResDbLoginAuth::set_csessionid(uint64_t value) {
  _internal_set_csessionid(value);
  // @@protoc_insertion_point(field_set:ResDbLoginAuth.csessionId)
}

// uint64 sessionId = 8;
inline void ResDbLoginAuth::clear_sessionid() {
  sessionid_ = uint64_t{0u};
}
inline uint64_t ResDbLoginAuth::_internal_sessionid() const {
  return sessionid_;
}
inline uint64_t ResDbLoginAuth::sessionid() const {
  // @@protoc_insertion_point(field_get:ResDbLoginAuth.sessionId)
  return _internal_sessionid();
}
inline void ResDbLoginAuth::_internal_set_sessionid(uint64_t value) {
  
  sessionid_ = value;
}
inline void ResDbLoginAuth::set_sessionid(uint64_t value) {
  _internal_set_sessionid(value);
  // @@protoc_insertion_point(field_set:ResDbLoginAuth.sessionId)
}

// -------------------------------------------------------------------

// ReqDbSelectPlayer

// uint64 csessionId = 1;
inline void ReqDbSelectPlayer::clear_csessionid() {
  csessionid_ = uint64_t{0u};
}
inline uint64_t ReqDbSelectPlayer::_internal_csessionid() const {
  return csessionid_;
}
inline uint64_t ReqDbSelectPlayer::csessionid() const {
  // @@protoc_insertion_point(field_get:ReqDbSelectPlayer.csessionId)
  return _internal_csessionid();
}
inline void ReqDbSelectPlayer::_internal_set_csessionid(uint64_t value) {
  
  csessionid_ = value;
}
inline void ReqDbSelectPlayer::set_csessionid(uint64_t value) {
  _internal_set_csessionid(value);
  // @@protoc_insertion_point(field_set:ReqDbSelectPlayer.csessionId)
}

// sint32 fromServerId = 2;
inline void ReqDbSelectPlayer::clear_fromserverid() {
  fromserverid_ = 0;
}
inline int32_t ReqDbSelectPlayer::_internal_fromserverid() const {
  return fromserverid_;
}
inline int32_t ReqDbSelectPlayer::fromserverid() const {
  // @@protoc_insertion_point(field_get:ReqDbSelectPlayer.fromServerId)
  return _internal_fromserverid();
}
inline void ReqDbSelectPlayer::_internal_set_fromserverid(int32_t value) {
  
  fromserverid_ = value;
}
inline void ReqDbSelectPlayer::set_fromserverid(int32_t value) {
  _internal_set_fromserverid(value);
  // @@protoc_insertion_point(field_set:ReqDbSelectPlayer.fromServerId)
}

// string account = 3;
inline void ReqDbSelectPlayer::clear_account() {
  account_.ClearToEmpty();
}
inline const std::string& ReqDbSelectPlayer::account() const {
  // @@protoc_insertion_point(field_get:ReqDbSelectPlayer.account)
  return _internal_account();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ReqDbSelectPlayer::set_account(ArgT0&& arg0, ArgT... args) {
 
 account_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ReqDbSelectPlayer.account)
}
inline std::string* ReqDbSelectPlayer::mutable_account() {
  std::string* _s = _internal_mutable_account();
  // @@protoc_insertion_point(field_mutable:ReqDbSelectPlayer.account)
  return _s;
}
inline const std::string& ReqDbSelectPlayer::_internal_account() const {
  return account_.Get();
}
inline void ReqDbSelectPlayer::_internal_set_account(const std::string& value) {
  
  account_.Set(value, GetArenaForAllocation());
}
inline std::string* ReqDbSelectPlayer::_internal_mutable_account() {
  
  return account_.Mutable(GetArenaForAllocation());
}
inline std::string* ReqDbSelectPlayer::release_account() {
  // @@protoc_insertion_point(field_release:ReqDbSelectPlayer.account)
  return account_.Release();
}
inline void ReqDbSelectPlayer::set_allocated_account(std::string* account) {
  if (account != nullptr) {
    
  } else {
    
  }
  account_.SetAllocated(account, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (account_.IsDefault()) {
    account_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ReqDbSelectPlayer.account)
}

// string pf = 4;
inline void ReqDbSelectPlayer::clear_pf() {
  pf_.ClearToEmpty();
}
inline const std::string& ReqDbSelectPlayer::pf() const {
  // @@protoc_insertion_point(field_get:ReqDbSelectPlayer.pf)
  return _internal_pf();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ReqDbSelectPlayer::set_pf(ArgT0&& arg0, ArgT... args) {
 
 pf_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ReqDbSelectPlayer.pf)
}
inline std::string* ReqDbSelectPlayer::mutable_pf() {
  std::string* _s = _internal_mutable_pf();
  // @@protoc_insertion_point(field_mutable:ReqDbSelectPlayer.pf)
  return _s;
}
inline const std::string& ReqDbSelectPlayer::_internal_pf() const {
  return pf_.Get();
}
inline void ReqDbSelectPlayer::_internal_set_pf(const std::string& value) {
  
  pf_.Set(value, GetArenaForAllocation());
}
inline std::string* ReqDbSelectPlayer::_internal_mutable_pf() {
  
  return pf_.Mutable(GetArenaForAllocation());
}
inline std::string* ReqDbSelectPlayer::release_pf() {
  // @@protoc_insertion_point(field_release:ReqDbSelectPlayer.pf)
  return pf_.Release();
}
inline void ReqDbSelectPlayer::set_allocated_pf(std::string* pf) {
  if (pf != nullptr) {
    
  } else {
    
  }
  pf_.SetAllocated(pf, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (pf_.IsDefault()) {
    pf_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ReqDbSelectPlayer.pf)
}

// uint64 sessionId = 5;
inline void ReqDbSelectPlayer::clear_sessionid() {
  sessionid_ = uint64_t{0u};
}
inline uint64_t ReqDbSelectPlayer::_internal_sessionid() const {
  return sessionid_;
}
inline uint64_t ReqDbSelectPlayer::sessionid() const {
  // @@protoc_insertion_point(field_get:ReqDbSelectPlayer.sessionId)
  return _internal_sessionid();
}
inline void ReqDbSelectPlayer::_internal_set_sessionid(uint64_t value) {
  
  sessionid_ = value;
}
inline void ReqDbSelectPlayer::set_sessionid(uint64_t value) {
  _internal_set_sessionid(value);
  // @@protoc_insertion_point(field_set:ReqDbSelectPlayer.sessionId)
}

// -------------------------------------------------------------------

// ResDbSelectPlayer

// uint64 pid = 1;
inline void ResDbSelectPlayer::clear_pid() {
  pid_ = uint64_t{0u};
}
inline uint64_t ResDbSelectPlayer::_internal_pid() const {
  return pid_;
}
inline uint64_t ResDbSelectPlayer::pid() const {
  // @@protoc_insertion_point(field_get:ResDbSelectPlayer.pid)
  return _internal_pid();
}
inline void ResDbSelectPlayer::_internal_set_pid(uint64_t value) {
  
  pid_ = value;
}
inline void ResDbSelectPlayer::set_pid(uint64_t value) {
  _internal_set_pid(value);
  // @@protoc_insertion_point(field_set:ResDbSelectPlayer.pid)
}

// uint64 csessionId = 2;
inline void ResDbSelectPlayer::clear_csessionid() {
  csessionid_ = uint64_t{0u};
}
inline uint64_t ResDbSelectPlayer::_internal_csessionid() const {
  return csessionid_;
}
inline uint64_t ResDbSelectPlayer::csessionid() const {
  // @@protoc_insertion_point(field_get:ResDbSelectPlayer.csessionId)
  return _internal_csessionid();
}
inline void ResDbSelectPlayer::_internal_set_csessionid(uint64_t value) {
  
  csessionid_ = value;
}
inline void ResDbSelectPlayer::set_csessionid(uint64_t value) {
  _internal_set_csessionid(value);
  // @@protoc_insertion_point(field_set:ResDbSelectPlayer.csessionId)
}

// sint32 code = 3;
inline void ResDbSelectPlayer::clear_code() {
  code_ = 0;
}
inline int32_t ResDbSelectPlayer::_internal_code() const {
  return code_;
}
inline int32_t ResDbSelectPlayer::code() const {
  // @@protoc_insertion_point(field_get:ResDbSelectPlayer.code)
  return _internal_code();
}
inline void ResDbSelectPlayer::_internal_set_code(int32_t value) {
  
  code_ = value;
}
inline void ResDbSelectPlayer::set_code(int32_t value) {
  _internal_set_code(value);
  // @@protoc_insertion_point(field_set:ResDbSelectPlayer.code)
}

// uint64 sessionId = 4;
inline void ResDbSelectPlayer::clear_sessionid() {
  sessionid_ = uint64_t{0u};
}
inline uint64_t ResDbSelectPlayer::_internal_sessionid() const {
  return sessionid_;
}
inline uint64_t ResDbSelectPlayer::sessionid() const {
  // @@protoc_insertion_point(field_get:ResDbSelectPlayer.sessionId)
  return _internal_sessionid();
}
inline void ResDbSelectPlayer::_internal_set_sessionid(uint64_t value) {
  
  sessionid_ = value;
}
inline void ResDbSelectPlayer::set_sessionid(uint64_t value) {
  _internal_set_sessionid(value);
  // @@protoc_insertion_point(field_set:ResDbSelectPlayer.sessionId)
}

// -------------------------------------------------------------------

// ReqDbCreatePlayer

// sint32 sex = 1;
inline void ReqDbCreatePlayer::clear_sex() {
  sex_ = 0;
}
inline int32_t ReqDbCreatePlayer::_internal_sex() const {
  return sex_;
}
inline int32_t ReqDbCreatePlayer::sex() const {
  // @@protoc_insertion_point(field_get:ReqDbCreatePlayer.sex)
  return _internal_sex();
}
inline void ReqDbCreatePlayer::_internal_set_sex(int32_t value) {
  
  sex_ = value;
}
inline void ReqDbCreatePlayer::set_sex(int32_t value) {
  _internal_set_sex(value);
  // @@protoc_insertion_point(field_set:ReqDbCreatePlayer.sex)
}

// bytes name = 2;
inline void ReqDbCreatePlayer::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& ReqDbCreatePlayer::name() const {
  // @@protoc_insertion_point(field_get:ReqDbCreatePlayer.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ReqDbCreatePlayer::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ReqDbCreatePlayer.name)
}
inline std::string* ReqDbCreatePlayer::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:ReqDbCreatePlayer.name)
  return _s;
}
inline const std::string& ReqDbCreatePlayer::_internal_name() const {
  return name_.Get();
}
inline void ReqDbCreatePlayer::_internal_set_name(const std::string& value) {
  
  name_.Set(value, GetArenaForAllocation());
}
inline std::string* ReqDbCreatePlayer::_internal_mutable_name() {
  
  return name_.Mutable(GetArenaForAllocation());
}
inline std::string* ReqDbCreatePlayer::release_name() {
  // @@protoc_insertion_point(field_release:ReqDbCreatePlayer.name)
  return name_.Release();
}
inline void ReqDbCreatePlayer::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (name_.IsDefault()) {
    name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ReqDbCreatePlayer.name)
}

// uint64 pid = 3;
inline void ReqDbCreatePlayer::clear_pid() {
  pid_ = uint64_t{0u};
}
inline uint64_t ReqDbCreatePlayer::_internal_pid() const {
  return pid_;
}
inline uint64_t ReqDbCreatePlayer::pid() const {
  // @@protoc_insertion_point(field_get:ReqDbCreatePlayer.pid)
  return _internal_pid();
}
inline void ReqDbCreatePlayer::_internal_set_pid(uint64_t value) {
  
  pid_ = value;
}
inline void ReqDbCreatePlayer::set_pid(uint64_t value) {
  _internal_set_pid(value);
  // @@protoc_insertion_point(field_set:ReqDbCreatePlayer.pid)
}

// uint64 csessionId = 4;
inline void ReqDbCreatePlayer::clear_csessionid() {
  csessionid_ = uint64_t{0u};
}
inline uint64_t ReqDbCreatePlayer::_internal_csessionid() const {
  return csessionid_;
}
inline uint64_t ReqDbCreatePlayer::csessionid() const {
  // @@protoc_insertion_point(field_get:ReqDbCreatePlayer.csessionId)
  return _internal_csessionid();
}
inline void ReqDbCreatePlayer::_internal_set_csessionid(uint64_t value) {
  
  csessionid_ = value;
}
inline void ReqDbCreatePlayer::set_csessionid(uint64_t value) {
  _internal_set_csessionid(value);
  // @@protoc_insertion_point(field_set:ReqDbCreatePlayer.csessionId)
}

// string account = 5;
inline void ReqDbCreatePlayer::clear_account() {
  account_.ClearToEmpty();
}
inline const std::string& ReqDbCreatePlayer::account() const {
  // @@protoc_insertion_point(field_get:ReqDbCreatePlayer.account)
  return _internal_account();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ReqDbCreatePlayer::set_account(ArgT0&& arg0, ArgT... args) {
 
 account_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ReqDbCreatePlayer.account)
}
inline std::string* ReqDbCreatePlayer::mutable_account() {
  std::string* _s = _internal_mutable_account();
  // @@protoc_insertion_point(field_mutable:ReqDbCreatePlayer.account)
  return _s;
}
inline const std::string& ReqDbCreatePlayer::_internal_account() const {
  return account_.Get();
}
inline void ReqDbCreatePlayer::_internal_set_account(const std::string& value) {
  
  account_.Set(value, GetArenaForAllocation());
}
inline std::string* ReqDbCreatePlayer::_internal_mutable_account() {
  
  return account_.Mutable(GetArenaForAllocation());
}
inline std::string* ReqDbCreatePlayer::release_account() {
  // @@protoc_insertion_point(field_release:ReqDbCreatePlayer.account)
  return account_.Release();
}
inline void ReqDbCreatePlayer::set_allocated_account(std::string* account) {
  if (account != nullptr) {
    
  } else {
    
  }
  account_.SetAllocated(account, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (account_.IsDefault()) {
    account_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ReqDbCreatePlayer.account)
}

// string pf = 6;
inline void ReqDbCreatePlayer::clear_pf() {
  pf_.ClearToEmpty();
}
inline const std::string& ReqDbCreatePlayer::pf() const {
  // @@protoc_insertion_point(field_get:ReqDbCreatePlayer.pf)
  return _internal_pf();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ReqDbCreatePlayer::set_pf(ArgT0&& arg0, ArgT... args) {
 
 pf_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ReqDbCreatePlayer.pf)
}
inline std::string* ReqDbCreatePlayer::mutable_pf() {
  std::string* _s = _internal_mutable_pf();
  // @@protoc_insertion_point(field_mutable:ReqDbCreatePlayer.pf)
  return _s;
}
inline const std::string& ReqDbCreatePlayer::_internal_pf() const {
  return pf_.Get();
}
inline void ReqDbCreatePlayer::_internal_set_pf(const std::string& value) {
  
  pf_.Set(value, GetArenaForAllocation());
}
inline std::string* ReqDbCreatePlayer::_internal_mutable_pf() {
  
  return pf_.Mutable(GetArenaForAllocation());
}
inline std::string* ReqDbCreatePlayer::release_pf() {
  // @@protoc_insertion_point(field_release:ReqDbCreatePlayer.pf)
  return pf_.Release();
}
inline void ReqDbCreatePlayer::set_allocated_pf(std::string* pf) {
  if (pf != nullptr) {
    
  } else {
    
  }
  pf_.SetAllocated(pf, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (pf_.IsDefault()) {
    pf_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ReqDbCreatePlayer.pf)
}

// sint32 fromServerId = 7;
inline void ReqDbCreatePlayer::clear_fromserverid() {
  fromserverid_ = 0;
}
inline int32_t ReqDbCreatePlayer::_internal_fromserverid() const {
  return fromserverid_;
}
inline int32_t ReqDbCreatePlayer::fromserverid() const {
  // @@protoc_insertion_point(field_get:ReqDbCreatePlayer.fromServerId)
  return _internal_fromserverid();
}
inline void ReqDbCreatePlayer::_internal_set_fromserverid(int32_t value) {
  
  fromserverid_ = value;
}
inline void ReqDbCreatePlayer::set_fromserverid(int32_t value) {
  _internal_set_fromserverid(value);
  // @@protoc_insertion_point(field_set:ReqDbCreatePlayer.fromServerId)
}

// sint32 serverId = 8;
inline void ReqDbCreatePlayer::clear_serverid() {
  serverid_ = 0;
}
inline int32_t ReqDbCreatePlayer::_internal_serverid() const {
  return serverid_;
}
inline int32_t ReqDbCreatePlayer::serverid() const {
  // @@protoc_insertion_point(field_get:ReqDbCreatePlayer.serverId)
  return _internal_serverid();
}
inline void ReqDbCreatePlayer::_internal_set_serverid(int32_t value) {
  
  serverid_ = value;
}
inline void ReqDbCreatePlayer::set_serverid(int32_t value) {
  _internal_set_serverid(value);
  // @@protoc_insertion_point(field_set:ReqDbCreatePlayer.serverId)
}

// uint64 sessionId = 9;
inline void ReqDbCreatePlayer::clear_sessionid() {
  sessionid_ = uint64_t{0u};
}
inline uint64_t ReqDbCreatePlayer::_internal_sessionid() const {
  return sessionid_;
}
inline uint64_t ReqDbCreatePlayer::sessionid() const {
  // @@protoc_insertion_point(field_get:ReqDbCreatePlayer.sessionId)
  return _internal_sessionid();
}
inline void ReqDbCreatePlayer::_internal_set_sessionid(uint64_t value) {
  
  sessionid_ = value;
}
inline void ReqDbCreatePlayer::set_sessionid(uint64_t value) {
  _internal_set_sessionid(value);
  // @@protoc_insertion_point(field_set:ReqDbCreatePlayer.sessionId)
}

// -------------------------------------------------------------------

// ResDbCreatePlayer

// sint32 sex = 1;
inline void ResDbCreatePlayer::clear_sex() {
  sex_ = 0;
}
inline int32_t ResDbCreatePlayer::_internal_sex() const {
  return sex_;
}
inline int32_t ResDbCreatePlayer::sex() const {
  // @@protoc_insertion_point(field_get:ResDbCreatePlayer.sex)
  return _internal_sex();
}
inline void ResDbCreatePlayer::_internal_set_sex(int32_t value) {
  
  sex_ = value;
}
inline void ResDbCreatePlayer::set_sex(int32_t value) {
  _internal_set_sex(value);
  // @@protoc_insertion_point(field_set:ResDbCreatePlayer.sex)
}

// bytes name = 2;
inline void ResDbCreatePlayer::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& ResDbCreatePlayer::name() const {
  // @@protoc_insertion_point(field_get:ResDbCreatePlayer.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ResDbCreatePlayer::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ResDbCreatePlayer.name)
}
inline std::string* ResDbCreatePlayer::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:ResDbCreatePlayer.name)
  return _s;
}
inline const std::string& ResDbCreatePlayer::_internal_name() const {
  return name_.Get();
}
inline void ResDbCreatePlayer::_internal_set_name(const std::string& value) {
  
  name_.Set(value, GetArenaForAllocation());
}
inline std::string* ResDbCreatePlayer::_internal_mutable_name() {
  
  return name_.Mutable(GetArenaForAllocation());
}
inline std::string* ResDbCreatePlayer::release_name() {
  // @@protoc_insertion_point(field_release:ResDbCreatePlayer.name)
  return name_.Release();
}
inline void ResDbCreatePlayer::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (name_.IsDefault()) {
    name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ResDbCreatePlayer.name)
}

// uint64 pid = 3;
inline void ResDbCreatePlayer::clear_pid() {
  pid_ = uint64_t{0u};
}
inline uint64_t ResDbCreatePlayer::_internal_pid() const {
  return pid_;
}
inline uint64_t ResDbCreatePlayer::pid() const {
  // @@protoc_insertion_point(field_get:ResDbCreatePlayer.pid)
  return _internal_pid();
}
inline void ResDbCreatePlayer::_internal_set_pid(uint64_t value) {
  
  pid_ = value;
}
inline void ResDbCreatePlayer::set_pid(uint64_t value) {
  _internal_set_pid(value);
  // @@protoc_insertion_point(field_set:ResDbCreatePlayer.pid)
}

// sint32 code = 4;
inline void ResDbCreatePlayer::clear_code() {
  code_ = 0;
}
inline int32_t ResDbCreatePlayer::_internal_code() const {
  return code_;
}
inline int32_t ResDbCreatePlayer::code() const {
  // @@protoc_insertion_point(field_get:ResDbCreatePlayer.code)
  return _internal_code();
}
inline void ResDbCreatePlayer::_internal_set_code(int32_t value) {
  
  code_ = value;
}
inline void ResDbCreatePlayer::set_code(int32_t value) {
  _internal_set_code(value);
  // @@protoc_insertion_point(field_set:ResDbCreatePlayer.code)
}

// uint64 csessionId = 5;
inline void ResDbCreatePlayer::clear_csessionid() {
  csessionid_ = uint64_t{0u};
}
inline uint64_t ResDbCreatePlayer::_internal_csessionid() const {
  return csessionid_;
}
inline uint64_t ResDbCreatePlayer::csessionid() const {
  // @@protoc_insertion_point(field_get:ResDbCreatePlayer.csessionId)
  return _internal_csessionid();
}
inline void ResDbCreatePlayer::_internal_set_csessionid(uint64_t value) {
  
  csessionid_ = value;
}
inline void ResDbCreatePlayer::set_csessionid(uint64_t value) {
  _internal_set_csessionid(value);
  // @@protoc_insertion_point(field_set:ResDbCreatePlayer.csessionId)
}

// uint64 sessionId = 7;
inline void ResDbCreatePlayer::clear_sessionid() {
  sessionid_ = uint64_t{0u};
}
inline uint64_t ResDbCreatePlayer::_internal_sessionid() const {
  return sessionid_;
}
inline uint64_t ResDbCreatePlayer::sessionid() const {
  // @@protoc_insertion_point(field_get:ResDbCreatePlayer.sessionId)
  return _internal_sessionid();
}
inline void ResDbCreatePlayer::_internal_set_sessionid(uint64_t value) {
  
  sessionid_ = value;
}
inline void ResDbCreatePlayer::set_sessionid(uint64_t value) {
  _internal_set_sessionid(value);
  // @@protoc_insertion_point(field_set:ResDbCreatePlayer.sessionId)
}

// -------------------------------------------------------------------

// ReqDbEnterGame

// uint64 pid = 1;
inline void ReqDbEnterGame::clear_pid() {
  pid_ = uint64_t{0u};
}
inline uint64_t ReqDbEnterGame::_internal_pid() const {
  return pid_;
}
inline uint64_t ReqDbEnterGame::pid() const {
  // @@protoc_insertion_point(field_get:ReqDbEnterGame.pid)
  return _internal_pid();
}
inline void ReqDbEnterGame::_internal_set_pid(uint64_t value) {
  
  pid_ = value;
}
inline void ReqDbEnterGame::set_pid(uint64_t value) {
  _internal_set_pid(value);
  // @@protoc_insertion_point(field_set:ReqDbEnterGame.pid)
}

// uint64 csessionId = 2;
inline void ReqDbEnterGame::clear_csessionid() {
  csessionid_ = uint64_t{0u};
}
inline uint64_t ReqDbEnterGame::_internal_csessionid() const {
  return csessionid_;
}
inline uint64_t ReqDbEnterGame::csessionid() const {
  // @@protoc_insertion_point(field_get:ReqDbEnterGame.csessionId)
  return _internal_csessionid();
}
inline void ReqDbEnterGame::_internal_set_csessionid(uint64_t value) {
  
  csessionid_ = value;
}
inline void ReqDbEnterGame::set_csessionid(uint64_t value) {
  _internal_set_csessionid(value);
  // @@protoc_insertion_point(field_set:ReqDbEnterGame.csessionId)
}

// uint64 sessionId = 3;
inline void ReqDbEnterGame::clear_sessionid() {
  sessionid_ = uint64_t{0u};
}
inline uint64_t ReqDbEnterGame::_internal_sessionid() const {
  return sessionid_;
}
inline uint64_t ReqDbEnterGame::sessionid() const {
  // @@protoc_insertion_point(field_get:ReqDbEnterGame.sessionId)
  return _internal_sessionid();
}
inline void ReqDbEnterGame::_internal_set_sessionid(uint64_t value) {
  
  sessionid_ = value;
}
inline void ReqDbEnterGame::set_sessionid(uint64_t value) {
  _internal_set_sessionid(value);
  // @@protoc_insertion_point(field_set:ReqDbEnterGame.sessionId)
}

// -------------------------------------------------------------------

// ResDbEnterGame

// uint64 pid = 1;
inline void ResDbEnterGame::clear_pid() {
  pid_ = uint64_t{0u};
}
inline uint64_t ResDbEnterGame::_internal_pid() const {
  return pid_;
}
inline uint64_t ResDbEnterGame::pid() const {
  // @@protoc_insertion_point(field_get:ResDbEnterGame.pid)
  return _internal_pid();
}
inline void ResDbEnterGame::_internal_set_pid(uint64_t value) {
  
  pid_ = value;
}
inline void ResDbEnterGame::set_pid(uint64_t value) {
  _internal_set_pid(value);
  // @@protoc_insertion_point(field_set:ResDbEnterGame.pid)
}

// sint32 code = 2;
inline void ResDbEnterGame::clear_code() {
  code_ = 0;
}
inline int32_t ResDbEnterGame::_internal_code() const {
  return code_;
}
inline int32_t ResDbEnterGame::code() const {
  // @@protoc_insertion_point(field_get:ResDbEnterGame.code)
  return _internal_code();
}
inline void ResDbEnterGame::_internal_set_code(int32_t value) {
  
  code_ = value;
}
inline void ResDbEnterGame::set_code(int32_t value) {
  _internal_set_code(value);
  // @@protoc_insertion_point(field_set:ResDbEnterGame.code)
}

// uint64 csessionId = 3;
inline void ResDbEnterGame::clear_csessionid() {
  csessionid_ = uint64_t{0u};
}
inline uint64_t ResDbEnterGame::_internal_csessionid() const {
  return csessionid_;
}
inline uint64_t ResDbEnterGame::csessionid() const {
  // @@protoc_insertion_point(field_get:ResDbEnterGame.csessionId)
  return _internal_csessionid();
}
inline void ResDbEnterGame::_internal_set_csessionid(uint64_t value) {
  
  csessionid_ = value;
}
inline void ResDbEnterGame::set_csessionid(uint64_t value) {
  _internal_set_csessionid(value);
  // @@protoc_insertion_point(field_set:ResDbEnterGame.csessionId)
}

// uint64 sessionId = 4;
inline void ResDbEnterGame::clear_sessionid() {
  sessionid_ = uint64_t{0u};
}
inline uint64_t ResDbEnterGame::_internal_sessionid() const {
  return sessionid_;
}
inline uint64_t ResDbEnterGame::sessionid() const {
  // @@protoc_insertion_point(field_get:ResDbEnterGame.sessionId)
  return _internal_sessionid();
}
inline void ResDbEnterGame::_internal_set_sessionid(uint64_t value) {
  
  sessionid_ = value;
}
inline void ResDbEnterGame::set_sessionid(uint64_t value) {
  _internal_set_sessionid(value);
  // @@protoc_insertion_point(field_set:ResDbEnterGame.sessionId)
}

// -------------------------------------------------------------------

// PlayerBaseData

// uint64 pid = 1;
inline void PlayerBaseData::clear_pid() {
  pid_ = uint64_t{0u};
}
inline uint64_t PlayerBaseData::_internal_pid() const {
  return pid_;
}
inline uint64_t PlayerBaseData::pid() const {
  // @@protoc_insertion_point(field_get:PlayerBaseData.pid)
  return _internal_pid();
}
inline void PlayerBaseData::_internal_set_pid(uint64_t value) {
  
  pid_ = value;
}
inline void PlayerBaseData::set_pid(uint64_t value) {
  _internal_set_pid(value);
  // @@protoc_insertion_point(field_set:PlayerBaseData.pid)
}

// bytes name = 2;
inline void PlayerBaseData::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& PlayerBaseData::name() const {
  // @@protoc_insertion_point(field_get:PlayerBaseData.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PlayerBaseData::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:PlayerBaseData.name)
}
inline std::string* PlayerBaseData::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:PlayerBaseData.name)
  return _s;
}
inline const std::string& PlayerBaseData::_internal_name() const {
  return name_.Get();
}
inline void PlayerBaseData::_internal_set_name(const std::string& value) {
  
  name_.Set(value, GetArenaForAllocation());
}
inline std::string* PlayerBaseData::_internal_mutable_name() {
  
  return name_.Mutable(GetArenaForAllocation());
}
inline std::string* PlayerBaseData::release_name() {
  // @@protoc_insertion_point(field_release:PlayerBaseData.name)
  return name_.Release();
}
inline void PlayerBaseData::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (name_.IsDefault()) {
    name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:PlayerBaseData.name)
}

// string icon = 3;
inline void PlayerBaseData::clear_icon() {
  icon_.ClearToEmpty();
}
inline const std::string& PlayerBaseData::icon() const {
  // @@protoc_insertion_point(field_get:PlayerBaseData.icon)
  return _internal_icon();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PlayerBaseData::set_icon(ArgT0&& arg0, ArgT... args) {
 
 icon_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:PlayerBaseData.icon)
}
inline std::string* PlayerBaseData::mutable_icon() {
  std::string* _s = _internal_mutable_icon();
  // @@protoc_insertion_point(field_mutable:PlayerBaseData.icon)
  return _s;
}
inline const std::string& PlayerBaseData::_internal_icon() const {
  return icon_.Get();
}
inline void PlayerBaseData::_internal_set_icon(const std::string& value) {
  
  icon_.Set(value, GetArenaForAllocation());
}
inline std::string* PlayerBaseData::_internal_mutable_icon() {
  
  return icon_.Mutable(GetArenaForAllocation());
}
inline std::string* PlayerBaseData::release_icon() {
  // @@protoc_insertion_point(field_release:PlayerBaseData.icon)
  return icon_.Release();
}
inline void PlayerBaseData::set_allocated_icon(std::string* icon) {
  if (icon != nullptr) {
    
  } else {
    
  }
  icon_.SetAllocated(icon, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (icon_.IsDefault()) {
    icon_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:PlayerBaseData.icon)
}

// string account = 4;
inline void PlayerBaseData::clear_account() {
  account_.ClearToEmpty();
}
inline const std::string& PlayerBaseData::account() const {
  // @@protoc_insertion_point(field_get:PlayerBaseData.account)
  return _internal_account();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PlayerBaseData::set_account(ArgT0&& arg0, ArgT... args) {
 
 account_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:PlayerBaseData.account)
}
inline std::string* PlayerBaseData::mutable_account() {
  std::string* _s = _internal_mutable_account();
  // @@protoc_insertion_point(field_mutable:PlayerBaseData.account)
  return _s;
}
inline const std::string& PlayerBaseData::_internal_account() const {
  return account_.Get();
}
inline void PlayerBaseData::_internal_set_account(const std::string& value) {
  
  account_.Set(value, GetArenaForAllocation());
}
inline std::string* PlayerBaseData::_internal_mutable_account() {
  
  return account_.Mutable(GetArenaForAllocation());
}
inline std::string* PlayerBaseData::release_account() {
  // @@protoc_insertion_point(field_release:PlayerBaseData.account)
  return account_.Release();
}
inline void PlayerBaseData::set_allocated_account(std::string* account) {
  if (account != nullptr) {
    
  } else {
    
  }
  account_.SetAllocated(account, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (account_.IsDefault()) {
    account_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:PlayerBaseData.account)
}

// string pf = 5;
inline void PlayerBaseData::clear_pf() {
  pf_.ClearToEmpty();
}
inline const std::string& PlayerBaseData::pf() const {
  // @@protoc_insertion_point(field_get:PlayerBaseData.pf)
  return _internal_pf();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PlayerBaseData::set_pf(ArgT0&& arg0, ArgT... args) {
 
 pf_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:PlayerBaseData.pf)
}
inline std::string* PlayerBaseData::mutable_pf() {
  std::string* _s = _internal_mutable_pf();
  // @@protoc_insertion_point(field_mutable:PlayerBaseData.pf)
  return _s;
}
inline const std::string& PlayerBaseData::_internal_pf() const {
  return pf_.Get();
}
inline void PlayerBaseData::_internal_set_pf(const std::string& value) {
  
  pf_.Set(value, GetArenaForAllocation());
}
inline std::string* PlayerBaseData::_internal_mutable_pf() {
  
  return pf_.Mutable(GetArenaForAllocation());
}
inline std::string* PlayerBaseData::release_pf() {
  // @@protoc_insertion_point(field_release:PlayerBaseData.pf)
  return pf_.Release();
}
inline void PlayerBaseData::set_allocated_pf(std::string* pf) {
  if (pf != nullptr) {
    
  } else {
    
  }
  pf_.SetAllocated(pf, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (pf_.IsDefault()) {
    pf_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:PlayerBaseData.pf)
}

// sint32 createTime = 6;
inline void PlayerBaseData::clear_createtime() {
  createtime_ = 0;
}
inline int32_t PlayerBaseData::_internal_createtime() const {
  return createtime_;
}
inline int32_t PlayerBaseData::createtime() const {
  // @@protoc_insertion_point(field_get:PlayerBaseData.createTime)
  return _internal_createtime();
}
inline void PlayerBaseData::_internal_set_createtime(int32_t value) {
  
  createtime_ = value;
}
inline void PlayerBaseData::set_createtime(int32_t value) {
  _internal_set_createtime(value);
  // @@protoc_insertion_point(field_set:PlayerBaseData.createTime)
}

// uint64 power = 7;
inline void PlayerBaseData::clear_power() {
  power_ = uint64_t{0u};
}
inline uint64_t PlayerBaseData::_internal_power() const {
  return power_;
}
inline uint64_t PlayerBaseData::power() const {
  // @@protoc_insertion_point(field_get:PlayerBaseData.power)
  return _internal_power();
}
inline void PlayerBaseData::_internal_set_power(uint64_t value) {
  
  power_ = value;
}
inline void PlayerBaseData::set_power(uint64_t value) {
  _internal_set_power(value);
  // @@protoc_insertion_point(field_set:PlayerBaseData.power)
}

// sint32 level = 8;
inline void PlayerBaseData::clear_level() {
  level_ = 0;
}
inline int32_t PlayerBaseData::_internal_level() const {
  return level_;
}
inline int32_t PlayerBaseData::level() const {
  // @@protoc_insertion_point(field_get:PlayerBaseData.level)
  return _internal_level();
}
inline void PlayerBaseData::_internal_set_level(int32_t value) {
  
  level_ = value;
}
inline void PlayerBaseData::set_level(int32_t value) {
  _internal_set_level(value);
  // @@protoc_insertion_point(field_set:PlayerBaseData.level)
}

// sint32 vip = 9;
inline void PlayerBaseData::clear_vip() {
  vip_ = 0;
}
inline int32_t PlayerBaseData::_internal_vip() const {
  return vip_;
}
inline int32_t PlayerBaseData::vip() const {
  // @@protoc_insertion_point(field_get:PlayerBaseData.vip)
  return _internal_vip();
}
inline void PlayerBaseData::_internal_set_vip(int32_t value) {
  
  vip_ = value;
}
inline void PlayerBaseData::set_vip(int32_t value) {
  _internal_set_vip(value);
  // @@protoc_insertion_point(field_set:PlayerBaseData.vip)
}

// sint32 exp = 10;
inline void PlayerBaseData::clear_exp() {
  exp_ = 0;
}
inline int32_t PlayerBaseData::_internal_exp() const {
  return exp_;
}
inline int32_t PlayerBaseData::exp() const {
  // @@protoc_insertion_point(field_get:PlayerBaseData.exp)
  return _internal_exp();
}
inline void PlayerBaseData::_internal_set_exp(int32_t value) {
  
  exp_ = value;
}
inline void PlayerBaseData::set_exp(int32_t value) {
  _internal_set_exp(value);
  // @@protoc_insertion_point(field_set:PlayerBaseData.exp)
}

// uint64 sessionId = 11;
inline void PlayerBaseData::clear_sessionid() {
  sessionid_ = uint64_t{0u};
}
inline uint64_t PlayerBaseData::_internal_sessionid() const {
  return sessionid_;
}
inline uint64_t PlayerBaseData::sessionid() const {
  // @@protoc_insertion_point(field_get:PlayerBaseData.sessionId)
  return _internal_sessionid();
}
inline void PlayerBaseData::_internal_set_sessionid(uint64_t value) {
  
  sessionid_ = value;
}
inline void PlayerBaseData::set_sessionid(uint64_t value) {
  _internal_set_sessionid(value);
  // @@protoc_insertion_point(field_set:PlayerBaseData.sessionId)
}

// sint32 loginTime = 12;
inline void PlayerBaseData::clear_logintime() {
  logintime_ = 0;
}
inline int32_t PlayerBaseData::_internal_logintime() const {
  return logintime_;
}
inline int32_t PlayerBaseData::logintime() const {
  // @@protoc_insertion_point(field_get:PlayerBaseData.loginTime)
  return _internal_logintime();
}
inline void PlayerBaseData::_internal_set_logintime(int32_t value) {
  
  logintime_ = value;
}
inline void PlayerBaseData::set_logintime(int32_t value) {
  _internal_set_logintime(value);
  // @@protoc_insertion_point(field_set:PlayerBaseData.loginTime)
}

// uint64 guildId = 13;
inline void PlayerBaseData::clear_guildid() {
  guildid_ = uint64_t{0u};
}
inline uint64_t PlayerBaseData::_internal_guildid() const {
  return guildid_;
}
inline uint64_t PlayerBaseData::guildid() const {
  // @@protoc_insertion_point(field_get:PlayerBaseData.guildId)
  return _internal_guildid();
}
inline void PlayerBaseData::_internal_set_guildid(uint64_t value) {
  
  guildid_ = value;
}
inline void PlayerBaseData::set_guildid(uint64_t value) {
  _internal_set_guildid(value);
  // @@protoc_insertion_point(field_set:PlayerBaseData.guildId)
}

// sint32 chargeVal = 14;
inline void PlayerBaseData::clear_chargeval() {
  chargeval_ = 0;
}
inline int32_t PlayerBaseData::_internal_chargeval() const {
  return chargeval_;
}
inline int32_t PlayerBaseData::chargeval() const {
  // @@protoc_insertion_point(field_get:PlayerBaseData.chargeVal)
  return _internal_chargeval();
}
inline void PlayerBaseData::_internal_set_chargeval(int32_t value) {
  
  chargeval_ = value;
}
inline void PlayerBaseData::set_chargeval(int32_t value) {
  _internal_set_chargeval(value);
  // @@protoc_insertion_point(field_set:PlayerBaseData.chargeVal)
}

// sint32 headIcon = 15;
inline void PlayerBaseData::clear_headicon() {
  headicon_ = 0;
}
inline int32_t PlayerBaseData::_internal_headicon() const {
  return headicon_;
}
inline int32_t PlayerBaseData::headicon() const {
  // @@protoc_insertion_point(field_get:PlayerBaseData.headIcon)
  return _internal_headicon();
}
inline void PlayerBaseData::_internal_set_headicon(int32_t value) {
  
  headicon_ = value;
}
inline void PlayerBaseData::set_headicon(int32_t value) {
  _internal_set_headicon(value);
  // @@protoc_insertion_point(field_set:PlayerBaseData.headIcon)
}

// sint32 title = 16;
inline void PlayerBaseData::clear_title() {
  title_ = 0;
}
inline int32_t PlayerBaseData::_internal_title() const {
  return title_;
}
inline int32_t PlayerBaseData::title() const {
  // @@protoc_insertion_point(field_get:PlayerBaseData.title)
  return _internal_title();
}
inline void PlayerBaseData::_internal_set_title(int32_t value) {
  
  title_ = value;
}
inline void PlayerBaseData::set_title(int32_t value) {
  _internal_set_title(value);
  // @@protoc_insertion_point(field_set:PlayerBaseData.title)
}

// sint32 skin = 17;
inline void PlayerBaseData::clear_skin() {
  skin_ = 0;
}
inline int32_t PlayerBaseData::_internal_skin() const {
  return skin_;
}
inline int32_t PlayerBaseData::skin() const {
  // @@protoc_insertion_point(field_get:PlayerBaseData.skin)
  return _internal_skin();
}
inline void PlayerBaseData::_internal_set_skin(int32_t value) {
  
  skin_ = value;
}
inline void PlayerBaseData::set_skin(int32_t value) {
  _internal_set_skin(value);
  // @@protoc_insertion_point(field_set:PlayerBaseData.skin)
}

// bytes extra = 18;
inline void PlayerBaseData::clear_extra() {
  extra_.ClearToEmpty();
}
inline const std::string& PlayerBaseData::extra() const {
  // @@protoc_insertion_point(field_get:PlayerBaseData.extra)
  return _internal_extra();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PlayerBaseData::set_extra(ArgT0&& arg0, ArgT... args) {
 
 extra_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:PlayerBaseData.extra)
}
inline std::string* PlayerBaseData::mutable_extra() {
  std::string* _s = _internal_mutable_extra();
  // @@protoc_insertion_point(field_mutable:PlayerBaseData.extra)
  return _s;
}
inline const std::string& PlayerBaseData::_internal_extra() const {
  return extra_.Get();
}
inline void PlayerBaseData::_internal_set_extra(const std::string& value) {
  
  extra_.Set(value, GetArenaForAllocation());
}
inline std::string* PlayerBaseData::_internal_mutable_extra() {
  
  return extra_.Mutable(GetArenaForAllocation());
}
inline std::string* PlayerBaseData::release_extra() {
  // @@protoc_insertion_point(field_release:PlayerBaseData.extra)
  return extra_.Release();
}
inline void PlayerBaseData::set_allocated_extra(std::string* extra) {
  if (extra != nullptr) {
    
  } else {
    
  }
  extra_.SetAllocated(extra, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (extra_.IsDefault()) {
    extra_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:PlayerBaseData.extra)
}

// sint32 fromServerId = 19;
inline void PlayerBaseData::clear_fromserverid() {
  fromserverid_ = 0;
}
inline int32_t PlayerBaseData::_internal_fromserverid() const {
  return fromserverid_;
}
inline int32_t PlayerBaseData::fromserverid() const {
  // @@protoc_insertion_point(field_get:PlayerBaseData.fromServerId)
  return _internal_fromserverid();
}
inline void PlayerBaseData::_internal_set_fromserverid(int32_t value) {
  
  fromserverid_ = value;
}
inline void PlayerBaseData::set_fromserverid(int32_t value) {
  _internal_set_fromserverid(value);
  // @@protoc_insertion_point(field_set:PlayerBaseData.fromServerId)
}

// sint32 logoutTime = 20;
inline void PlayerBaseData::clear_logouttime() {
  logouttime_ = 0;
}
inline int32_t PlayerBaseData::_internal_logouttime() const {
  return logouttime_;
}
inline int32_t PlayerBaseData::logouttime() const {
  // @@protoc_insertion_point(field_get:PlayerBaseData.logoutTime)
  return _internal_logouttime();
}
inline void PlayerBaseData::_internal_set_logouttime(int32_t value) {
  
  logouttime_ = value;
}
inline void PlayerBaseData::set_logouttime(int32_t value) {
  _internal_set_logouttime(value);
  // @@protoc_insertion_point(field_set:PlayerBaseData.logoutTime)
}

// -------------------------------------------------------------------

// BagData

// uint64 guid = 1;
inline void BagData::clear_guid() {
  guid_ = uint64_t{0u};
}
inline uint64_t BagData::_internal_guid() const {
  return guid_;
}
inline uint64_t BagData::guid() const {
  // @@protoc_insertion_point(field_get:BagData.guid)
  return _internal_guid();
}
inline void BagData::_internal_set_guid(uint64_t value) {
  
  guid_ = value;
}
inline void BagData::set_guid(uint64_t value) {
  _internal_set_guid(value);
  // @@protoc_insertion_point(field_set:BagData.guid)
}

// uint32 itemId = 2;
inline void BagData::clear_itemid() {
  itemid_ = 0u;
}
inline uint32_t BagData::_internal_itemid() const {
  return itemid_;
}
inline uint32_t BagData::itemid() const {
  // @@protoc_insertion_point(field_get:BagData.itemId)
  return _internal_itemid();
}
inline void BagData::_internal_set_itemid(uint32_t value) {
  
  itemid_ = value;
}
inline void BagData::set_itemid(uint32_t value) {
  _internal_set_itemid(value);
  // @@protoc_insertion_point(field_set:BagData.itemId)
}

// uint64 count = 3;
inline void BagData::clear_count() {
  count_ = uint64_t{0u};
}
inline uint64_t BagData::_internal_count() const {
  return count_;
}
inline uint64_t BagData::count() const {
  // @@protoc_insertion_point(field_get:BagData.count)
  return _internal_count();
}
inline void BagData::_internal_set_count(uint64_t value) {
  
  count_ = value;
}
inline void BagData::set_count(uint64_t value) {
  _internal_set_count(value);
  // @@protoc_insertion_point(field_set:BagData.count)
}

// sint32 time = 4;
inline void BagData::clear_time() {
  time_ = 0;
}
inline int32_t BagData::_internal_time() const {
  return time_;
}
inline int32_t BagData::time() const {
  // @@protoc_insertion_point(field_get:BagData.time)
  return _internal_time();
}
inline void BagData::_internal_set_time(int32_t value) {
  
  time_ = value;
}
inline void BagData::set_time(int32_t value) {
  _internal_set_time(value);
  // @@protoc_insertion_point(field_set:BagData.time)
}

// sint32 level = 5;
inline void BagData::clear_level() {
  level_ = 0;
}
inline int32_t BagData::_internal_level() const {
  return level_;
}
inline int32_t BagData::level() const {
  // @@protoc_insertion_point(field_get:BagData.level)
  return _internal_level();
}
inline void BagData::_internal_set_level(int32_t value) {
  
  level_ = value;
}
inline void BagData::set_level(int32_t value) {
  _internal_set_level(value);
  // @@protoc_insertion_point(field_set:BagData.level)
}

// sint32 exp = 6;
inline void BagData::clear_exp() {
  exp_ = 0;
}
inline int32_t BagData::_internal_exp() const {
  return exp_;
}
inline int32_t BagData::exp() const {
  // @@protoc_insertion_point(field_get:BagData.exp)
  return _internal_exp();
}
inline void BagData::_internal_set_exp(int32_t value) {
  
  exp_ = value;
}
inline void BagData::set_exp(int32_t value) {
  _internal_set_exp(value);
  // @@protoc_insertion_point(field_set:BagData.exp)
}

// uint64 owner = 7;
inline void BagData::clear_owner() {
  owner_ = uint64_t{0u};
}
inline uint64_t BagData::_internal_owner() const {
  return owner_;
}
inline uint64_t BagData::owner() const {
  // @@protoc_insertion_point(field_get:BagData.owner)
  return _internal_owner();
}
inline void BagData::_internal_set_owner(uint64_t value) {
  
  owner_ = value;
}
inline void BagData::set_owner(uint64_t value) {
  _internal_set_owner(value);
  // @@protoc_insertion_point(field_set:BagData.owner)
}

// sint32 star = 8;
inline void BagData::clear_star() {
  star_ = 0;
}
inline int32_t BagData::_internal_star() const {
  return star_;
}
inline int32_t BagData::star() const {
  // @@protoc_insertion_point(field_get:BagData.star)
  return _internal_star();
}
inline void BagData::_internal_set_star(int32_t value) {
  
  star_ = value;
}
inline void BagData::set_star(int32_t value) {
  _internal_set_star(value);
  // @@protoc_insertion_point(field_set:BagData.star)
}

// sint32 step = 9;
inline void BagData::clear_step() {
  step_ = 0;
}
inline int32_t BagData::_internal_step() const {
  return step_;
}
inline int32_t BagData::step() const {
  // @@protoc_insertion_point(field_get:BagData.step)
  return _internal_step();
}
inline void BagData::_internal_set_step(int32_t value) {
  
  step_ = value;
}
inline void BagData::set_step(int32_t value) {
  _internal_set_step(value);
  // @@protoc_insertion_point(field_set:BagData.step)
}

// -------------------------------------------------------------------

// ResReturnPlayerBaseData

// uint64 pid = 1;
inline void ResReturnPlayerBaseData::clear_pid() {
  pid_ = uint64_t{0u};
}
inline uint64_t ResReturnPlayerBaseData::_internal_pid() const {
  return pid_;
}
inline uint64_t ResReturnPlayerBaseData::pid() const {
  // @@protoc_insertion_point(field_get:ResReturnPlayerBaseData.pid)
  return _internal_pid();
}
inline void ResReturnPlayerBaseData::_internal_set_pid(uint64_t value) {
  
  pid_ = value;
}
inline void ResReturnPlayerBaseData::set_pid(uint64_t value) {
  _internal_set_pid(value);
  // @@protoc_insertion_point(field_set:ResReturnPlayerBaseData.pid)
}

// .PlayerBaseData data = 2;
inline bool ResReturnPlayerBaseData::_internal_has_data() const {
  return this != internal_default_instance() && data_ != nullptr;
}
inline bool ResReturnPlayerBaseData::has_data() const {
  return _internal_has_data();
}
inline void ResReturnPlayerBaseData::clear_data() {
  if (GetArenaForAllocation() == nullptr && data_ != nullptr) {
    delete data_;
  }
  data_ = nullptr;
}
inline const ::PlayerBaseData& ResReturnPlayerBaseData::_internal_data() const {
  const ::PlayerBaseData* p = data_;
  return p != nullptr ? *p : reinterpret_cast<const ::PlayerBaseData&>(
      ::_PlayerBaseData_default_instance_);
}
inline const ::PlayerBaseData& ResReturnPlayerBaseData::data() const {
  // @@protoc_insertion_point(field_get:ResReturnPlayerBaseData.data)
  return _internal_data();
}
inline void ResReturnPlayerBaseData::unsafe_arena_set_allocated_data(
    ::PlayerBaseData* data) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(data_);
  }
  data_ = data;
  if (data) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ResReturnPlayerBaseData.data)
}
inline ::PlayerBaseData* ResReturnPlayerBaseData::release_data() {
  
  ::PlayerBaseData* temp = data_;
  data_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PlayerBaseData* ResReturnPlayerBaseData::unsafe_arena_release_data() {
  // @@protoc_insertion_point(field_release:ResReturnPlayerBaseData.data)
  
  ::PlayerBaseData* temp = data_;
  data_ = nullptr;
  return temp;
}
inline ::PlayerBaseData* ResReturnPlayerBaseData::_internal_mutable_data() {
  
  if (data_ == nullptr) {
    auto* p = CreateMaybeMessage<::PlayerBaseData>(GetArenaForAllocation());
    data_ = p;
  }
  return data_;
}
inline ::PlayerBaseData* ResReturnPlayerBaseData::mutable_data() {
  ::PlayerBaseData* _msg = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:ResReturnPlayerBaseData.data)
  return _msg;
}
inline void ResReturnPlayerBaseData::set_allocated_data(::PlayerBaseData* data) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete data_;
  }
  if (data) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(data);
    if (message_arena != submessage_arena) {
      data = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, data, submessage_arena);
    }
    
  } else {
    
  }
  data_ = data;
  // @@protoc_insertion_point(field_set_allocated:ResReturnPlayerBaseData.data)
}

// uint64 csessionId = 3;
inline void ResReturnPlayerBaseData::clear_csessionid() {
  csessionid_ = uint64_t{0u};
}
inline uint64_t ResReturnPlayerBaseData::_internal_csessionid() const {
  return csessionid_;
}
inline uint64_t ResReturnPlayerBaseData::csessionid() const {
  // @@protoc_insertion_point(field_get:ResReturnPlayerBaseData.csessionId)
  return _internal_csessionid();
}
inline void ResReturnPlayerBaseData::_internal_set_csessionid(uint64_t value) {
  
  csessionid_ = value;
}
inline void ResReturnPlayerBaseData::set_csessionid(uint64_t value) {
  _internal_set_csessionid(value);
  // @@protoc_insertion_point(field_set:ResReturnPlayerBaseData.csessionId)
}

// uint64 sessionId = 4;
inline void ResReturnPlayerBaseData::clear_sessionid() {
  sessionid_ = uint64_t{0u};
}
inline uint64_t ResReturnPlayerBaseData::_internal_sessionid() const {
  return sessionid_;
}
inline uint64_t ResReturnPlayerBaseData::sessionid() const {
  // @@protoc_insertion_point(field_get:ResReturnPlayerBaseData.sessionId)
  return _internal_sessionid();
}
inline void ResReturnPlayerBaseData::_internal_set_sessionid(uint64_t value) {
  
  sessionid_ = value;
}
inline void ResReturnPlayerBaseData::set_sessionid(uint64_t value) {
  _internal_set_sessionid(value);
  // @@protoc_insertion_point(field_set:ResReturnPlayerBaseData.sessionId)
}

// -------------------------------------------------------------------

// ResReturnPlayerBagData

// uint64 pid = 1;
inline void ResReturnPlayerBagData::clear_pid() {
  pid_ = uint64_t{0u};
}
inline uint64_t ResReturnPlayerBagData::_internal_pid() const {
  return pid_;
}
inline uint64_t ResReturnPlayerBagData::pid() const {
  // @@protoc_insertion_point(field_get:ResReturnPlayerBagData.pid)
  return _internal_pid();
}
inline void ResReturnPlayerBagData::_internal_set_pid(uint64_t value) {
  
  pid_ = value;
}
inline void ResReturnPlayerBagData::set_pid(uint64_t value) {
  _internal_set_pid(value);
  // @@protoc_insertion_point(field_set:ResReturnPlayerBagData.pid)
}

// repeated .BagData data = 2;
inline int ResReturnPlayerBagData::_internal_data_size() const {
  return data_.size();
}
inline int ResReturnPlayerBagData::data_size() const {
  return _internal_data_size();
}
inline void ResReturnPlayerBagData::clear_data() {
  data_.Clear();
}
inline ::BagData* ResReturnPlayerBagData::mutable_data(int index) {
  // @@protoc_insertion_point(field_mutable:ResReturnPlayerBagData.data)
  return data_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::BagData >*
ResReturnPlayerBagData::mutable_data() {
  // @@protoc_insertion_point(field_mutable_list:ResReturnPlayerBagData.data)
  return &data_;
}
inline const ::BagData& ResReturnPlayerBagData::_internal_data(int index) const {
  return data_.Get(index);
}
inline const ::BagData& ResReturnPlayerBagData::data(int index) const {
  // @@protoc_insertion_point(field_get:ResReturnPlayerBagData.data)
  return _internal_data(index);
}
inline ::BagData* ResReturnPlayerBagData::_internal_add_data() {
  return data_.Add();
}
inline ::BagData* ResReturnPlayerBagData::add_data() {
  ::BagData* _add = _internal_add_data();
  // @@protoc_insertion_point(field_add:ResReturnPlayerBagData.data)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::BagData >&
ResReturnPlayerBagData::data() const {
  // @@protoc_insertion_point(field_list:ResReturnPlayerBagData.data)
  return data_;
}

// uint64 csessionId = 3;
inline void ResReturnPlayerBagData::clear_csessionid() {
  csessionid_ = uint64_t{0u};
}
inline uint64_t ResReturnPlayerBagData::_internal_csessionid() const {
  return csessionid_;
}
inline uint64_t ResReturnPlayerBagData::csessionid() const {
  // @@protoc_insertion_point(field_get:ResReturnPlayerBagData.csessionId)
  return _internal_csessionid();
}
inline void ResReturnPlayerBagData::_internal_set_csessionid(uint64_t value) {
  
  csessionid_ = value;
}
inline void ResReturnPlayerBagData::set_csessionid(uint64_t value) {
  _internal_set_csessionid(value);
  // @@protoc_insertion_point(field_set:ResReturnPlayerBagData.csessionId)
}

// uint64 sessionId = 4;
inline void ResReturnPlayerBagData::clear_sessionid() {
  sessionid_ = uint64_t{0u};
}
inline uint64_t ResReturnPlayerBagData::_internal_sessionid() const {
  return sessionid_;
}
inline uint64_t ResReturnPlayerBagData::sessionid() const {
  // @@protoc_insertion_point(field_get:ResReturnPlayerBagData.sessionId)
  return _internal_sessionid();
}
inline void ResReturnPlayerBagData::_internal_set_sessionid(uint64_t value) {
  
  sessionid_ = value;
}
inline void ResReturnPlayerBagData::set_sessionid(uint64_t value) {
  _internal_set_sessionid(value);
  // @@protoc_insertion_point(field_set:ResReturnPlayerBagData.sessionId)
}

// -------------------------------------------------------------------

// ResReturnPlayerModuleData

// sint32 moduleId = 1;
inline void ResReturnPlayerModuleData::clear_moduleid() {
  moduleid_ = 0;
}
inline int32_t ResReturnPlayerModuleData::_internal_moduleid() const {
  return moduleid_;
}
inline int32_t ResReturnPlayerModuleData::moduleid() const {
  // @@protoc_insertion_point(field_get:ResReturnPlayerModuleData.moduleId)
  return _internal_moduleid();
}
inline void ResReturnPlayerModuleData::_internal_set_moduleid(int32_t value) {
  
  moduleid_ = value;
}
inline void ResReturnPlayerModuleData::set_moduleid(int32_t value) {
  _internal_set_moduleid(value);
  // @@protoc_insertion_point(field_set:ResReturnPlayerModuleData.moduleId)
}

// bytes data = 2;
inline void ResReturnPlayerModuleData::clear_data() {
  data_.ClearToEmpty();
}
inline const std::string& ResReturnPlayerModuleData::data() const {
  // @@protoc_insertion_point(field_get:ResReturnPlayerModuleData.data)
  return _internal_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ResReturnPlayerModuleData::set_data(ArgT0&& arg0, ArgT... args) {
 
 data_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ResReturnPlayerModuleData.data)
}
inline std::string* ResReturnPlayerModuleData::mutable_data() {
  std::string* _s = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:ResReturnPlayerModuleData.data)
  return _s;
}
inline const std::string& ResReturnPlayerModuleData::_internal_data() const {
  return data_.Get();
}
inline void ResReturnPlayerModuleData::_internal_set_data(const std::string& value) {
  
  data_.Set(value, GetArenaForAllocation());
}
inline std::string* ResReturnPlayerModuleData::_internal_mutable_data() {
  
  return data_.Mutable(GetArenaForAllocation());
}
inline std::string* ResReturnPlayerModuleData::release_data() {
  // @@protoc_insertion_point(field_release:ResReturnPlayerModuleData.data)
  return data_.Release();
}
inline void ResReturnPlayerModuleData::set_allocated_data(std::string* data) {
  if (data != nullptr) {
    
  } else {
    
  }
  data_.SetAllocated(data, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (data_.IsDefault()) {
    data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ResReturnPlayerModuleData.data)
}

// uint64 csessionId = 3;
inline void ResReturnPlayerModuleData::clear_csessionid() {
  csessionid_ = uint64_t{0u};
}
inline uint64_t ResReturnPlayerModuleData::_internal_csessionid() const {
  return csessionid_;
}
inline uint64_t ResReturnPlayerModuleData::csessionid() const {
  // @@protoc_insertion_point(field_get:ResReturnPlayerModuleData.csessionId)
  return _internal_csessionid();
}
inline void ResReturnPlayerModuleData::_internal_set_csessionid(uint64_t value) {
  
  csessionid_ = value;
}
inline void ResReturnPlayerModuleData::set_csessionid(uint64_t value) {
  _internal_set_csessionid(value);
  // @@protoc_insertion_point(field_set:ResReturnPlayerModuleData.csessionId)
}

// uint64 sessionId = 4;
inline void ResReturnPlayerModuleData::clear_sessionid() {
  sessionid_ = uint64_t{0u};
}
inline uint64_t ResReturnPlayerModuleData::_internal_sessionid() const {
  return sessionid_;
}
inline uint64_t ResReturnPlayerModuleData::sessionid() const {
  // @@protoc_insertion_point(field_get:ResReturnPlayerModuleData.sessionId)
  return _internal_sessionid();
}
inline void ResReturnPlayerModuleData::_internal_set_sessionid(uint64_t value) {
  
  sessionid_ = value;
}
inline void ResReturnPlayerModuleData::set_sessionid(uint64_t value) {
  _internal_set_sessionid(value);
  // @@protoc_insertion_point(field_set:ResReturnPlayerModuleData.sessionId)
}

// -------------------------------------------------------------------

// ReqSavePlayerBaseData

// uint64 pid = 1;
inline void ReqSavePlayerBaseData::clear_pid() {
  pid_ = uint64_t{0u};
}
inline uint64_t ReqSavePlayerBaseData::_internal_pid() const {
  return pid_;
}
inline uint64_t ReqSavePlayerBaseData::pid() const {
  // @@protoc_insertion_point(field_get:ReqSavePlayerBaseData.pid)
  return _internal_pid();
}
inline void ReqSavePlayerBaseData::_internal_set_pid(uint64_t value) {
  
  pid_ = value;
}
inline void ReqSavePlayerBaseData::set_pid(uint64_t value) {
  _internal_set_pid(value);
  // @@protoc_insertion_point(field_set:ReqSavePlayerBaseData.pid)
}

// .PlayerBaseData data = 2;
inline bool ReqSavePlayerBaseData::_internal_has_data() const {
  return this != internal_default_instance() && data_ != nullptr;
}
inline bool ReqSavePlayerBaseData::has_data() const {
  return _internal_has_data();
}
inline void ReqSavePlayerBaseData::clear_data() {
  if (GetArenaForAllocation() == nullptr && data_ != nullptr) {
    delete data_;
  }
  data_ = nullptr;
}
inline const ::PlayerBaseData& ReqSavePlayerBaseData::_internal_data() const {
  const ::PlayerBaseData* p = data_;
  return p != nullptr ? *p : reinterpret_cast<const ::PlayerBaseData&>(
      ::_PlayerBaseData_default_instance_);
}
inline const ::PlayerBaseData& ReqSavePlayerBaseData::data() const {
  // @@protoc_insertion_point(field_get:ReqSavePlayerBaseData.data)
  return _internal_data();
}
inline void ReqSavePlayerBaseData::unsafe_arena_set_allocated_data(
    ::PlayerBaseData* data) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(data_);
  }
  data_ = data;
  if (data) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ReqSavePlayerBaseData.data)
}
inline ::PlayerBaseData* ReqSavePlayerBaseData::release_data() {
  
  ::PlayerBaseData* temp = data_;
  data_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PlayerBaseData* ReqSavePlayerBaseData::unsafe_arena_release_data() {
  // @@protoc_insertion_point(field_release:ReqSavePlayerBaseData.data)
  
  ::PlayerBaseData* temp = data_;
  data_ = nullptr;
  return temp;
}
inline ::PlayerBaseData* ReqSavePlayerBaseData::_internal_mutable_data() {
  
  if (data_ == nullptr) {
    auto* p = CreateMaybeMessage<::PlayerBaseData>(GetArenaForAllocation());
    data_ = p;
  }
  return data_;
}
inline ::PlayerBaseData* ReqSavePlayerBaseData::mutable_data() {
  ::PlayerBaseData* _msg = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:ReqSavePlayerBaseData.data)
  return _msg;
}
inline void ReqSavePlayerBaseData::set_allocated_data(::PlayerBaseData* data) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete data_;
  }
  if (data) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(data);
    if (message_arena != submessage_arena) {
      data = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, data, submessage_arena);
    }
    
  } else {
    
  }
  data_ = data;
  // @@protoc_insertion_point(field_set_allocated:ReqSavePlayerBaseData.data)
}

// -------------------------------------------------------------------

// ReqSavePlayerBagData

// uint64 pid = 1;
inline void ReqSavePlayerBagData::clear_pid() {
  pid_ = uint64_t{0u};
}
inline uint64_t ReqSavePlayerBagData::_internal_pid() const {
  return pid_;
}
inline uint64_t ReqSavePlayerBagData::pid() const {
  // @@protoc_insertion_point(field_get:ReqSavePlayerBagData.pid)
  return _internal_pid();
}
inline void ReqSavePlayerBagData::_internal_set_pid(uint64_t value) {
  
  pid_ = value;
}
inline void ReqSavePlayerBagData::set_pid(uint64_t value) {
  _internal_set_pid(value);
  // @@protoc_insertion_point(field_set:ReqSavePlayerBagData.pid)
}

// repeated .BagData data = 2;
inline int ReqSavePlayerBagData::_internal_data_size() const {
  return data_.size();
}
inline int ReqSavePlayerBagData::data_size() const {
  return _internal_data_size();
}
inline void ReqSavePlayerBagData::clear_data() {
  data_.Clear();
}
inline ::BagData* ReqSavePlayerBagData::mutable_data(int index) {
  // @@protoc_insertion_point(field_mutable:ReqSavePlayerBagData.data)
  return data_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::BagData >*
ReqSavePlayerBagData::mutable_data() {
  // @@protoc_insertion_point(field_mutable_list:ReqSavePlayerBagData.data)
  return &data_;
}
inline const ::BagData& ReqSavePlayerBagData::_internal_data(int index) const {
  return data_.Get(index);
}
inline const ::BagData& ReqSavePlayerBagData::data(int index) const {
  // @@protoc_insertion_point(field_get:ReqSavePlayerBagData.data)
  return _internal_data(index);
}
inline ::BagData* ReqSavePlayerBagData::_internal_add_data() {
  return data_.Add();
}
inline ::BagData* ReqSavePlayerBagData::add_data() {
  ::BagData* _add = _internal_add_data();
  // @@protoc_insertion_point(field_add:ReqSavePlayerBagData.data)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::BagData >&
ReqSavePlayerBagData::data() const {
  // @@protoc_insertion_point(field_list:ReqSavePlayerBagData.data)
  return data_;
}

// -------------------------------------------------------------------

// ReqSavePlayerModuleData

// uint64 pid = 1;
inline void ReqSavePlayerModuleData::clear_pid() {
  pid_ = uint64_t{0u};
}
inline uint64_t ReqSavePlayerModuleData::_internal_pid() const {
  return pid_;
}
inline uint64_t ReqSavePlayerModuleData::pid() const {
  // @@protoc_insertion_point(field_get:ReqSavePlayerModuleData.pid)
  return _internal_pid();
}
inline void ReqSavePlayerModuleData::_internal_set_pid(uint64_t value) {
  
  pid_ = value;
}
inline void ReqSavePlayerModuleData::set_pid(uint64_t value) {
  _internal_set_pid(value);
  // @@protoc_insertion_point(field_set:ReqSavePlayerModuleData.pid)
}

// sint32 moduleId = 2;
inline void ReqSavePlayerModuleData::clear_moduleid() {
  moduleid_ = 0;
}
inline int32_t ReqSavePlayerModuleData::_internal_moduleid() const {
  return moduleid_;
}
inline int32_t ReqSavePlayerModuleData::moduleid() const {
  // @@protoc_insertion_point(field_get:ReqSavePlayerModuleData.moduleId)
  return _internal_moduleid();
}
inline void ReqSavePlayerModuleData::_internal_set_moduleid(int32_t value) {
  
  moduleid_ = value;
}
inline void ReqSavePlayerModuleData::set_moduleid(int32_t value) {
  _internal_set_moduleid(value);
  // @@protoc_insertion_point(field_set:ReqSavePlayerModuleData.moduleId)
}

// bytes data = 3;
inline void ReqSavePlayerModuleData::clear_data() {
  data_.ClearToEmpty();
}
inline const std::string& ReqSavePlayerModuleData::data() const {
  // @@protoc_insertion_point(field_get:ReqSavePlayerModuleData.data)
  return _internal_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ReqSavePlayerModuleData::set_data(ArgT0&& arg0, ArgT... args) {
 
 data_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ReqSavePlayerModuleData.data)
}
inline std::string* ReqSavePlayerModuleData::mutable_data() {
  std::string* _s = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:ReqSavePlayerModuleData.data)
  return _s;
}
inline const std::string& ReqSavePlayerModuleData::_internal_data() const {
  return data_.Get();
}
inline void ReqSavePlayerModuleData::_internal_set_data(const std::string& value) {
  
  data_.Set(value, GetArenaForAllocation());
}
inline std::string* ReqSavePlayerModuleData::_internal_mutable_data() {
  
  return data_.Mutable(GetArenaForAllocation());
}
inline std::string* ReqSavePlayerModuleData::release_data() {
  // @@protoc_insertion_point(field_release:ReqSavePlayerModuleData.data)
  return data_.Release();
}
inline void ReqSavePlayerModuleData::set_allocated_data(std::string* data) {
  if (data != nullptr) {
    
  } else {
    
  }
  data_.SetAllocated(data, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (data_.IsDefault()) {
    data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ReqSavePlayerModuleData.data)
}

// sint32 serverId = 4;
inline void ReqSavePlayerModuleData::clear_serverid() {
  serverid_ = 0;
}
inline int32_t ReqSavePlayerModuleData::_internal_serverid() const {
  return serverid_;
}
inline int32_t ReqSavePlayerModuleData::serverid() const {
  // @@protoc_insertion_point(field_get:ReqSavePlayerModuleData.serverId)
  return _internal_serverid();
}
inline void ReqSavePlayerModuleData::_internal_set_serverid(int32_t value) {
  
  serverid_ = value;
}
inline void ReqSavePlayerModuleData::set_serverid(int32_t value) {
  _internal_set_serverid(value);
  // @@protoc_insertion_point(field_set:ReqSavePlayerModuleData.serverId)
}

// -------------------------------------------------------------------

// ReqSendGmToGame

// string cmd = 1;
inline void ReqSendGmToGame::clear_cmd() {
  cmd_.ClearToEmpty();
}
inline const std::string& ReqSendGmToGame::cmd() const {
  // @@protoc_insertion_point(field_get:ReqSendGmToGame.cmd)
  return _internal_cmd();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ReqSendGmToGame::set_cmd(ArgT0&& arg0, ArgT... args) {
 
 cmd_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ReqSendGmToGame.cmd)
}
inline std::string* ReqSendGmToGame::mutable_cmd() {
  std::string* _s = _internal_mutable_cmd();
  // @@protoc_insertion_point(field_mutable:ReqSendGmToGame.cmd)
  return _s;
}
inline const std::string& ReqSendGmToGame::_internal_cmd() const {
  return cmd_.Get();
}
inline void ReqSendGmToGame::_internal_set_cmd(const std::string& value) {
  
  cmd_.Set(value, GetArenaForAllocation());
}
inline std::string* ReqSendGmToGame::_internal_mutable_cmd() {
  
  return cmd_.Mutable(GetArenaForAllocation());
}
inline std::string* ReqSendGmToGame::release_cmd() {
  // @@protoc_insertion_point(field_release:ReqSendGmToGame.cmd)
  return cmd_.Release();
}
inline void ReqSendGmToGame::set_allocated_cmd(std::string* cmd) {
  if (cmd != nullptr) {
    
  } else {
    
  }
  cmd_.SetAllocated(cmd, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (cmd_.IsDefault()) {
    cmd_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ReqSendGmToGame.cmd)
}

// -------------------------------------------------------------------

// ReqGameReport

// sint32 serverId = 1;
inline void ReqGameReport::clear_serverid() {
  serverid_ = 0;
}
inline int32_t ReqGameReport::_internal_serverid() const {
  return serverid_;
}
inline int32_t ReqGameReport::serverid() const {
  // @@protoc_insertion_point(field_get:ReqGameReport.serverId)
  return _internal_serverid();
}
inline void ReqGameReport::_internal_set_serverid(int32_t value) {
  
  serverid_ = value;
}
inline void ReqGameReport::set_serverid(int32_t value) {
  _internal_set_serverid(value);
  // @@protoc_insertion_point(field_set:ReqGameReport.serverId)
}

// -------------------------------------------------------------------

// ReqGameQuit

// -------------------------------------------------------------------

// LogItems

// sint32 id = 1;
inline void LogItems::clear_id() {
  id_ = 0;
}
inline int32_t LogItems::_internal_id() const {
  return id_;
}
inline int32_t LogItems::id() const {
  // @@protoc_insertion_point(field_get:LogItems.id)
  return _internal_id();
}
inline void LogItems::_internal_set_id(int32_t value) {
  
  id_ = value;
}
inline void LogItems::set_id(int32_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:LogItems.id)
}

// uint64 cnt = 2;
inline void LogItems::clear_cnt() {
  cnt_ = uint64_t{0u};
}
inline uint64_t LogItems::_internal_cnt() const {
  return cnt_;
}
inline uint64_t LogItems::cnt() const {
  // @@protoc_insertion_point(field_get:LogItems.cnt)
  return _internal_cnt();
}
inline void LogItems::_internal_set_cnt(uint64_t value) {
  
  cnt_ = value;
}
inline void LogItems::set_cnt(uint64_t value) {
  _internal_set_cnt(value);
  // @@protoc_insertion_point(field_set:LogItems.cnt)
}

// uint64 oldCnt = 3;
inline void LogItems::clear_oldcnt() {
  oldcnt_ = uint64_t{0u};
}
inline uint64_t LogItems::_internal_oldcnt() const {
  return oldcnt_;
}
inline uint64_t LogItems::oldcnt() const {
  // @@protoc_insertion_point(field_get:LogItems.oldCnt)
  return _internal_oldcnt();
}
inline void LogItems::_internal_set_oldcnt(uint64_t value) {
  
  oldcnt_ = value;
}
inline void LogItems::set_oldcnt(uint64_t value) {
  _internal_set_oldcnt(value);
  // @@protoc_insertion_point(field_set:LogItems.oldCnt)
}

// -------------------------------------------------------------------

// WriteLogData

// uint64 pid = 1;
inline void WriteLogData::clear_pid() {
  pid_ = uint64_t{0u};
}
inline uint64_t WriteLogData::_internal_pid() const {
  return pid_;
}
inline uint64_t WriteLogData::pid() const {
  // @@protoc_insertion_point(field_get:WriteLogData.pid)
  return _internal_pid();
}
inline void WriteLogData::_internal_set_pid(uint64_t value) {
  
  pid_ = value;
}
inline void WriteLogData::set_pid(uint64_t value) {
  _internal_set_pid(value);
  // @@protoc_insertion_point(field_set:WriteLogData.pid)
}

// string account = 2;
inline void WriteLogData::clear_account() {
  account_.ClearToEmpty();
}
inline const std::string& WriteLogData::account() const {
  // @@protoc_insertion_point(field_get:WriteLogData.account)
  return _internal_account();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void WriteLogData::set_account(ArgT0&& arg0, ArgT... args) {
 
 account_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:WriteLogData.account)
}
inline std::string* WriteLogData::mutable_account() {
  std::string* _s = _internal_mutable_account();
  // @@protoc_insertion_point(field_mutable:WriteLogData.account)
  return _s;
}
inline const std::string& WriteLogData::_internal_account() const {
  return account_.Get();
}
inline void WriteLogData::_internal_set_account(const std::string& value) {
  
  account_.Set(value, GetArenaForAllocation());
}
inline std::string* WriteLogData::_internal_mutable_account() {
  
  return account_.Mutable(GetArenaForAllocation());
}
inline std::string* WriteLogData::release_account() {
  // @@protoc_insertion_point(field_release:WriteLogData.account)
  return account_.Release();
}
inline void WriteLogData::set_allocated_account(std::string* account) {
  if (account != nullptr) {
    
  } else {
    
  }
  account_.SetAllocated(account, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (account_.IsDefault()) {
    account_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:WriteLogData.account)
}

// string pf = 3;
inline void WriteLogData::clear_pf() {
  pf_.ClearToEmpty();
}
inline const std::string& WriteLogData::pf() const {
  // @@protoc_insertion_point(field_get:WriteLogData.pf)
  return _internal_pf();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void WriteLogData::set_pf(ArgT0&& arg0, ArgT... args) {
 
 pf_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:WriteLogData.pf)
}
inline std::string* WriteLogData::mutable_pf() {
  std::string* _s = _internal_mutable_pf();
  // @@protoc_insertion_point(field_mutable:WriteLogData.pf)
  return _s;
}
inline const std::string& WriteLogData::_internal_pf() const {
  return pf_.Get();
}
inline void WriteLogData::_internal_set_pf(const std::string& value) {
  
  pf_.Set(value, GetArenaForAllocation());
}
inline std::string* WriteLogData::_internal_mutable_pf() {
  
  return pf_.Mutable(GetArenaForAllocation());
}
inline std::string* WriteLogData::release_pf() {
  // @@protoc_insertion_point(field_release:WriteLogData.pf)
  return pf_.Release();
}
inline void WriteLogData::set_allocated_pf(std::string* pf) {
  if (pf != nullptr) {
    
  } else {
    
  }
  pf_.SetAllocated(pf, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (pf_.IsDefault()) {
    pf_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:WriteLogData.pf)
}

// bytes desc = 4;
inline void WriteLogData::clear_desc() {
  desc_.ClearToEmpty();
}
inline const std::string& WriteLogData::desc() const {
  // @@protoc_insertion_point(field_get:WriteLogData.desc)
  return _internal_desc();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void WriteLogData::set_desc(ArgT0&& arg0, ArgT... args) {
 
 desc_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:WriteLogData.desc)
}
inline std::string* WriteLogData::mutable_desc() {
  std::string* _s = _internal_mutable_desc();
  // @@protoc_insertion_point(field_mutable:WriteLogData.desc)
  return _s;
}
inline const std::string& WriteLogData::_internal_desc() const {
  return desc_.Get();
}
inline void WriteLogData::_internal_set_desc(const std::string& value) {
  
  desc_.Set(value, GetArenaForAllocation());
}
inline std::string* WriteLogData::_internal_mutable_desc() {
  
  return desc_.Mutable(GetArenaForAllocation());
}
inline std::string* WriteLogData::release_desc() {
  // @@protoc_insertion_point(field_release:WriteLogData.desc)
  return desc_.Release();
}
inline void WriteLogData::set_allocated_desc(std::string* desc) {
  if (desc != nullptr) {
    
  } else {
    
  }
  desc_.SetAllocated(desc, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (desc_.IsDefault()) {
    desc_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:WriteLogData.desc)
}

// sint32 serverId = 5;
inline void WriteLogData::clear_serverid() {
  serverid_ = 0;
}
inline int32_t WriteLogData::_internal_serverid() const {
  return serverid_;
}
inline int32_t WriteLogData::serverid() const {
  // @@protoc_insertion_point(field_get:WriteLogData.serverId)
  return _internal_serverid();
}
inline void WriteLogData::_internal_set_serverid(int32_t value) {
  
  serverid_ = value;
}
inline void WriteLogData::set_serverid(int32_t value) {
  _internal_set_serverid(value);
  // @@protoc_insertion_point(field_set:WriteLogData.serverId)
}

// bytes extra = 6;
inline void WriteLogData::clear_extra() {
  extra_.ClearToEmpty();
}
inline const std::string& WriteLogData::extra() const {
  // @@protoc_insertion_point(field_get:WriteLogData.extra)
  return _internal_extra();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void WriteLogData::set_extra(ArgT0&& arg0, ArgT... args) {
 
 extra_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:WriteLogData.extra)
}
inline std::string* WriteLogData::mutable_extra() {
  std::string* _s = _internal_mutable_extra();
  // @@protoc_insertion_point(field_mutable:WriteLogData.extra)
  return _s;
}
inline const std::string& WriteLogData::_internal_extra() const {
  return extra_.Get();
}
inline void WriteLogData::_internal_set_extra(const std::string& value) {
  
  extra_.Set(value, GetArenaForAllocation());
}
inline std::string* WriteLogData::_internal_mutable_extra() {
  
  return extra_.Mutable(GetArenaForAllocation());
}
inline std::string* WriteLogData::release_extra() {
  // @@protoc_insertion_point(field_release:WriteLogData.extra)
  return extra_.Release();
}
inline void WriteLogData::set_allocated_extra(std::string* extra) {
  if (extra != nullptr) {
    
  } else {
    
  }
  extra_.SetAllocated(extra, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (extra_.IsDefault()) {
    extra_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:WriteLogData.extra)
}

// bytes name = 7;
inline void WriteLogData::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& WriteLogData::name() const {
  // @@protoc_insertion_point(field_get:WriteLogData.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void WriteLogData::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:WriteLogData.name)
}
inline std::string* WriteLogData::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:WriteLogData.name)
  return _s;
}
inline const std::string& WriteLogData::_internal_name() const {
  return name_.Get();
}
inline void WriteLogData::_internal_set_name(const std::string& value) {
  
  name_.Set(value, GetArenaForAllocation());
}
inline std::string* WriteLogData::_internal_mutable_name() {
  
  return name_.Mutable(GetArenaForAllocation());
}
inline std::string* WriteLogData::release_name() {
  // @@protoc_insertion_point(field_release:WriteLogData.name)
  return name_.Release();
}
inline void WriteLogData::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (name_.IsDefault()) {
    name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:WriteLogData.name)
}

// repeated .LogItems data = 8;
inline int WriteLogData::_internal_data_size() const {
  return data_.size();
}
inline int WriteLogData::data_size() const {
  return _internal_data_size();
}
inline void WriteLogData::clear_data() {
  data_.Clear();
}
inline ::LogItems* WriteLogData::mutable_data(int index) {
  // @@protoc_insertion_point(field_mutable:WriteLogData.data)
  return data_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::LogItems >*
WriteLogData::mutable_data() {
  // @@protoc_insertion_point(field_mutable_list:WriteLogData.data)
  return &data_;
}
inline const ::LogItems& WriteLogData::_internal_data(int index) const {
  return data_.Get(index);
}
inline const ::LogItems& WriteLogData::data(int index) const {
  // @@protoc_insertion_point(field_get:WriteLogData.data)
  return _internal_data(index);
}
inline ::LogItems* WriteLogData::_internal_add_data() {
  return data_.Add();
}
inline ::LogItems* WriteLogData::add_data() {
  ::LogItems* _add = _internal_add_data();
  // @@protoc_insertion_point(field_add:WriteLogData.data)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::LogItems >&
WriteLogData::data() const {
  // @@protoc_insertion_point(field_list:WriteLogData.data)
  return data_;
}

// -------------------------------------------------------------------

// LogMails

// uint64 mailId = 1;
inline void LogMails::clear_mailid() {
  mailid_ = uint64_t{0u};
}
inline uint64_t LogMails::_internal_mailid() const {
  return mailid_;
}
inline uint64_t LogMails::mailid() const {
  // @@protoc_insertion_point(field_get:LogMails.mailId)
  return _internal_mailid();
}
inline void LogMails::_internal_set_mailid(uint64_t value) {
  
  mailid_ = value;
}
inline void LogMails::set_mailid(uint64_t value) {
  _internal_set_mailid(value);
  // @@protoc_insertion_point(field_set:LogMails.mailId)
}

// bytes title = 2;
inline void LogMails::clear_title() {
  title_.ClearToEmpty();
}
inline const std::string& LogMails::title() const {
  // @@protoc_insertion_point(field_get:LogMails.title)
  return _internal_title();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LogMails::set_title(ArgT0&& arg0, ArgT... args) {
 
 title_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:LogMails.title)
}
inline std::string* LogMails::mutable_title() {
  std::string* _s = _internal_mutable_title();
  // @@protoc_insertion_point(field_mutable:LogMails.title)
  return _s;
}
inline const std::string& LogMails::_internal_title() const {
  return title_.Get();
}
inline void LogMails::_internal_set_title(const std::string& value) {
  
  title_.Set(value, GetArenaForAllocation());
}
inline std::string* LogMails::_internal_mutable_title() {
  
  return title_.Mutable(GetArenaForAllocation());
}
inline std::string* LogMails::release_title() {
  // @@protoc_insertion_point(field_release:LogMails.title)
  return title_.Release();
}
inline void LogMails::set_allocated_title(std::string* title) {
  if (title != nullptr) {
    
  } else {
    
  }
  title_.SetAllocated(title, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (title_.IsDefault()) {
    title_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:LogMails.title)
}

// bytes content = 3;
inline void LogMails::clear_content() {
  content_.ClearToEmpty();
}
inline const std::string& LogMails::content() const {
  // @@protoc_insertion_point(field_get:LogMails.content)
  return _internal_content();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LogMails::set_content(ArgT0&& arg0, ArgT... args) {
 
 content_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:LogMails.content)
}
inline std::string* LogMails::mutable_content() {
  std::string* _s = _internal_mutable_content();
  // @@protoc_insertion_point(field_mutable:LogMails.content)
  return _s;
}
inline const std::string& LogMails::_internal_content() const {
  return content_.Get();
}
inline void LogMails::_internal_set_content(const std::string& value) {
  
  content_.Set(value, GetArenaForAllocation());
}
inline std::string* LogMails::_internal_mutable_content() {
  
  return content_.Mutable(GetArenaForAllocation());
}
inline std::string* LogMails::release_content() {
  // @@protoc_insertion_point(field_release:LogMails.content)
  return content_.Release();
}
inline void LogMails::set_allocated_content(std::string* content) {
  if (content != nullptr) {
    
  } else {
    
  }
  content_.SetAllocated(content, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (content_.IsDefault()) {
    content_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:LogMails.content)
}

// string reward = 4;
inline void LogMails::clear_reward() {
  reward_.ClearToEmpty();
}
inline const std::string& LogMails::reward() const {
  // @@protoc_insertion_point(field_get:LogMails.reward)
  return _internal_reward();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LogMails::set_reward(ArgT0&& arg0, ArgT... args) {
 
 reward_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:LogMails.reward)
}
inline std::string* LogMails::mutable_reward() {
  std::string* _s = _internal_mutable_reward();
  // @@protoc_insertion_point(field_mutable:LogMails.reward)
  return _s;
}
inline const std::string& LogMails::_internal_reward() const {
  return reward_.Get();
}
inline void LogMails::_internal_set_reward(const std::string& value) {
  
  reward_.Set(value, GetArenaForAllocation());
}
inline std::string* LogMails::_internal_mutable_reward() {
  
  return reward_.Mutable(GetArenaForAllocation());
}
inline std::string* LogMails::release_reward() {
  // @@protoc_insertion_point(field_release:LogMails.reward)
  return reward_.Release();
}
inline void LogMails::set_allocated_reward(std::string* reward) {
  if (reward != nullptr) {
    
  } else {
    
  }
  reward_.SetAllocated(reward, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (reward_.IsDefault()) {
    reward_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:LogMails.reward)
}

// bytes desc = 5;
inline void LogMails::clear_desc() {
  desc_.ClearToEmpty();
}
inline const std::string& LogMails::desc() const {
  // @@protoc_insertion_point(field_get:LogMails.desc)
  return _internal_desc();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LogMails::set_desc(ArgT0&& arg0, ArgT... args) {
 
 desc_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:LogMails.desc)
}
inline std::string* LogMails::mutable_desc() {
  std::string* _s = _internal_mutable_desc();
  // @@protoc_insertion_point(field_mutable:LogMails.desc)
  return _s;
}
inline const std::string& LogMails::_internal_desc() const {
  return desc_.Get();
}
inline void LogMails::_internal_set_desc(const std::string& value) {
  
  desc_.Set(value, GetArenaForAllocation());
}
inline std::string* LogMails::_internal_mutable_desc() {
  
  return desc_.Mutable(GetArenaForAllocation());
}
inline std::string* LogMails::release_desc() {
  // @@protoc_insertion_point(field_release:LogMails.desc)
  return desc_.Release();
}
inline void LogMails::set_allocated_desc(std::string* desc) {
  if (desc != nullptr) {
    
  } else {
    
  }
  desc_.SetAllocated(desc, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (desc_.IsDefault()) {
    desc_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:LogMails.desc)
}

// sint32 expireTime = 6;
inline void LogMails::clear_expiretime() {
  expiretime_ = 0;
}
inline int32_t LogMails::_internal_expiretime() const {
  return expiretime_;
}
inline int32_t LogMails::expiretime() const {
  // @@protoc_insertion_point(field_get:LogMails.expireTime)
  return _internal_expiretime();
}
inline void LogMails::_internal_set_expiretime(int32_t value) {
  
  expiretime_ = value;
}
inline void LogMails::set_expiretime(int32_t value) {
  _internal_set_expiretime(value);
  // @@protoc_insertion_point(field_set:LogMails.expireTime)
}

// bytes extra = 7;
inline void LogMails::clear_extra() {
  extra_.ClearToEmpty();
}
inline const std::string& LogMails::extra() const {
  // @@protoc_insertion_point(field_get:LogMails.extra)
  return _internal_extra();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LogMails::set_extra(ArgT0&& arg0, ArgT... args) {
 
 extra_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:LogMails.extra)
}
inline std::string* LogMails::mutable_extra() {
  std::string* _s = _internal_mutable_extra();
  // @@protoc_insertion_point(field_mutable:LogMails.extra)
  return _s;
}
inline const std::string& LogMails::_internal_extra() const {
  return extra_.Get();
}
inline void LogMails::_internal_set_extra(const std::string& value) {
  
  extra_.Set(value, GetArenaForAllocation());
}
inline std::string* LogMails::_internal_mutable_extra() {
  
  return extra_.Mutable(GetArenaForAllocation());
}
inline std::string* LogMails::release_extra() {
  // @@protoc_insertion_point(field_release:LogMails.extra)
  return extra_.Release();
}
inline void LogMails::set_allocated_extra(std::string* extra) {
  if (extra != nullptr) {
    
  } else {
    
  }
  extra_.SetAllocated(extra, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (extra_.IsDefault()) {
    extra_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:LogMails.extra)
}

// -------------------------------------------------------------------

// WriteMailData

// uint64 pid = 1;
inline void WriteMailData::clear_pid() {
  pid_ = uint64_t{0u};
}
inline uint64_t WriteMailData::_internal_pid() const {
  return pid_;
}
inline uint64_t WriteMailData::pid() const {
  // @@protoc_insertion_point(field_get:WriteMailData.pid)
  return _internal_pid();
}
inline void WriteMailData::_internal_set_pid(uint64_t value) {
  
  pid_ = value;
}
inline void WriteMailData::set_pid(uint64_t value) {
  _internal_set_pid(value);
  // @@protoc_insertion_point(field_set:WriteMailData.pid)
}

// string account = 2;
inline void WriteMailData::clear_account() {
  account_.ClearToEmpty();
}
inline const std::string& WriteMailData::account() const {
  // @@protoc_insertion_point(field_get:WriteMailData.account)
  return _internal_account();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void WriteMailData::set_account(ArgT0&& arg0, ArgT... args) {
 
 account_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:WriteMailData.account)
}
inline std::string* WriteMailData::mutable_account() {
  std::string* _s = _internal_mutable_account();
  // @@protoc_insertion_point(field_mutable:WriteMailData.account)
  return _s;
}
inline const std::string& WriteMailData::_internal_account() const {
  return account_.Get();
}
inline void WriteMailData::_internal_set_account(const std::string& value) {
  
  account_.Set(value, GetArenaForAllocation());
}
inline std::string* WriteMailData::_internal_mutable_account() {
  
  return account_.Mutable(GetArenaForAllocation());
}
inline std::string* WriteMailData::release_account() {
  // @@protoc_insertion_point(field_release:WriteMailData.account)
  return account_.Release();
}
inline void WriteMailData::set_allocated_account(std::string* account) {
  if (account != nullptr) {
    
  } else {
    
  }
  account_.SetAllocated(account, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (account_.IsDefault()) {
    account_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:WriteMailData.account)
}

// string pf = 3;
inline void WriteMailData::clear_pf() {
  pf_.ClearToEmpty();
}
inline const std::string& WriteMailData::pf() const {
  // @@protoc_insertion_point(field_get:WriteMailData.pf)
  return _internal_pf();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void WriteMailData::set_pf(ArgT0&& arg0, ArgT... args) {
 
 pf_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:WriteMailData.pf)
}
inline std::string* WriteMailData::mutable_pf() {
  std::string* _s = _internal_mutable_pf();
  // @@protoc_insertion_point(field_mutable:WriteMailData.pf)
  return _s;
}
inline const std::string& WriteMailData::_internal_pf() const {
  return pf_.Get();
}
inline void WriteMailData::_internal_set_pf(const std::string& value) {
  
  pf_.Set(value, GetArenaForAllocation());
}
inline std::string* WriteMailData::_internal_mutable_pf() {
  
  return pf_.Mutable(GetArenaForAllocation());
}
inline std::string* WriteMailData::release_pf() {
  // @@protoc_insertion_point(field_release:WriteMailData.pf)
  return pf_.Release();
}
inline void WriteMailData::set_allocated_pf(std::string* pf) {
  if (pf != nullptr) {
    
  } else {
    
  }
  pf_.SetAllocated(pf, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (pf_.IsDefault()) {
    pf_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:WriteMailData.pf)
}

// sint32 serverId = 4;
inline void WriteMailData::clear_serverid() {
  serverid_ = 0;
}
inline int32_t WriteMailData::_internal_serverid() const {
  return serverid_;
}
inline int32_t WriteMailData::serverid() const {
  // @@protoc_insertion_point(field_get:WriteMailData.serverId)
  return _internal_serverid();
}
inline void WriteMailData::_internal_set_serverid(int32_t value) {
  
  serverid_ = value;
}
inline void WriteMailData::set_serverid(int32_t value) {
  _internal_set_serverid(value);
  // @@protoc_insertion_point(field_set:WriteMailData.serverId)
}

// bytes name = 5;
inline void WriteMailData::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& WriteMailData::name() const {
  // @@protoc_insertion_point(field_get:WriteMailData.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void WriteMailData::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:WriteMailData.name)
}
inline std::string* WriteMailData::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:WriteMailData.name)
  return _s;
}
inline const std::string& WriteMailData::_internal_name() const {
  return name_.Get();
}
inline void WriteMailData::_internal_set_name(const std::string& value) {
  
  name_.Set(value, GetArenaForAllocation());
}
inline std::string* WriteMailData::_internal_mutable_name() {
  
  return name_.Mutable(GetArenaForAllocation());
}
inline std::string* WriteMailData::release_name() {
  // @@protoc_insertion_point(field_release:WriteMailData.name)
  return name_.Release();
}
inline void WriteMailData::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (name_.IsDefault()) {
    name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:WriteMailData.name)
}

// repeated .LogMails data = 6;
inline int WriteMailData::_internal_data_size() const {
  return data_.size();
}
inline int WriteMailData::data_size() const {
  return _internal_data_size();
}
inline void WriteMailData::clear_data() {
  data_.Clear();
}
inline ::LogMails* WriteMailData::mutable_data(int index) {
  // @@protoc_insertion_point(field_mutable:WriteMailData.data)
  return data_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::LogMails >*
WriteMailData::mutable_data() {
  // @@protoc_insertion_point(field_mutable_list:WriteMailData.data)
  return &data_;
}
inline const ::LogMails& WriteMailData::_internal_data(int index) const {
  return data_.Get(index);
}
inline const ::LogMails& WriteMailData::data(int index) const {
  // @@protoc_insertion_point(field_get:WriteMailData.data)
  return _internal_data(index);
}
inline ::LogMails* WriteMailData::_internal_add_data() {
  return data_.Add();
}
inline ::LogMails* WriteMailData::add_data() {
  ::LogMails* _add = _internal_add_data();
  // @@protoc_insertion_point(field_add:WriteMailData.data)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::LogMails >&
WriteMailData::data() const {
  // @@protoc_insertion_point(field_list:WriteMailData.data)
  return data_;
}

// -------------------------------------------------------------------

// ReqSelectRepeatedName

// string name = 1;
inline void ReqSelectRepeatedName::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& ReqSelectRepeatedName::name() const {
  // @@protoc_insertion_point(field_get:ReqSelectRepeatedName.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ReqSelectRepeatedName::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ReqSelectRepeatedName.name)
}
inline std::string* ReqSelectRepeatedName::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:ReqSelectRepeatedName.name)
  return _s;
}
inline const std::string& ReqSelectRepeatedName::_internal_name() const {
  return name_.Get();
}
inline void ReqSelectRepeatedName::_internal_set_name(const std::string& value) {
  
  name_.Set(value, GetArenaForAllocation());
}
inline std::string* ReqSelectRepeatedName::_internal_mutable_name() {
  
  return name_.Mutable(GetArenaForAllocation());
}
inline std::string* ReqSelectRepeatedName::release_name() {
  // @@protoc_insertion_point(field_release:ReqSelectRepeatedName.name)
  return name_.Release();
}
inline void ReqSelectRepeatedName::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (name_.IsDefault()) {
    name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ReqSelectRepeatedName.name)
}

// uint64 pid = 2;
inline void ReqSelectRepeatedName::clear_pid() {
  pid_ = uint64_t{0u};
}
inline uint64_t ReqSelectRepeatedName::_internal_pid() const {
  return pid_;
}
inline uint64_t ReqSelectRepeatedName::pid() const {
  // @@protoc_insertion_point(field_get:ReqSelectRepeatedName.pid)
  return _internal_pid();
}
inline void ReqSelectRepeatedName::_internal_set_pid(uint64_t value) {
  
  pid_ = value;
}
inline void ReqSelectRepeatedName::set_pid(uint64_t value) {
  _internal_set_pid(value);
  // @@protoc_insertion_point(field_set:ReqSelectRepeatedName.pid)
}

// -------------------------------------------------------------------

// ResSelectRepeatedName

// string name = 1;
inline void ResSelectRepeatedName::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& ResSelectRepeatedName::name() const {
  // @@protoc_insertion_point(field_get:ResSelectRepeatedName.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ResSelectRepeatedName::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ResSelectRepeatedName.name)
}
inline std::string* ResSelectRepeatedName::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:ResSelectRepeatedName.name)
  return _s;
}
inline const std::string& ResSelectRepeatedName::_internal_name() const {
  return name_.Get();
}
inline void ResSelectRepeatedName::_internal_set_name(const std::string& value) {
  
  name_.Set(value, GetArenaForAllocation());
}
inline std::string* ResSelectRepeatedName::_internal_mutable_name() {
  
  return name_.Mutable(GetArenaForAllocation());
}
inline std::string* ResSelectRepeatedName::release_name() {
  // @@protoc_insertion_point(field_release:ResSelectRepeatedName.name)
  return name_.Release();
}
inline void ResSelectRepeatedName::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (name_.IsDefault()) {
    name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ResSelectRepeatedName.name)
}

// int32 res = 2;
inline void ResSelectRepeatedName::clear_res() {
  res_ = 0;
}
inline int32_t ResSelectRepeatedName::_internal_res() const {
  return res_;
}
inline int32_t ResSelectRepeatedName::res() const {
  // @@protoc_insertion_point(field_get:ResSelectRepeatedName.res)
  return _internal_res();
}
inline void ResSelectRepeatedName::_internal_set_res(int32_t value) {
  
  res_ = value;
}
inline void ResSelectRepeatedName::set_res(int32_t value) {
  _internal_set_res(value);
  // @@protoc_insertion_point(field_set:ResSelectRepeatedName.res)
}

// uint64 pid = 3;
inline void ResSelectRepeatedName::clear_pid() {
  pid_ = uint64_t{0u};
}
inline uint64_t ResSelectRepeatedName::_internal_pid() const {
  return pid_;
}
inline uint64_t ResSelectRepeatedName::pid() const {
  // @@protoc_insertion_point(field_get:ResSelectRepeatedName.pid)
  return _internal_pid();
}
inline void ResSelectRepeatedName::_internal_set_pid(uint64_t value) {
  
  pid_ = value;
}
inline void ResSelectRepeatedName::set_pid(uint64_t value) {
  _internal_set_pid(value);
  // @@protoc_insertion_point(field_set:ResSelectRepeatedName.pid)
}

// -------------------------------------------------------------------

// ReqReturnNewName

// -------------------------------------------------------------------

// ResReturnNewName

// string name = 1;
inline void ResReturnNewName::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& ResReturnNewName::name() const {
  // @@protoc_insertion_point(field_get:ResReturnNewName.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ResReturnNewName::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ResReturnNewName.name)
}
inline std::string* ResReturnNewName::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:ResReturnNewName.name)
  return _s;
}
inline const std::string& ResReturnNewName::_internal_name() const {
  return name_.Get();
}
inline void ResReturnNewName::_internal_set_name(const std::string& value) {
  
  name_.Set(value, GetArenaForAllocation());
}
inline std::string* ResReturnNewName::_internal_mutable_name() {
  
  return name_.Mutable(GetArenaForAllocation());
}
inline std::string* ResReturnNewName::release_name() {
  // @@protoc_insertion_point(field_release:ResReturnNewName.name)
  return name_.Release();
}
inline void ResReturnNewName::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (name_.IsDefault()) {
    name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ResReturnNewName.name)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_ServerCommon_2eproto
